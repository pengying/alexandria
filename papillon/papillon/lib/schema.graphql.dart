class Input$BookCountOrderByAggregateInput {
  factory Input$BookCountOrderByAggregateInput({
    Enum$SortOrder? createdAt,
    Enum$SortOrder? title,
    Enum$SortOrder? updatedAt,
    Enum$SortOrder? uuid,
  }) =>
      Input$BookCountOrderByAggregateInput._({
        if (createdAt != null) r'createdAt': createdAt,
        if (title != null) r'title': title,
        if (updatedAt != null) r'updatedAt': updatedAt,
        if (uuid != null) r'uuid': uuid,
      });

  Input$BookCountOrderByAggregateInput._(this._$data);

  factory Input$BookCountOrderByAggregateInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : fromJson$Enum$SortOrder((l$createdAt as String));
    }
    if (data.containsKey('title')) {
      final l$title = data['title'];
      result$data['title'] =
          l$title == null ? null : fromJson$Enum$SortOrder((l$title as String));
    }
    if (data.containsKey('updatedAt')) {
      final l$updatedAt = data['updatedAt'];
      result$data['updatedAt'] = l$updatedAt == null
          ? null
          : fromJson$Enum$SortOrder((l$updatedAt as String));
    }
    if (data.containsKey('uuid')) {
      final l$uuid = data['uuid'];
      result$data['uuid'] =
          l$uuid == null ? null : fromJson$Enum$SortOrder((l$uuid as String));
    }
    return Input$BookCountOrderByAggregateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$SortOrder? get createdAt => (_$data['createdAt'] as Enum$SortOrder?);

  Enum$SortOrder? get title => (_$data['title'] as Enum$SortOrder?);

  Enum$SortOrder? get updatedAt => (_$data['updatedAt'] as Enum$SortOrder?);

  Enum$SortOrder? get uuid => (_$data['uuid'] as Enum$SortOrder?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] =
          l$createdAt == null ? null : toJson$Enum$SortOrder(l$createdAt);
    }
    if (_$data.containsKey('title')) {
      final l$title = title;
      result$data['title'] =
          l$title == null ? null : toJson$Enum$SortOrder(l$title);
    }
    if (_$data.containsKey('updatedAt')) {
      final l$updatedAt = updatedAt;
      result$data['updatedAt'] =
          l$updatedAt == null ? null : toJson$Enum$SortOrder(l$updatedAt);
    }
    if (_$data.containsKey('uuid')) {
      final l$uuid = uuid;
      result$data['uuid'] =
          l$uuid == null ? null : toJson$Enum$SortOrder(l$uuid);
    }
    return result$data;
  }

  CopyWith$Input$BookCountOrderByAggregateInput<
          Input$BookCountOrderByAggregateInput>
      get copyWith => CopyWith$Input$BookCountOrderByAggregateInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$BookCountOrderByAggregateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$title = title;
    final lOther$title = other.title;
    if (_$data.containsKey('title') != other._$data.containsKey('title')) {
      return false;
    }
    if (l$title != lOther$title) {
      return false;
    }
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (_$data.containsKey('updatedAt') !=
        other._$data.containsKey('updatedAt')) {
      return false;
    }
    if (l$updatedAt != lOther$updatedAt) {
      return false;
    }
    final l$uuid = uuid;
    final lOther$uuid = other.uuid;
    if (_$data.containsKey('uuid') != other._$data.containsKey('uuid')) {
      return false;
    }
    if (l$uuid != lOther$uuid) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$createdAt = createdAt;
    final l$title = title;
    final l$updatedAt = updatedAt;
    final l$uuid = uuid;
    return Object.hashAll([
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('title') ? l$title : const {},
      _$data.containsKey('updatedAt') ? l$updatedAt : const {},
      _$data.containsKey('uuid') ? l$uuid : const {},
    ]);
  }
}

abstract class CopyWith$Input$BookCountOrderByAggregateInput<TRes> {
  factory CopyWith$Input$BookCountOrderByAggregateInput(
    Input$BookCountOrderByAggregateInput instance,
    TRes Function(Input$BookCountOrderByAggregateInput) then,
  ) = _CopyWithImpl$Input$BookCountOrderByAggregateInput;

  factory CopyWith$Input$BookCountOrderByAggregateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$BookCountOrderByAggregateInput;

  TRes call({
    Enum$SortOrder? createdAt,
    Enum$SortOrder? title,
    Enum$SortOrder? updatedAt,
    Enum$SortOrder? uuid,
  });
}

class _CopyWithImpl$Input$BookCountOrderByAggregateInput<TRes>
    implements CopyWith$Input$BookCountOrderByAggregateInput<TRes> {
  _CopyWithImpl$Input$BookCountOrderByAggregateInput(
    this._instance,
    this._then,
  );

  final Input$BookCountOrderByAggregateInput _instance;

  final TRes Function(Input$BookCountOrderByAggregateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? createdAt = _undefined,
    Object? title = _undefined,
    Object? updatedAt = _undefined,
    Object? uuid = _undefined,
  }) =>
      _then(Input$BookCountOrderByAggregateInput._({
        ..._instance._$data,
        if (createdAt != _undefined)
          'createdAt': (createdAt as Enum$SortOrder?),
        if (title != _undefined) 'title': (title as Enum$SortOrder?),
        if (updatedAt != _undefined)
          'updatedAt': (updatedAt as Enum$SortOrder?),
        if (uuid != _undefined) 'uuid': (uuid as Enum$SortOrder?),
      }));
}

class _CopyWithStubImpl$Input$BookCountOrderByAggregateInput<TRes>
    implements CopyWith$Input$BookCountOrderByAggregateInput<TRes> {
  _CopyWithStubImpl$Input$BookCountOrderByAggregateInput(this._res);

  TRes _res;

  call({
    Enum$SortOrder? createdAt,
    Enum$SortOrder? title,
    Enum$SortOrder? updatedAt,
    Enum$SortOrder? uuid,
  }) =>
      _res;
}

class Input$BookCreateInput {
  factory Input$BookCreateInput({
    Input$BookRevisionCreateNestedOneWithoutBookEditedInput? bookEdited,
    Input$BookRevisionCreateNestedOneWithoutBookRawInput? bookRaw,
    String? createdAt,
    required String title,
    String? updatedAt,
    String? uuid,
  }) =>
      Input$BookCreateInput._({
        if (bookEdited != null) r'bookEdited': bookEdited,
        if (bookRaw != null) r'bookRaw': bookRaw,
        if (createdAt != null) r'createdAt': createdAt,
        r'title': title,
        if (updatedAt != null) r'updatedAt': updatedAt,
        if (uuid != null) r'uuid': uuid,
      });

  Input$BookCreateInput._(this._$data);

  factory Input$BookCreateInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('bookEdited')) {
      final l$bookEdited = data['bookEdited'];
      result$data['bookEdited'] = l$bookEdited == null
          ? null
          : Input$BookRevisionCreateNestedOneWithoutBookEditedInput.fromJson(
              (l$bookEdited as Map<String, dynamic>));
    }
    if (data.containsKey('bookRaw')) {
      final l$bookRaw = data['bookRaw'];
      result$data['bookRaw'] = l$bookRaw == null
          ? null
          : Input$BookRevisionCreateNestedOneWithoutBookRawInput.fromJson(
              (l$bookRaw as Map<String, dynamic>));
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = (l$createdAt as String?);
    }
    final l$title = data['title'];
    result$data['title'] = (l$title as String);
    if (data.containsKey('updatedAt')) {
      final l$updatedAt = data['updatedAt'];
      result$data['updatedAt'] = (l$updatedAt as String?);
    }
    if (data.containsKey('uuid')) {
      final l$uuid = data['uuid'];
      result$data['uuid'] = (l$uuid as String?);
    }
    return Input$BookCreateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$BookRevisionCreateNestedOneWithoutBookEditedInput? get bookEdited =>
      (_$data['bookEdited']
          as Input$BookRevisionCreateNestedOneWithoutBookEditedInput?);

  Input$BookRevisionCreateNestedOneWithoutBookRawInput? get bookRaw =>
      (_$data['bookRaw']
          as Input$BookRevisionCreateNestedOneWithoutBookRawInput?);

  String? get createdAt => (_$data['createdAt'] as String?);

  String get title => (_$data['title'] as String);

  String? get updatedAt => (_$data['updatedAt'] as String?);

  String? get uuid => (_$data['uuid'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('bookEdited')) {
      final l$bookEdited = bookEdited;
      result$data['bookEdited'] = l$bookEdited?.toJson();
    }
    if (_$data.containsKey('bookRaw')) {
      final l$bookRaw = bookRaw;
      result$data['bookRaw'] = l$bookRaw?.toJson();
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt;
    }
    final l$title = title;
    result$data['title'] = l$title;
    if (_$data.containsKey('updatedAt')) {
      final l$updatedAt = updatedAt;
      result$data['updatedAt'] = l$updatedAt;
    }
    if (_$data.containsKey('uuid')) {
      final l$uuid = uuid;
      result$data['uuid'] = l$uuid;
    }
    return result$data;
  }

  CopyWith$Input$BookCreateInput<Input$BookCreateInput> get copyWith =>
      CopyWith$Input$BookCreateInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$BookCreateInput) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$bookEdited = bookEdited;
    final lOther$bookEdited = other.bookEdited;
    if (_$data.containsKey('bookEdited') !=
        other._$data.containsKey('bookEdited')) {
      return false;
    }
    if (l$bookEdited != lOther$bookEdited) {
      return false;
    }
    final l$bookRaw = bookRaw;
    final lOther$bookRaw = other.bookRaw;
    if (_$data.containsKey('bookRaw') != other._$data.containsKey('bookRaw')) {
      return false;
    }
    if (l$bookRaw != lOther$bookRaw) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$title = title;
    final lOther$title = other.title;
    if (l$title != lOther$title) {
      return false;
    }
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (_$data.containsKey('updatedAt') !=
        other._$data.containsKey('updatedAt')) {
      return false;
    }
    if (l$updatedAt != lOther$updatedAt) {
      return false;
    }
    final l$uuid = uuid;
    final lOther$uuid = other.uuid;
    if (_$data.containsKey('uuid') != other._$data.containsKey('uuid')) {
      return false;
    }
    if (l$uuid != lOther$uuid) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$bookEdited = bookEdited;
    final l$bookRaw = bookRaw;
    final l$createdAt = createdAt;
    final l$title = title;
    final l$updatedAt = updatedAt;
    final l$uuid = uuid;
    return Object.hashAll([
      _$data.containsKey('bookEdited') ? l$bookEdited : const {},
      _$data.containsKey('bookRaw') ? l$bookRaw : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      l$title,
      _$data.containsKey('updatedAt') ? l$updatedAt : const {},
      _$data.containsKey('uuid') ? l$uuid : const {},
    ]);
  }
}

abstract class CopyWith$Input$BookCreateInput<TRes> {
  factory CopyWith$Input$BookCreateInput(
    Input$BookCreateInput instance,
    TRes Function(Input$BookCreateInput) then,
  ) = _CopyWithImpl$Input$BookCreateInput;

  factory CopyWith$Input$BookCreateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$BookCreateInput;

  TRes call({
    Input$BookRevisionCreateNestedOneWithoutBookEditedInput? bookEdited,
    Input$BookRevisionCreateNestedOneWithoutBookRawInput? bookRaw,
    String? createdAt,
    String? title,
    String? updatedAt,
    String? uuid,
  });
  CopyWith$Input$BookRevisionCreateNestedOneWithoutBookEditedInput<TRes>
      get bookEdited;
  CopyWith$Input$BookRevisionCreateNestedOneWithoutBookRawInput<TRes>
      get bookRaw;
}

class _CopyWithImpl$Input$BookCreateInput<TRes>
    implements CopyWith$Input$BookCreateInput<TRes> {
  _CopyWithImpl$Input$BookCreateInput(
    this._instance,
    this._then,
  );

  final Input$BookCreateInput _instance;

  final TRes Function(Input$BookCreateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? bookEdited = _undefined,
    Object? bookRaw = _undefined,
    Object? createdAt = _undefined,
    Object? title = _undefined,
    Object? updatedAt = _undefined,
    Object? uuid = _undefined,
  }) =>
      _then(Input$BookCreateInput._({
        ..._instance._$data,
        if (bookEdited != _undefined)
          'bookEdited': (bookEdited
              as Input$BookRevisionCreateNestedOneWithoutBookEditedInput?),
        if (bookRaw != _undefined)
          'bookRaw': (bookRaw
              as Input$BookRevisionCreateNestedOneWithoutBookRawInput?),
        if (createdAt != _undefined) 'createdAt': (createdAt as String?),
        if (title != _undefined && title != null) 'title': (title as String),
        if (updatedAt != _undefined) 'updatedAt': (updatedAt as String?),
        if (uuid != _undefined) 'uuid': (uuid as String?),
      }));

  CopyWith$Input$BookRevisionCreateNestedOneWithoutBookEditedInput<TRes>
      get bookEdited {
    final local$bookEdited = _instance.bookEdited;
    return local$bookEdited == null
        ? CopyWith$Input$BookRevisionCreateNestedOneWithoutBookEditedInput.stub(
            _then(_instance))
        : CopyWith$Input$BookRevisionCreateNestedOneWithoutBookEditedInput(
            local$bookEdited, (e) => call(bookEdited: e));
  }

  CopyWith$Input$BookRevisionCreateNestedOneWithoutBookRawInput<TRes>
      get bookRaw {
    final local$bookRaw = _instance.bookRaw;
    return local$bookRaw == null
        ? CopyWith$Input$BookRevisionCreateNestedOneWithoutBookRawInput.stub(
            _then(_instance))
        : CopyWith$Input$BookRevisionCreateNestedOneWithoutBookRawInput(
            local$bookRaw, (e) => call(bookRaw: e));
  }
}

class _CopyWithStubImpl$Input$BookCreateInput<TRes>
    implements CopyWith$Input$BookCreateInput<TRes> {
  _CopyWithStubImpl$Input$BookCreateInput(this._res);

  TRes _res;

  call({
    Input$BookRevisionCreateNestedOneWithoutBookEditedInput? bookEdited,
    Input$BookRevisionCreateNestedOneWithoutBookRawInput? bookRaw,
    String? createdAt,
    String? title,
    String? updatedAt,
    String? uuid,
  }) =>
      _res;

  CopyWith$Input$BookRevisionCreateNestedOneWithoutBookEditedInput<TRes>
      get bookEdited =>
          CopyWith$Input$BookRevisionCreateNestedOneWithoutBookEditedInput.stub(
              _res);

  CopyWith$Input$BookRevisionCreateNestedOneWithoutBookRawInput<TRes>
      get bookRaw =>
          CopyWith$Input$BookRevisionCreateNestedOneWithoutBookRawInput.stub(
              _res);
}

class Input$BookCreateManyInput {
  factory Input$BookCreateManyInput({
    String? createdAt,
    required String title,
    String? updatedAt,
    String? uuid,
  }) =>
      Input$BookCreateManyInput._({
        if (createdAt != null) r'createdAt': createdAt,
        r'title': title,
        if (updatedAt != null) r'updatedAt': updatedAt,
        if (uuid != null) r'uuid': uuid,
      });

  Input$BookCreateManyInput._(this._$data);

  factory Input$BookCreateManyInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = (l$createdAt as String?);
    }
    final l$title = data['title'];
    result$data['title'] = (l$title as String);
    if (data.containsKey('updatedAt')) {
      final l$updatedAt = data['updatedAt'];
      result$data['updatedAt'] = (l$updatedAt as String?);
    }
    if (data.containsKey('uuid')) {
      final l$uuid = data['uuid'];
      result$data['uuid'] = (l$uuid as String?);
    }
    return Input$BookCreateManyInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get createdAt => (_$data['createdAt'] as String?);

  String get title => (_$data['title'] as String);

  String? get updatedAt => (_$data['updatedAt'] as String?);

  String? get uuid => (_$data['uuid'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt;
    }
    final l$title = title;
    result$data['title'] = l$title;
    if (_$data.containsKey('updatedAt')) {
      final l$updatedAt = updatedAt;
      result$data['updatedAt'] = l$updatedAt;
    }
    if (_$data.containsKey('uuid')) {
      final l$uuid = uuid;
      result$data['uuid'] = l$uuid;
    }
    return result$data;
  }

  CopyWith$Input$BookCreateManyInput<Input$BookCreateManyInput> get copyWith =>
      CopyWith$Input$BookCreateManyInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$BookCreateManyInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$title = title;
    final lOther$title = other.title;
    if (l$title != lOther$title) {
      return false;
    }
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (_$data.containsKey('updatedAt') !=
        other._$data.containsKey('updatedAt')) {
      return false;
    }
    if (l$updatedAt != lOther$updatedAt) {
      return false;
    }
    final l$uuid = uuid;
    final lOther$uuid = other.uuid;
    if (_$data.containsKey('uuid') != other._$data.containsKey('uuid')) {
      return false;
    }
    if (l$uuid != lOther$uuid) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$createdAt = createdAt;
    final l$title = title;
    final l$updatedAt = updatedAt;
    final l$uuid = uuid;
    return Object.hashAll([
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      l$title,
      _$data.containsKey('updatedAt') ? l$updatedAt : const {},
      _$data.containsKey('uuid') ? l$uuid : const {},
    ]);
  }
}

abstract class CopyWith$Input$BookCreateManyInput<TRes> {
  factory CopyWith$Input$BookCreateManyInput(
    Input$BookCreateManyInput instance,
    TRes Function(Input$BookCreateManyInput) then,
  ) = _CopyWithImpl$Input$BookCreateManyInput;

  factory CopyWith$Input$BookCreateManyInput.stub(TRes res) =
      _CopyWithStubImpl$Input$BookCreateManyInput;

  TRes call({
    String? createdAt,
    String? title,
    String? updatedAt,
    String? uuid,
  });
}

class _CopyWithImpl$Input$BookCreateManyInput<TRes>
    implements CopyWith$Input$BookCreateManyInput<TRes> {
  _CopyWithImpl$Input$BookCreateManyInput(
    this._instance,
    this._then,
  );

  final Input$BookCreateManyInput _instance;

  final TRes Function(Input$BookCreateManyInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? createdAt = _undefined,
    Object? title = _undefined,
    Object? updatedAt = _undefined,
    Object? uuid = _undefined,
  }) =>
      _then(Input$BookCreateManyInput._({
        ..._instance._$data,
        if (createdAt != _undefined) 'createdAt': (createdAt as String?),
        if (title != _undefined && title != null) 'title': (title as String),
        if (updatedAt != _undefined) 'updatedAt': (updatedAt as String?),
        if (uuid != _undefined) 'uuid': (uuid as String?),
      }));
}

class _CopyWithStubImpl$Input$BookCreateManyInput<TRes>
    implements CopyWith$Input$BookCreateManyInput<TRes> {
  _CopyWithStubImpl$Input$BookCreateManyInput(this._res);

  TRes _res;

  call({
    String? createdAt,
    String? title,
    String? updatedAt,
    String? uuid,
  }) =>
      _res;
}

class Input$BookCreateNestedOneWithoutBookEditedInput {
  factory Input$BookCreateNestedOneWithoutBookEditedInput({
    Input$BookWhereUniqueInput? connect,
    Input$BookCreateOrConnectWithoutBookEditedInput? connectOrCreate,
    Input$BookCreateWithoutBookEditedInput? create,
  }) =>
      Input$BookCreateNestedOneWithoutBookEditedInput._({
        if (connect != null) r'connect': connect,
        if (connectOrCreate != null) r'connectOrCreate': connectOrCreate,
        if (create != null) r'create': create,
      });

  Input$BookCreateNestedOneWithoutBookEditedInput._(this._$data);

  factory Input$BookCreateNestedOneWithoutBookEditedInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('connect')) {
      final l$connect = data['connect'];
      result$data['connect'] = l$connect == null
          ? null
          : Input$BookWhereUniqueInput.fromJson(
              (l$connect as Map<String, dynamic>));
    }
    if (data.containsKey('connectOrCreate')) {
      final l$connectOrCreate = data['connectOrCreate'];
      result$data['connectOrCreate'] = l$connectOrCreate == null
          ? null
          : Input$BookCreateOrConnectWithoutBookEditedInput.fromJson(
              (l$connectOrCreate as Map<String, dynamic>));
    }
    if (data.containsKey('create')) {
      final l$create = data['create'];
      result$data['create'] = l$create == null
          ? null
          : Input$BookCreateWithoutBookEditedInput.fromJson(
              (l$create as Map<String, dynamic>));
    }
    return Input$BookCreateNestedOneWithoutBookEditedInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$BookWhereUniqueInput? get connect =>
      (_$data['connect'] as Input$BookWhereUniqueInput?);

  Input$BookCreateOrConnectWithoutBookEditedInput? get connectOrCreate =>
      (_$data['connectOrCreate']
          as Input$BookCreateOrConnectWithoutBookEditedInput?);

  Input$BookCreateWithoutBookEditedInput? get create =>
      (_$data['create'] as Input$BookCreateWithoutBookEditedInput?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('connect')) {
      final l$connect = connect;
      result$data['connect'] = l$connect?.toJson();
    }
    if (_$data.containsKey('connectOrCreate')) {
      final l$connectOrCreate = connectOrCreate;
      result$data['connectOrCreate'] = l$connectOrCreate?.toJson();
    }
    if (_$data.containsKey('create')) {
      final l$create = create;
      result$data['create'] = l$create?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$BookCreateNestedOneWithoutBookEditedInput<
          Input$BookCreateNestedOneWithoutBookEditedInput>
      get copyWith => CopyWith$Input$BookCreateNestedOneWithoutBookEditedInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$BookCreateNestedOneWithoutBookEditedInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$connect = connect;
    final lOther$connect = other.connect;
    if (_$data.containsKey('connect') != other._$data.containsKey('connect')) {
      return false;
    }
    if (l$connect != lOther$connect) {
      return false;
    }
    final l$connectOrCreate = connectOrCreate;
    final lOther$connectOrCreate = other.connectOrCreate;
    if (_$data.containsKey('connectOrCreate') !=
        other._$data.containsKey('connectOrCreate')) {
      return false;
    }
    if (l$connectOrCreate != lOther$connectOrCreate) {
      return false;
    }
    final l$create = create;
    final lOther$create = other.create;
    if (_$data.containsKey('create') != other._$data.containsKey('create')) {
      return false;
    }
    if (l$create != lOther$create) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$connect = connect;
    final l$connectOrCreate = connectOrCreate;
    final l$create = create;
    return Object.hashAll([
      _$data.containsKey('connect') ? l$connect : const {},
      _$data.containsKey('connectOrCreate') ? l$connectOrCreate : const {},
      _$data.containsKey('create') ? l$create : const {},
    ]);
  }
}

abstract class CopyWith$Input$BookCreateNestedOneWithoutBookEditedInput<TRes> {
  factory CopyWith$Input$BookCreateNestedOneWithoutBookEditedInput(
    Input$BookCreateNestedOneWithoutBookEditedInput instance,
    TRes Function(Input$BookCreateNestedOneWithoutBookEditedInput) then,
  ) = _CopyWithImpl$Input$BookCreateNestedOneWithoutBookEditedInput;

  factory CopyWith$Input$BookCreateNestedOneWithoutBookEditedInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$BookCreateNestedOneWithoutBookEditedInput;

  TRes call({
    Input$BookWhereUniqueInput? connect,
    Input$BookCreateOrConnectWithoutBookEditedInput? connectOrCreate,
    Input$BookCreateWithoutBookEditedInput? create,
  });
  CopyWith$Input$BookWhereUniqueInput<TRes> get connect;
  CopyWith$Input$BookCreateOrConnectWithoutBookEditedInput<TRes>
      get connectOrCreate;
  CopyWith$Input$BookCreateWithoutBookEditedInput<TRes> get create;
}

class _CopyWithImpl$Input$BookCreateNestedOneWithoutBookEditedInput<TRes>
    implements CopyWith$Input$BookCreateNestedOneWithoutBookEditedInput<TRes> {
  _CopyWithImpl$Input$BookCreateNestedOneWithoutBookEditedInput(
    this._instance,
    this._then,
  );

  final Input$BookCreateNestedOneWithoutBookEditedInput _instance;

  final TRes Function(Input$BookCreateNestedOneWithoutBookEditedInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? connect = _undefined,
    Object? connectOrCreate = _undefined,
    Object? create = _undefined,
  }) =>
      _then(Input$BookCreateNestedOneWithoutBookEditedInput._({
        ..._instance._$data,
        if (connect != _undefined)
          'connect': (connect as Input$BookWhereUniqueInput?),
        if (connectOrCreate != _undefined)
          'connectOrCreate': (connectOrCreate
              as Input$BookCreateOrConnectWithoutBookEditedInput?),
        if (create != _undefined)
          'create': (create as Input$BookCreateWithoutBookEditedInput?),
      }));

  CopyWith$Input$BookWhereUniqueInput<TRes> get connect {
    final local$connect = _instance.connect;
    return local$connect == null
        ? CopyWith$Input$BookWhereUniqueInput.stub(_then(_instance))
        : CopyWith$Input$BookWhereUniqueInput(
            local$connect, (e) => call(connect: e));
  }

  CopyWith$Input$BookCreateOrConnectWithoutBookEditedInput<TRes>
      get connectOrCreate {
    final local$connectOrCreate = _instance.connectOrCreate;
    return local$connectOrCreate == null
        ? CopyWith$Input$BookCreateOrConnectWithoutBookEditedInput.stub(
            _then(_instance))
        : CopyWith$Input$BookCreateOrConnectWithoutBookEditedInput(
            local$connectOrCreate, (e) => call(connectOrCreate: e));
  }

  CopyWith$Input$BookCreateWithoutBookEditedInput<TRes> get create {
    final local$create = _instance.create;
    return local$create == null
        ? CopyWith$Input$BookCreateWithoutBookEditedInput.stub(_then(_instance))
        : CopyWith$Input$BookCreateWithoutBookEditedInput(
            local$create, (e) => call(create: e));
  }
}

class _CopyWithStubImpl$Input$BookCreateNestedOneWithoutBookEditedInput<TRes>
    implements CopyWith$Input$BookCreateNestedOneWithoutBookEditedInput<TRes> {
  _CopyWithStubImpl$Input$BookCreateNestedOneWithoutBookEditedInput(this._res);

  TRes _res;

  call({
    Input$BookWhereUniqueInput? connect,
    Input$BookCreateOrConnectWithoutBookEditedInput? connectOrCreate,
    Input$BookCreateWithoutBookEditedInput? create,
  }) =>
      _res;

  CopyWith$Input$BookWhereUniqueInput<TRes> get connect =>
      CopyWith$Input$BookWhereUniqueInput.stub(_res);

  CopyWith$Input$BookCreateOrConnectWithoutBookEditedInput<TRes>
      get connectOrCreate =>
          CopyWith$Input$BookCreateOrConnectWithoutBookEditedInput.stub(_res);

  CopyWith$Input$BookCreateWithoutBookEditedInput<TRes> get create =>
      CopyWith$Input$BookCreateWithoutBookEditedInput.stub(_res);
}

class Input$BookCreateNestedOneWithoutBookRawInput {
  factory Input$BookCreateNestedOneWithoutBookRawInput({
    Input$BookWhereUniqueInput? connect,
    Input$BookCreateOrConnectWithoutBookRawInput? connectOrCreate,
    Input$BookCreateWithoutBookRawInput? create,
  }) =>
      Input$BookCreateNestedOneWithoutBookRawInput._({
        if (connect != null) r'connect': connect,
        if (connectOrCreate != null) r'connectOrCreate': connectOrCreate,
        if (create != null) r'create': create,
      });

  Input$BookCreateNestedOneWithoutBookRawInput._(this._$data);

  factory Input$BookCreateNestedOneWithoutBookRawInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('connect')) {
      final l$connect = data['connect'];
      result$data['connect'] = l$connect == null
          ? null
          : Input$BookWhereUniqueInput.fromJson(
              (l$connect as Map<String, dynamic>));
    }
    if (data.containsKey('connectOrCreate')) {
      final l$connectOrCreate = data['connectOrCreate'];
      result$data['connectOrCreate'] = l$connectOrCreate == null
          ? null
          : Input$BookCreateOrConnectWithoutBookRawInput.fromJson(
              (l$connectOrCreate as Map<String, dynamic>));
    }
    if (data.containsKey('create')) {
      final l$create = data['create'];
      result$data['create'] = l$create == null
          ? null
          : Input$BookCreateWithoutBookRawInput.fromJson(
              (l$create as Map<String, dynamic>));
    }
    return Input$BookCreateNestedOneWithoutBookRawInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$BookWhereUniqueInput? get connect =>
      (_$data['connect'] as Input$BookWhereUniqueInput?);

  Input$BookCreateOrConnectWithoutBookRawInput? get connectOrCreate =>
      (_$data['connectOrCreate']
          as Input$BookCreateOrConnectWithoutBookRawInput?);

  Input$BookCreateWithoutBookRawInput? get create =>
      (_$data['create'] as Input$BookCreateWithoutBookRawInput?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('connect')) {
      final l$connect = connect;
      result$data['connect'] = l$connect?.toJson();
    }
    if (_$data.containsKey('connectOrCreate')) {
      final l$connectOrCreate = connectOrCreate;
      result$data['connectOrCreate'] = l$connectOrCreate?.toJson();
    }
    if (_$data.containsKey('create')) {
      final l$create = create;
      result$data['create'] = l$create?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$BookCreateNestedOneWithoutBookRawInput<
          Input$BookCreateNestedOneWithoutBookRawInput>
      get copyWith => CopyWith$Input$BookCreateNestedOneWithoutBookRawInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$BookCreateNestedOneWithoutBookRawInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$connect = connect;
    final lOther$connect = other.connect;
    if (_$data.containsKey('connect') != other._$data.containsKey('connect')) {
      return false;
    }
    if (l$connect != lOther$connect) {
      return false;
    }
    final l$connectOrCreate = connectOrCreate;
    final lOther$connectOrCreate = other.connectOrCreate;
    if (_$data.containsKey('connectOrCreate') !=
        other._$data.containsKey('connectOrCreate')) {
      return false;
    }
    if (l$connectOrCreate != lOther$connectOrCreate) {
      return false;
    }
    final l$create = create;
    final lOther$create = other.create;
    if (_$data.containsKey('create') != other._$data.containsKey('create')) {
      return false;
    }
    if (l$create != lOther$create) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$connect = connect;
    final l$connectOrCreate = connectOrCreate;
    final l$create = create;
    return Object.hashAll([
      _$data.containsKey('connect') ? l$connect : const {},
      _$data.containsKey('connectOrCreate') ? l$connectOrCreate : const {},
      _$data.containsKey('create') ? l$create : const {},
    ]);
  }
}

abstract class CopyWith$Input$BookCreateNestedOneWithoutBookRawInput<TRes> {
  factory CopyWith$Input$BookCreateNestedOneWithoutBookRawInput(
    Input$BookCreateNestedOneWithoutBookRawInput instance,
    TRes Function(Input$BookCreateNestedOneWithoutBookRawInput) then,
  ) = _CopyWithImpl$Input$BookCreateNestedOneWithoutBookRawInput;

  factory CopyWith$Input$BookCreateNestedOneWithoutBookRawInput.stub(TRes res) =
      _CopyWithStubImpl$Input$BookCreateNestedOneWithoutBookRawInput;

  TRes call({
    Input$BookWhereUniqueInput? connect,
    Input$BookCreateOrConnectWithoutBookRawInput? connectOrCreate,
    Input$BookCreateWithoutBookRawInput? create,
  });
  CopyWith$Input$BookWhereUniqueInput<TRes> get connect;
  CopyWith$Input$BookCreateOrConnectWithoutBookRawInput<TRes>
      get connectOrCreate;
  CopyWith$Input$BookCreateWithoutBookRawInput<TRes> get create;
}

class _CopyWithImpl$Input$BookCreateNestedOneWithoutBookRawInput<TRes>
    implements CopyWith$Input$BookCreateNestedOneWithoutBookRawInput<TRes> {
  _CopyWithImpl$Input$BookCreateNestedOneWithoutBookRawInput(
    this._instance,
    this._then,
  );

  final Input$BookCreateNestedOneWithoutBookRawInput _instance;

  final TRes Function(Input$BookCreateNestedOneWithoutBookRawInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? connect = _undefined,
    Object? connectOrCreate = _undefined,
    Object? create = _undefined,
  }) =>
      _then(Input$BookCreateNestedOneWithoutBookRawInput._({
        ..._instance._$data,
        if (connect != _undefined)
          'connect': (connect as Input$BookWhereUniqueInput?),
        if (connectOrCreate != _undefined)
          'connectOrCreate': (connectOrCreate
              as Input$BookCreateOrConnectWithoutBookRawInput?),
        if (create != _undefined)
          'create': (create as Input$BookCreateWithoutBookRawInput?),
      }));

  CopyWith$Input$BookWhereUniqueInput<TRes> get connect {
    final local$connect = _instance.connect;
    return local$connect == null
        ? CopyWith$Input$BookWhereUniqueInput.stub(_then(_instance))
        : CopyWith$Input$BookWhereUniqueInput(
            local$connect, (e) => call(connect: e));
  }

  CopyWith$Input$BookCreateOrConnectWithoutBookRawInput<TRes>
      get connectOrCreate {
    final local$connectOrCreate = _instance.connectOrCreate;
    return local$connectOrCreate == null
        ? CopyWith$Input$BookCreateOrConnectWithoutBookRawInput.stub(
            _then(_instance))
        : CopyWith$Input$BookCreateOrConnectWithoutBookRawInput(
            local$connectOrCreate, (e) => call(connectOrCreate: e));
  }

  CopyWith$Input$BookCreateWithoutBookRawInput<TRes> get create {
    final local$create = _instance.create;
    return local$create == null
        ? CopyWith$Input$BookCreateWithoutBookRawInput.stub(_then(_instance))
        : CopyWith$Input$BookCreateWithoutBookRawInput(
            local$create, (e) => call(create: e));
  }
}

class _CopyWithStubImpl$Input$BookCreateNestedOneWithoutBookRawInput<TRes>
    implements CopyWith$Input$BookCreateNestedOneWithoutBookRawInput<TRes> {
  _CopyWithStubImpl$Input$BookCreateNestedOneWithoutBookRawInput(this._res);

  TRes _res;

  call({
    Input$BookWhereUniqueInput? connect,
    Input$BookCreateOrConnectWithoutBookRawInput? connectOrCreate,
    Input$BookCreateWithoutBookRawInput? create,
  }) =>
      _res;

  CopyWith$Input$BookWhereUniqueInput<TRes> get connect =>
      CopyWith$Input$BookWhereUniqueInput.stub(_res);

  CopyWith$Input$BookCreateOrConnectWithoutBookRawInput<TRes>
      get connectOrCreate =>
          CopyWith$Input$BookCreateOrConnectWithoutBookRawInput.stub(_res);

  CopyWith$Input$BookCreateWithoutBookRawInput<TRes> get create =>
      CopyWith$Input$BookCreateWithoutBookRawInput.stub(_res);
}

class Input$BookCreateOrConnectWithoutBookEditedInput {
  factory Input$BookCreateOrConnectWithoutBookEditedInput({
    required Input$BookCreateWithoutBookEditedInput create,
    required Input$BookWhereUniqueInput where,
  }) =>
      Input$BookCreateOrConnectWithoutBookEditedInput._({
        r'create': create,
        r'where': where,
      });

  Input$BookCreateOrConnectWithoutBookEditedInput._(this._$data);

  factory Input$BookCreateOrConnectWithoutBookEditedInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$create = data['create'];
    result$data['create'] = Input$BookCreateWithoutBookEditedInput.fromJson(
        (l$create as Map<String, dynamic>));
    final l$where = data['where'];
    result$data['where'] =
        Input$BookWhereUniqueInput.fromJson((l$where as Map<String, dynamic>));
    return Input$BookCreateOrConnectWithoutBookEditedInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$BookCreateWithoutBookEditedInput get create =>
      (_$data['create'] as Input$BookCreateWithoutBookEditedInput);

  Input$BookWhereUniqueInput get where =>
      (_$data['where'] as Input$BookWhereUniqueInput);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$create = create;
    result$data['create'] = l$create.toJson();
    final l$where = where;
    result$data['where'] = l$where.toJson();
    return result$data;
  }

  CopyWith$Input$BookCreateOrConnectWithoutBookEditedInput<
          Input$BookCreateOrConnectWithoutBookEditedInput>
      get copyWith => CopyWith$Input$BookCreateOrConnectWithoutBookEditedInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$BookCreateOrConnectWithoutBookEditedInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != lOther$create) {
      return false;
    }
    final l$where = where;
    final lOther$where = other.where;
    if (l$where != lOther$where) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$create = create;
    final l$where = where;
    return Object.hashAll([
      l$create,
      l$where,
    ]);
  }
}

abstract class CopyWith$Input$BookCreateOrConnectWithoutBookEditedInput<TRes> {
  factory CopyWith$Input$BookCreateOrConnectWithoutBookEditedInput(
    Input$BookCreateOrConnectWithoutBookEditedInput instance,
    TRes Function(Input$BookCreateOrConnectWithoutBookEditedInput) then,
  ) = _CopyWithImpl$Input$BookCreateOrConnectWithoutBookEditedInput;

  factory CopyWith$Input$BookCreateOrConnectWithoutBookEditedInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$BookCreateOrConnectWithoutBookEditedInput;

  TRes call({
    Input$BookCreateWithoutBookEditedInput? create,
    Input$BookWhereUniqueInput? where,
  });
  CopyWith$Input$BookCreateWithoutBookEditedInput<TRes> get create;
  CopyWith$Input$BookWhereUniqueInput<TRes> get where;
}

class _CopyWithImpl$Input$BookCreateOrConnectWithoutBookEditedInput<TRes>
    implements CopyWith$Input$BookCreateOrConnectWithoutBookEditedInput<TRes> {
  _CopyWithImpl$Input$BookCreateOrConnectWithoutBookEditedInput(
    this._instance,
    this._then,
  );

  final Input$BookCreateOrConnectWithoutBookEditedInput _instance;

  final TRes Function(Input$BookCreateOrConnectWithoutBookEditedInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? create = _undefined,
    Object? where = _undefined,
  }) =>
      _then(Input$BookCreateOrConnectWithoutBookEditedInput._({
        ..._instance._$data,
        if (create != _undefined && create != null)
          'create': (create as Input$BookCreateWithoutBookEditedInput),
        if (where != _undefined && where != null)
          'where': (where as Input$BookWhereUniqueInput),
      }));

  CopyWith$Input$BookCreateWithoutBookEditedInput<TRes> get create {
    final local$create = _instance.create;
    return CopyWith$Input$BookCreateWithoutBookEditedInput(
        local$create, (e) => call(create: e));
  }

  CopyWith$Input$BookWhereUniqueInput<TRes> get where {
    final local$where = _instance.where;
    return CopyWith$Input$BookWhereUniqueInput(
        local$where, (e) => call(where: e));
  }
}

class _CopyWithStubImpl$Input$BookCreateOrConnectWithoutBookEditedInput<TRes>
    implements CopyWith$Input$BookCreateOrConnectWithoutBookEditedInput<TRes> {
  _CopyWithStubImpl$Input$BookCreateOrConnectWithoutBookEditedInput(this._res);

  TRes _res;

  call({
    Input$BookCreateWithoutBookEditedInput? create,
    Input$BookWhereUniqueInput? where,
  }) =>
      _res;

  CopyWith$Input$BookCreateWithoutBookEditedInput<TRes> get create =>
      CopyWith$Input$BookCreateWithoutBookEditedInput.stub(_res);

  CopyWith$Input$BookWhereUniqueInput<TRes> get where =>
      CopyWith$Input$BookWhereUniqueInput.stub(_res);
}

class Input$BookCreateOrConnectWithoutBookRawInput {
  factory Input$BookCreateOrConnectWithoutBookRawInput({
    required Input$BookCreateWithoutBookRawInput create,
    required Input$BookWhereUniqueInput where,
  }) =>
      Input$BookCreateOrConnectWithoutBookRawInput._({
        r'create': create,
        r'where': where,
      });

  Input$BookCreateOrConnectWithoutBookRawInput._(this._$data);

  factory Input$BookCreateOrConnectWithoutBookRawInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$create = data['create'];
    result$data['create'] = Input$BookCreateWithoutBookRawInput.fromJson(
        (l$create as Map<String, dynamic>));
    final l$where = data['where'];
    result$data['where'] =
        Input$BookWhereUniqueInput.fromJson((l$where as Map<String, dynamic>));
    return Input$BookCreateOrConnectWithoutBookRawInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$BookCreateWithoutBookRawInput get create =>
      (_$data['create'] as Input$BookCreateWithoutBookRawInput);

  Input$BookWhereUniqueInput get where =>
      (_$data['where'] as Input$BookWhereUniqueInput);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$create = create;
    result$data['create'] = l$create.toJson();
    final l$where = where;
    result$data['where'] = l$where.toJson();
    return result$data;
  }

  CopyWith$Input$BookCreateOrConnectWithoutBookRawInput<
          Input$BookCreateOrConnectWithoutBookRawInput>
      get copyWith => CopyWith$Input$BookCreateOrConnectWithoutBookRawInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$BookCreateOrConnectWithoutBookRawInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != lOther$create) {
      return false;
    }
    final l$where = where;
    final lOther$where = other.where;
    if (l$where != lOther$where) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$create = create;
    final l$where = where;
    return Object.hashAll([
      l$create,
      l$where,
    ]);
  }
}

abstract class CopyWith$Input$BookCreateOrConnectWithoutBookRawInput<TRes> {
  factory CopyWith$Input$BookCreateOrConnectWithoutBookRawInput(
    Input$BookCreateOrConnectWithoutBookRawInput instance,
    TRes Function(Input$BookCreateOrConnectWithoutBookRawInput) then,
  ) = _CopyWithImpl$Input$BookCreateOrConnectWithoutBookRawInput;

  factory CopyWith$Input$BookCreateOrConnectWithoutBookRawInput.stub(TRes res) =
      _CopyWithStubImpl$Input$BookCreateOrConnectWithoutBookRawInput;

  TRes call({
    Input$BookCreateWithoutBookRawInput? create,
    Input$BookWhereUniqueInput? where,
  });
  CopyWith$Input$BookCreateWithoutBookRawInput<TRes> get create;
  CopyWith$Input$BookWhereUniqueInput<TRes> get where;
}

class _CopyWithImpl$Input$BookCreateOrConnectWithoutBookRawInput<TRes>
    implements CopyWith$Input$BookCreateOrConnectWithoutBookRawInput<TRes> {
  _CopyWithImpl$Input$BookCreateOrConnectWithoutBookRawInput(
    this._instance,
    this._then,
  );

  final Input$BookCreateOrConnectWithoutBookRawInput _instance;

  final TRes Function(Input$BookCreateOrConnectWithoutBookRawInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? create = _undefined,
    Object? where = _undefined,
  }) =>
      _then(Input$BookCreateOrConnectWithoutBookRawInput._({
        ..._instance._$data,
        if (create != _undefined && create != null)
          'create': (create as Input$BookCreateWithoutBookRawInput),
        if (where != _undefined && where != null)
          'where': (where as Input$BookWhereUniqueInput),
      }));

  CopyWith$Input$BookCreateWithoutBookRawInput<TRes> get create {
    final local$create = _instance.create;
    return CopyWith$Input$BookCreateWithoutBookRawInput(
        local$create, (e) => call(create: e));
  }

  CopyWith$Input$BookWhereUniqueInput<TRes> get where {
    final local$where = _instance.where;
    return CopyWith$Input$BookWhereUniqueInput(
        local$where, (e) => call(where: e));
  }
}

class _CopyWithStubImpl$Input$BookCreateOrConnectWithoutBookRawInput<TRes>
    implements CopyWith$Input$BookCreateOrConnectWithoutBookRawInput<TRes> {
  _CopyWithStubImpl$Input$BookCreateOrConnectWithoutBookRawInput(this._res);

  TRes _res;

  call({
    Input$BookCreateWithoutBookRawInput? create,
    Input$BookWhereUniqueInput? where,
  }) =>
      _res;

  CopyWith$Input$BookCreateWithoutBookRawInput<TRes> get create =>
      CopyWith$Input$BookCreateWithoutBookRawInput.stub(_res);

  CopyWith$Input$BookWhereUniqueInput<TRes> get where =>
      CopyWith$Input$BookWhereUniqueInput.stub(_res);
}

class Input$BookCreateWithoutBookEditedInput {
  factory Input$BookCreateWithoutBookEditedInput({
    Input$BookRevisionCreateNestedOneWithoutBookRawInput? bookRaw,
    String? createdAt,
    required String title,
    String? updatedAt,
    String? uuid,
  }) =>
      Input$BookCreateWithoutBookEditedInput._({
        if (bookRaw != null) r'bookRaw': bookRaw,
        if (createdAt != null) r'createdAt': createdAt,
        r'title': title,
        if (updatedAt != null) r'updatedAt': updatedAt,
        if (uuid != null) r'uuid': uuid,
      });

  Input$BookCreateWithoutBookEditedInput._(this._$data);

  factory Input$BookCreateWithoutBookEditedInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('bookRaw')) {
      final l$bookRaw = data['bookRaw'];
      result$data['bookRaw'] = l$bookRaw == null
          ? null
          : Input$BookRevisionCreateNestedOneWithoutBookRawInput.fromJson(
              (l$bookRaw as Map<String, dynamic>));
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = (l$createdAt as String?);
    }
    final l$title = data['title'];
    result$data['title'] = (l$title as String);
    if (data.containsKey('updatedAt')) {
      final l$updatedAt = data['updatedAt'];
      result$data['updatedAt'] = (l$updatedAt as String?);
    }
    if (data.containsKey('uuid')) {
      final l$uuid = data['uuid'];
      result$data['uuid'] = (l$uuid as String?);
    }
    return Input$BookCreateWithoutBookEditedInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$BookRevisionCreateNestedOneWithoutBookRawInput? get bookRaw =>
      (_$data['bookRaw']
          as Input$BookRevisionCreateNestedOneWithoutBookRawInput?);

  String? get createdAt => (_$data['createdAt'] as String?);

  String get title => (_$data['title'] as String);

  String? get updatedAt => (_$data['updatedAt'] as String?);

  String? get uuid => (_$data['uuid'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('bookRaw')) {
      final l$bookRaw = bookRaw;
      result$data['bookRaw'] = l$bookRaw?.toJson();
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt;
    }
    final l$title = title;
    result$data['title'] = l$title;
    if (_$data.containsKey('updatedAt')) {
      final l$updatedAt = updatedAt;
      result$data['updatedAt'] = l$updatedAt;
    }
    if (_$data.containsKey('uuid')) {
      final l$uuid = uuid;
      result$data['uuid'] = l$uuid;
    }
    return result$data;
  }

  CopyWith$Input$BookCreateWithoutBookEditedInput<
          Input$BookCreateWithoutBookEditedInput>
      get copyWith => CopyWith$Input$BookCreateWithoutBookEditedInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$BookCreateWithoutBookEditedInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$bookRaw = bookRaw;
    final lOther$bookRaw = other.bookRaw;
    if (_$data.containsKey('bookRaw') != other._$data.containsKey('bookRaw')) {
      return false;
    }
    if (l$bookRaw != lOther$bookRaw) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$title = title;
    final lOther$title = other.title;
    if (l$title != lOther$title) {
      return false;
    }
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (_$data.containsKey('updatedAt') !=
        other._$data.containsKey('updatedAt')) {
      return false;
    }
    if (l$updatedAt != lOther$updatedAt) {
      return false;
    }
    final l$uuid = uuid;
    final lOther$uuid = other.uuid;
    if (_$data.containsKey('uuid') != other._$data.containsKey('uuid')) {
      return false;
    }
    if (l$uuid != lOther$uuid) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$bookRaw = bookRaw;
    final l$createdAt = createdAt;
    final l$title = title;
    final l$updatedAt = updatedAt;
    final l$uuid = uuid;
    return Object.hashAll([
      _$data.containsKey('bookRaw') ? l$bookRaw : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      l$title,
      _$data.containsKey('updatedAt') ? l$updatedAt : const {},
      _$data.containsKey('uuid') ? l$uuid : const {},
    ]);
  }
}

abstract class CopyWith$Input$BookCreateWithoutBookEditedInput<TRes> {
  factory CopyWith$Input$BookCreateWithoutBookEditedInput(
    Input$BookCreateWithoutBookEditedInput instance,
    TRes Function(Input$BookCreateWithoutBookEditedInput) then,
  ) = _CopyWithImpl$Input$BookCreateWithoutBookEditedInput;

  factory CopyWith$Input$BookCreateWithoutBookEditedInput.stub(TRes res) =
      _CopyWithStubImpl$Input$BookCreateWithoutBookEditedInput;

  TRes call({
    Input$BookRevisionCreateNestedOneWithoutBookRawInput? bookRaw,
    String? createdAt,
    String? title,
    String? updatedAt,
    String? uuid,
  });
  CopyWith$Input$BookRevisionCreateNestedOneWithoutBookRawInput<TRes>
      get bookRaw;
}

class _CopyWithImpl$Input$BookCreateWithoutBookEditedInput<TRes>
    implements CopyWith$Input$BookCreateWithoutBookEditedInput<TRes> {
  _CopyWithImpl$Input$BookCreateWithoutBookEditedInput(
    this._instance,
    this._then,
  );

  final Input$BookCreateWithoutBookEditedInput _instance;

  final TRes Function(Input$BookCreateWithoutBookEditedInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? bookRaw = _undefined,
    Object? createdAt = _undefined,
    Object? title = _undefined,
    Object? updatedAt = _undefined,
    Object? uuid = _undefined,
  }) =>
      _then(Input$BookCreateWithoutBookEditedInput._({
        ..._instance._$data,
        if (bookRaw != _undefined)
          'bookRaw': (bookRaw
              as Input$BookRevisionCreateNestedOneWithoutBookRawInput?),
        if (createdAt != _undefined) 'createdAt': (createdAt as String?),
        if (title != _undefined && title != null) 'title': (title as String),
        if (updatedAt != _undefined) 'updatedAt': (updatedAt as String?),
        if (uuid != _undefined) 'uuid': (uuid as String?),
      }));

  CopyWith$Input$BookRevisionCreateNestedOneWithoutBookRawInput<TRes>
      get bookRaw {
    final local$bookRaw = _instance.bookRaw;
    return local$bookRaw == null
        ? CopyWith$Input$BookRevisionCreateNestedOneWithoutBookRawInput.stub(
            _then(_instance))
        : CopyWith$Input$BookRevisionCreateNestedOneWithoutBookRawInput(
            local$bookRaw, (e) => call(bookRaw: e));
  }
}

class _CopyWithStubImpl$Input$BookCreateWithoutBookEditedInput<TRes>
    implements CopyWith$Input$BookCreateWithoutBookEditedInput<TRes> {
  _CopyWithStubImpl$Input$BookCreateWithoutBookEditedInput(this._res);

  TRes _res;

  call({
    Input$BookRevisionCreateNestedOneWithoutBookRawInput? bookRaw,
    String? createdAt,
    String? title,
    String? updatedAt,
    String? uuid,
  }) =>
      _res;

  CopyWith$Input$BookRevisionCreateNestedOneWithoutBookRawInput<TRes>
      get bookRaw =>
          CopyWith$Input$BookRevisionCreateNestedOneWithoutBookRawInput.stub(
              _res);
}

class Input$BookCreateWithoutBookRawInput {
  factory Input$BookCreateWithoutBookRawInput({
    Input$BookRevisionCreateNestedOneWithoutBookEditedInput? bookEdited,
    String? createdAt,
    required String title,
    String? updatedAt,
    String? uuid,
  }) =>
      Input$BookCreateWithoutBookRawInput._({
        if (bookEdited != null) r'bookEdited': bookEdited,
        if (createdAt != null) r'createdAt': createdAt,
        r'title': title,
        if (updatedAt != null) r'updatedAt': updatedAt,
        if (uuid != null) r'uuid': uuid,
      });

  Input$BookCreateWithoutBookRawInput._(this._$data);

  factory Input$BookCreateWithoutBookRawInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('bookEdited')) {
      final l$bookEdited = data['bookEdited'];
      result$data['bookEdited'] = l$bookEdited == null
          ? null
          : Input$BookRevisionCreateNestedOneWithoutBookEditedInput.fromJson(
              (l$bookEdited as Map<String, dynamic>));
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = (l$createdAt as String?);
    }
    final l$title = data['title'];
    result$data['title'] = (l$title as String);
    if (data.containsKey('updatedAt')) {
      final l$updatedAt = data['updatedAt'];
      result$data['updatedAt'] = (l$updatedAt as String?);
    }
    if (data.containsKey('uuid')) {
      final l$uuid = data['uuid'];
      result$data['uuid'] = (l$uuid as String?);
    }
    return Input$BookCreateWithoutBookRawInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$BookRevisionCreateNestedOneWithoutBookEditedInput? get bookEdited =>
      (_$data['bookEdited']
          as Input$BookRevisionCreateNestedOneWithoutBookEditedInput?);

  String? get createdAt => (_$data['createdAt'] as String?);

  String get title => (_$data['title'] as String);

  String? get updatedAt => (_$data['updatedAt'] as String?);

  String? get uuid => (_$data['uuid'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('bookEdited')) {
      final l$bookEdited = bookEdited;
      result$data['bookEdited'] = l$bookEdited?.toJson();
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt;
    }
    final l$title = title;
    result$data['title'] = l$title;
    if (_$data.containsKey('updatedAt')) {
      final l$updatedAt = updatedAt;
      result$data['updatedAt'] = l$updatedAt;
    }
    if (_$data.containsKey('uuid')) {
      final l$uuid = uuid;
      result$data['uuid'] = l$uuid;
    }
    return result$data;
  }

  CopyWith$Input$BookCreateWithoutBookRawInput<
          Input$BookCreateWithoutBookRawInput>
      get copyWith => CopyWith$Input$BookCreateWithoutBookRawInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$BookCreateWithoutBookRawInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$bookEdited = bookEdited;
    final lOther$bookEdited = other.bookEdited;
    if (_$data.containsKey('bookEdited') !=
        other._$data.containsKey('bookEdited')) {
      return false;
    }
    if (l$bookEdited != lOther$bookEdited) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$title = title;
    final lOther$title = other.title;
    if (l$title != lOther$title) {
      return false;
    }
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (_$data.containsKey('updatedAt') !=
        other._$data.containsKey('updatedAt')) {
      return false;
    }
    if (l$updatedAt != lOther$updatedAt) {
      return false;
    }
    final l$uuid = uuid;
    final lOther$uuid = other.uuid;
    if (_$data.containsKey('uuid') != other._$data.containsKey('uuid')) {
      return false;
    }
    if (l$uuid != lOther$uuid) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$bookEdited = bookEdited;
    final l$createdAt = createdAt;
    final l$title = title;
    final l$updatedAt = updatedAt;
    final l$uuid = uuid;
    return Object.hashAll([
      _$data.containsKey('bookEdited') ? l$bookEdited : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      l$title,
      _$data.containsKey('updatedAt') ? l$updatedAt : const {},
      _$data.containsKey('uuid') ? l$uuid : const {},
    ]);
  }
}

abstract class CopyWith$Input$BookCreateWithoutBookRawInput<TRes> {
  factory CopyWith$Input$BookCreateWithoutBookRawInput(
    Input$BookCreateWithoutBookRawInput instance,
    TRes Function(Input$BookCreateWithoutBookRawInput) then,
  ) = _CopyWithImpl$Input$BookCreateWithoutBookRawInput;

  factory CopyWith$Input$BookCreateWithoutBookRawInput.stub(TRes res) =
      _CopyWithStubImpl$Input$BookCreateWithoutBookRawInput;

  TRes call({
    Input$BookRevisionCreateNestedOneWithoutBookEditedInput? bookEdited,
    String? createdAt,
    String? title,
    String? updatedAt,
    String? uuid,
  });
  CopyWith$Input$BookRevisionCreateNestedOneWithoutBookEditedInput<TRes>
      get bookEdited;
}

class _CopyWithImpl$Input$BookCreateWithoutBookRawInput<TRes>
    implements CopyWith$Input$BookCreateWithoutBookRawInput<TRes> {
  _CopyWithImpl$Input$BookCreateWithoutBookRawInput(
    this._instance,
    this._then,
  );

  final Input$BookCreateWithoutBookRawInput _instance;

  final TRes Function(Input$BookCreateWithoutBookRawInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? bookEdited = _undefined,
    Object? createdAt = _undefined,
    Object? title = _undefined,
    Object? updatedAt = _undefined,
    Object? uuid = _undefined,
  }) =>
      _then(Input$BookCreateWithoutBookRawInput._({
        ..._instance._$data,
        if (bookEdited != _undefined)
          'bookEdited': (bookEdited
              as Input$BookRevisionCreateNestedOneWithoutBookEditedInput?),
        if (createdAt != _undefined) 'createdAt': (createdAt as String?),
        if (title != _undefined && title != null) 'title': (title as String),
        if (updatedAt != _undefined) 'updatedAt': (updatedAt as String?),
        if (uuid != _undefined) 'uuid': (uuid as String?),
      }));

  CopyWith$Input$BookRevisionCreateNestedOneWithoutBookEditedInput<TRes>
      get bookEdited {
    final local$bookEdited = _instance.bookEdited;
    return local$bookEdited == null
        ? CopyWith$Input$BookRevisionCreateNestedOneWithoutBookEditedInput.stub(
            _then(_instance))
        : CopyWith$Input$BookRevisionCreateNestedOneWithoutBookEditedInput(
            local$bookEdited, (e) => call(bookEdited: e));
  }
}

class _CopyWithStubImpl$Input$BookCreateWithoutBookRawInput<TRes>
    implements CopyWith$Input$BookCreateWithoutBookRawInput<TRes> {
  _CopyWithStubImpl$Input$BookCreateWithoutBookRawInput(this._res);

  TRes _res;

  call({
    Input$BookRevisionCreateNestedOneWithoutBookEditedInput? bookEdited,
    String? createdAt,
    String? title,
    String? updatedAt,
    String? uuid,
  }) =>
      _res;

  CopyWith$Input$BookRevisionCreateNestedOneWithoutBookEditedInput<TRes>
      get bookEdited =>
          CopyWith$Input$BookRevisionCreateNestedOneWithoutBookEditedInput.stub(
              _res);
}

class Input$BookMaxOrderByAggregateInput {
  factory Input$BookMaxOrderByAggregateInput({
    Enum$SortOrder? createdAt,
    Enum$SortOrder? title,
    Enum$SortOrder? updatedAt,
    Enum$SortOrder? uuid,
  }) =>
      Input$BookMaxOrderByAggregateInput._({
        if (createdAt != null) r'createdAt': createdAt,
        if (title != null) r'title': title,
        if (updatedAt != null) r'updatedAt': updatedAt,
        if (uuid != null) r'uuid': uuid,
      });

  Input$BookMaxOrderByAggregateInput._(this._$data);

  factory Input$BookMaxOrderByAggregateInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : fromJson$Enum$SortOrder((l$createdAt as String));
    }
    if (data.containsKey('title')) {
      final l$title = data['title'];
      result$data['title'] =
          l$title == null ? null : fromJson$Enum$SortOrder((l$title as String));
    }
    if (data.containsKey('updatedAt')) {
      final l$updatedAt = data['updatedAt'];
      result$data['updatedAt'] = l$updatedAt == null
          ? null
          : fromJson$Enum$SortOrder((l$updatedAt as String));
    }
    if (data.containsKey('uuid')) {
      final l$uuid = data['uuid'];
      result$data['uuid'] =
          l$uuid == null ? null : fromJson$Enum$SortOrder((l$uuid as String));
    }
    return Input$BookMaxOrderByAggregateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$SortOrder? get createdAt => (_$data['createdAt'] as Enum$SortOrder?);

  Enum$SortOrder? get title => (_$data['title'] as Enum$SortOrder?);

  Enum$SortOrder? get updatedAt => (_$data['updatedAt'] as Enum$SortOrder?);

  Enum$SortOrder? get uuid => (_$data['uuid'] as Enum$SortOrder?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] =
          l$createdAt == null ? null : toJson$Enum$SortOrder(l$createdAt);
    }
    if (_$data.containsKey('title')) {
      final l$title = title;
      result$data['title'] =
          l$title == null ? null : toJson$Enum$SortOrder(l$title);
    }
    if (_$data.containsKey('updatedAt')) {
      final l$updatedAt = updatedAt;
      result$data['updatedAt'] =
          l$updatedAt == null ? null : toJson$Enum$SortOrder(l$updatedAt);
    }
    if (_$data.containsKey('uuid')) {
      final l$uuid = uuid;
      result$data['uuid'] =
          l$uuid == null ? null : toJson$Enum$SortOrder(l$uuid);
    }
    return result$data;
  }

  CopyWith$Input$BookMaxOrderByAggregateInput<
          Input$BookMaxOrderByAggregateInput>
      get copyWith => CopyWith$Input$BookMaxOrderByAggregateInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$BookMaxOrderByAggregateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$title = title;
    final lOther$title = other.title;
    if (_$data.containsKey('title') != other._$data.containsKey('title')) {
      return false;
    }
    if (l$title != lOther$title) {
      return false;
    }
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (_$data.containsKey('updatedAt') !=
        other._$data.containsKey('updatedAt')) {
      return false;
    }
    if (l$updatedAt != lOther$updatedAt) {
      return false;
    }
    final l$uuid = uuid;
    final lOther$uuid = other.uuid;
    if (_$data.containsKey('uuid') != other._$data.containsKey('uuid')) {
      return false;
    }
    if (l$uuid != lOther$uuid) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$createdAt = createdAt;
    final l$title = title;
    final l$updatedAt = updatedAt;
    final l$uuid = uuid;
    return Object.hashAll([
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('title') ? l$title : const {},
      _$data.containsKey('updatedAt') ? l$updatedAt : const {},
      _$data.containsKey('uuid') ? l$uuid : const {},
    ]);
  }
}

abstract class CopyWith$Input$BookMaxOrderByAggregateInput<TRes> {
  factory CopyWith$Input$BookMaxOrderByAggregateInput(
    Input$BookMaxOrderByAggregateInput instance,
    TRes Function(Input$BookMaxOrderByAggregateInput) then,
  ) = _CopyWithImpl$Input$BookMaxOrderByAggregateInput;

  factory CopyWith$Input$BookMaxOrderByAggregateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$BookMaxOrderByAggregateInput;

  TRes call({
    Enum$SortOrder? createdAt,
    Enum$SortOrder? title,
    Enum$SortOrder? updatedAt,
    Enum$SortOrder? uuid,
  });
}

class _CopyWithImpl$Input$BookMaxOrderByAggregateInput<TRes>
    implements CopyWith$Input$BookMaxOrderByAggregateInput<TRes> {
  _CopyWithImpl$Input$BookMaxOrderByAggregateInput(
    this._instance,
    this._then,
  );

  final Input$BookMaxOrderByAggregateInput _instance;

  final TRes Function(Input$BookMaxOrderByAggregateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? createdAt = _undefined,
    Object? title = _undefined,
    Object? updatedAt = _undefined,
    Object? uuid = _undefined,
  }) =>
      _then(Input$BookMaxOrderByAggregateInput._({
        ..._instance._$data,
        if (createdAt != _undefined)
          'createdAt': (createdAt as Enum$SortOrder?),
        if (title != _undefined) 'title': (title as Enum$SortOrder?),
        if (updatedAt != _undefined)
          'updatedAt': (updatedAt as Enum$SortOrder?),
        if (uuid != _undefined) 'uuid': (uuid as Enum$SortOrder?),
      }));
}

class _CopyWithStubImpl$Input$BookMaxOrderByAggregateInput<TRes>
    implements CopyWith$Input$BookMaxOrderByAggregateInput<TRes> {
  _CopyWithStubImpl$Input$BookMaxOrderByAggregateInput(this._res);

  TRes _res;

  call({
    Enum$SortOrder? createdAt,
    Enum$SortOrder? title,
    Enum$SortOrder? updatedAt,
    Enum$SortOrder? uuid,
  }) =>
      _res;
}

class Input$BookMinOrderByAggregateInput {
  factory Input$BookMinOrderByAggregateInput({
    Enum$SortOrder? createdAt,
    Enum$SortOrder? title,
    Enum$SortOrder? updatedAt,
    Enum$SortOrder? uuid,
  }) =>
      Input$BookMinOrderByAggregateInput._({
        if (createdAt != null) r'createdAt': createdAt,
        if (title != null) r'title': title,
        if (updatedAt != null) r'updatedAt': updatedAt,
        if (uuid != null) r'uuid': uuid,
      });

  Input$BookMinOrderByAggregateInput._(this._$data);

  factory Input$BookMinOrderByAggregateInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : fromJson$Enum$SortOrder((l$createdAt as String));
    }
    if (data.containsKey('title')) {
      final l$title = data['title'];
      result$data['title'] =
          l$title == null ? null : fromJson$Enum$SortOrder((l$title as String));
    }
    if (data.containsKey('updatedAt')) {
      final l$updatedAt = data['updatedAt'];
      result$data['updatedAt'] = l$updatedAt == null
          ? null
          : fromJson$Enum$SortOrder((l$updatedAt as String));
    }
    if (data.containsKey('uuid')) {
      final l$uuid = data['uuid'];
      result$data['uuid'] =
          l$uuid == null ? null : fromJson$Enum$SortOrder((l$uuid as String));
    }
    return Input$BookMinOrderByAggregateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$SortOrder? get createdAt => (_$data['createdAt'] as Enum$SortOrder?);

  Enum$SortOrder? get title => (_$data['title'] as Enum$SortOrder?);

  Enum$SortOrder? get updatedAt => (_$data['updatedAt'] as Enum$SortOrder?);

  Enum$SortOrder? get uuid => (_$data['uuid'] as Enum$SortOrder?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] =
          l$createdAt == null ? null : toJson$Enum$SortOrder(l$createdAt);
    }
    if (_$data.containsKey('title')) {
      final l$title = title;
      result$data['title'] =
          l$title == null ? null : toJson$Enum$SortOrder(l$title);
    }
    if (_$data.containsKey('updatedAt')) {
      final l$updatedAt = updatedAt;
      result$data['updatedAt'] =
          l$updatedAt == null ? null : toJson$Enum$SortOrder(l$updatedAt);
    }
    if (_$data.containsKey('uuid')) {
      final l$uuid = uuid;
      result$data['uuid'] =
          l$uuid == null ? null : toJson$Enum$SortOrder(l$uuid);
    }
    return result$data;
  }

  CopyWith$Input$BookMinOrderByAggregateInput<
          Input$BookMinOrderByAggregateInput>
      get copyWith => CopyWith$Input$BookMinOrderByAggregateInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$BookMinOrderByAggregateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$title = title;
    final lOther$title = other.title;
    if (_$data.containsKey('title') != other._$data.containsKey('title')) {
      return false;
    }
    if (l$title != lOther$title) {
      return false;
    }
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (_$data.containsKey('updatedAt') !=
        other._$data.containsKey('updatedAt')) {
      return false;
    }
    if (l$updatedAt != lOther$updatedAt) {
      return false;
    }
    final l$uuid = uuid;
    final lOther$uuid = other.uuid;
    if (_$data.containsKey('uuid') != other._$data.containsKey('uuid')) {
      return false;
    }
    if (l$uuid != lOther$uuid) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$createdAt = createdAt;
    final l$title = title;
    final l$updatedAt = updatedAt;
    final l$uuid = uuid;
    return Object.hashAll([
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('title') ? l$title : const {},
      _$data.containsKey('updatedAt') ? l$updatedAt : const {},
      _$data.containsKey('uuid') ? l$uuid : const {},
    ]);
  }
}

abstract class CopyWith$Input$BookMinOrderByAggregateInput<TRes> {
  factory CopyWith$Input$BookMinOrderByAggregateInput(
    Input$BookMinOrderByAggregateInput instance,
    TRes Function(Input$BookMinOrderByAggregateInput) then,
  ) = _CopyWithImpl$Input$BookMinOrderByAggregateInput;

  factory CopyWith$Input$BookMinOrderByAggregateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$BookMinOrderByAggregateInput;

  TRes call({
    Enum$SortOrder? createdAt,
    Enum$SortOrder? title,
    Enum$SortOrder? updatedAt,
    Enum$SortOrder? uuid,
  });
}

class _CopyWithImpl$Input$BookMinOrderByAggregateInput<TRes>
    implements CopyWith$Input$BookMinOrderByAggregateInput<TRes> {
  _CopyWithImpl$Input$BookMinOrderByAggregateInput(
    this._instance,
    this._then,
  );

  final Input$BookMinOrderByAggregateInput _instance;

  final TRes Function(Input$BookMinOrderByAggregateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? createdAt = _undefined,
    Object? title = _undefined,
    Object? updatedAt = _undefined,
    Object? uuid = _undefined,
  }) =>
      _then(Input$BookMinOrderByAggregateInput._({
        ..._instance._$data,
        if (createdAt != _undefined)
          'createdAt': (createdAt as Enum$SortOrder?),
        if (title != _undefined) 'title': (title as Enum$SortOrder?),
        if (updatedAt != _undefined)
          'updatedAt': (updatedAt as Enum$SortOrder?),
        if (uuid != _undefined) 'uuid': (uuid as Enum$SortOrder?),
      }));
}

class _CopyWithStubImpl$Input$BookMinOrderByAggregateInput<TRes>
    implements CopyWith$Input$BookMinOrderByAggregateInput<TRes> {
  _CopyWithStubImpl$Input$BookMinOrderByAggregateInput(this._res);

  TRes _res;

  call({
    Enum$SortOrder? createdAt,
    Enum$SortOrder? title,
    Enum$SortOrder? updatedAt,
    Enum$SortOrder? uuid,
  }) =>
      _res;
}

class Input$BookNullableRelationFilter {
  factory Input$BookNullableRelationFilter({
    Input$BookWhereInput? $is,
    Input$BookWhereInput? isNot,
  }) =>
      Input$BookNullableRelationFilter._({
        if ($is != null) r'is': $is,
        if (isNot != null) r'isNot': isNot,
      });

  Input$BookNullableRelationFilter._(this._$data);

  factory Input$BookNullableRelationFilter.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('is')) {
      final l$$is = data['is'];
      result$data['is'] = l$$is == null
          ? null
          : Input$BookWhereInput.fromJson((l$$is as Map<String, dynamic>));
    }
    if (data.containsKey('isNot')) {
      final l$isNot = data['isNot'];
      result$data['isNot'] = l$isNot == null
          ? null
          : Input$BookWhereInput.fromJson((l$isNot as Map<String, dynamic>));
    }
    return Input$BookNullableRelationFilter._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$BookWhereInput? get $is => (_$data['is'] as Input$BookWhereInput?);

  Input$BookWhereInput? get isNot => (_$data['isNot'] as Input$BookWhereInput?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('is')) {
      final l$$is = $is;
      result$data['is'] = l$$is?.toJson();
    }
    if (_$data.containsKey('isNot')) {
      final l$isNot = isNot;
      result$data['isNot'] = l$isNot?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$BookNullableRelationFilter<Input$BookNullableRelationFilter>
      get copyWith => CopyWith$Input$BookNullableRelationFilter(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$BookNullableRelationFilter) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$$is = $is;
    final lOther$$is = other.$is;
    if (_$data.containsKey('is') != other._$data.containsKey('is')) {
      return false;
    }
    if (l$$is != lOther$$is) {
      return false;
    }
    final l$isNot = isNot;
    final lOther$isNot = other.isNot;
    if (_$data.containsKey('isNot') != other._$data.containsKey('isNot')) {
      return false;
    }
    if (l$isNot != lOther$isNot) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$$is = $is;
    final l$isNot = isNot;
    return Object.hashAll([
      _$data.containsKey('is') ? l$$is : const {},
      _$data.containsKey('isNot') ? l$isNot : const {},
    ]);
  }
}

abstract class CopyWith$Input$BookNullableRelationFilter<TRes> {
  factory CopyWith$Input$BookNullableRelationFilter(
    Input$BookNullableRelationFilter instance,
    TRes Function(Input$BookNullableRelationFilter) then,
  ) = _CopyWithImpl$Input$BookNullableRelationFilter;

  factory CopyWith$Input$BookNullableRelationFilter.stub(TRes res) =
      _CopyWithStubImpl$Input$BookNullableRelationFilter;

  TRes call({
    Input$BookWhereInput? $is,
    Input$BookWhereInput? isNot,
  });
  CopyWith$Input$BookWhereInput<TRes> get $is;
  CopyWith$Input$BookWhereInput<TRes> get isNot;
}

class _CopyWithImpl$Input$BookNullableRelationFilter<TRes>
    implements CopyWith$Input$BookNullableRelationFilter<TRes> {
  _CopyWithImpl$Input$BookNullableRelationFilter(
    this._instance,
    this._then,
  );

  final Input$BookNullableRelationFilter _instance;

  final TRes Function(Input$BookNullableRelationFilter) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? $is = _undefined,
    Object? isNot = _undefined,
  }) =>
      _then(Input$BookNullableRelationFilter._({
        ..._instance._$data,
        if ($is != _undefined) 'is': ($is as Input$BookWhereInput?),
        if (isNot != _undefined) 'isNot': (isNot as Input$BookWhereInput?),
      }));

  CopyWith$Input$BookWhereInput<TRes> get $is {
    final local$$is = _instance.$is;
    return local$$is == null
        ? CopyWith$Input$BookWhereInput.stub(_then(_instance))
        : CopyWith$Input$BookWhereInput(local$$is, (e) => call($is: e));
  }

  CopyWith$Input$BookWhereInput<TRes> get isNot {
    final local$isNot = _instance.isNot;
    return local$isNot == null
        ? CopyWith$Input$BookWhereInput.stub(_then(_instance))
        : CopyWith$Input$BookWhereInput(local$isNot, (e) => call(isNot: e));
  }
}

class _CopyWithStubImpl$Input$BookNullableRelationFilter<TRes>
    implements CopyWith$Input$BookNullableRelationFilter<TRes> {
  _CopyWithStubImpl$Input$BookNullableRelationFilter(this._res);

  TRes _res;

  call({
    Input$BookWhereInput? $is,
    Input$BookWhereInput? isNot,
  }) =>
      _res;

  CopyWith$Input$BookWhereInput<TRes> get $is =>
      CopyWith$Input$BookWhereInput.stub(_res);

  CopyWith$Input$BookWhereInput<TRes> get isNot =>
      CopyWith$Input$BookWhereInput.stub(_res);
}

class Input$BookOrderByWithAggregationInput {
  factory Input$BookOrderByWithAggregationInput({
    Input$BookCountOrderByAggregateInput? $_count,
    Input$BookMaxOrderByAggregateInput? $_max,
    Input$BookMinOrderByAggregateInput? $_min,
    Enum$SortOrder? createdAt,
    Enum$SortOrder? title,
    Enum$SortOrder? updatedAt,
    Enum$SortOrder? uuid,
  }) =>
      Input$BookOrderByWithAggregationInput._({
        if ($_count != null) r'_count': $_count,
        if ($_max != null) r'_max': $_max,
        if ($_min != null) r'_min': $_min,
        if (createdAt != null) r'createdAt': createdAt,
        if (title != null) r'title': title,
        if (updatedAt != null) r'updatedAt': updatedAt,
        if (uuid != null) r'uuid': uuid,
      });

  Input$BookOrderByWithAggregationInput._(this._$data);

  factory Input$BookOrderByWithAggregationInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('_count')) {
      final l$$_count = data['_count'];
      result$data['_count'] = l$$_count == null
          ? null
          : Input$BookCountOrderByAggregateInput.fromJson(
              (l$$_count as Map<String, dynamic>));
    }
    if (data.containsKey('_max')) {
      final l$$_max = data['_max'];
      result$data['_max'] = l$$_max == null
          ? null
          : Input$BookMaxOrderByAggregateInput.fromJson(
              (l$$_max as Map<String, dynamic>));
    }
    if (data.containsKey('_min')) {
      final l$$_min = data['_min'];
      result$data['_min'] = l$$_min == null
          ? null
          : Input$BookMinOrderByAggregateInput.fromJson(
              (l$$_min as Map<String, dynamic>));
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : fromJson$Enum$SortOrder((l$createdAt as String));
    }
    if (data.containsKey('title')) {
      final l$title = data['title'];
      result$data['title'] =
          l$title == null ? null : fromJson$Enum$SortOrder((l$title as String));
    }
    if (data.containsKey('updatedAt')) {
      final l$updatedAt = data['updatedAt'];
      result$data['updatedAt'] = l$updatedAt == null
          ? null
          : fromJson$Enum$SortOrder((l$updatedAt as String));
    }
    if (data.containsKey('uuid')) {
      final l$uuid = data['uuid'];
      result$data['uuid'] =
          l$uuid == null ? null : fromJson$Enum$SortOrder((l$uuid as String));
    }
    return Input$BookOrderByWithAggregationInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$BookCountOrderByAggregateInput? get $_count =>
      (_$data['_count'] as Input$BookCountOrderByAggregateInput?);

  Input$BookMaxOrderByAggregateInput? get $_max =>
      (_$data['_max'] as Input$BookMaxOrderByAggregateInput?);

  Input$BookMinOrderByAggregateInput? get $_min =>
      (_$data['_min'] as Input$BookMinOrderByAggregateInput?);

  Enum$SortOrder? get createdAt => (_$data['createdAt'] as Enum$SortOrder?);

  Enum$SortOrder? get title => (_$data['title'] as Enum$SortOrder?);

  Enum$SortOrder? get updatedAt => (_$data['updatedAt'] as Enum$SortOrder?);

  Enum$SortOrder? get uuid => (_$data['uuid'] as Enum$SortOrder?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('_count')) {
      final l$$_count = $_count;
      result$data['_count'] = l$$_count?.toJson();
    }
    if (_$data.containsKey('_max')) {
      final l$$_max = $_max;
      result$data['_max'] = l$$_max?.toJson();
    }
    if (_$data.containsKey('_min')) {
      final l$$_min = $_min;
      result$data['_min'] = l$$_min?.toJson();
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] =
          l$createdAt == null ? null : toJson$Enum$SortOrder(l$createdAt);
    }
    if (_$data.containsKey('title')) {
      final l$title = title;
      result$data['title'] =
          l$title == null ? null : toJson$Enum$SortOrder(l$title);
    }
    if (_$data.containsKey('updatedAt')) {
      final l$updatedAt = updatedAt;
      result$data['updatedAt'] =
          l$updatedAt == null ? null : toJson$Enum$SortOrder(l$updatedAt);
    }
    if (_$data.containsKey('uuid')) {
      final l$uuid = uuid;
      result$data['uuid'] =
          l$uuid == null ? null : toJson$Enum$SortOrder(l$uuid);
    }
    return result$data;
  }

  CopyWith$Input$BookOrderByWithAggregationInput<
          Input$BookOrderByWithAggregationInput>
      get copyWith => CopyWith$Input$BookOrderByWithAggregationInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$BookOrderByWithAggregationInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$$_count = $_count;
    final lOther$$_count = other.$_count;
    if (_$data.containsKey('_count') != other._$data.containsKey('_count')) {
      return false;
    }
    if (l$$_count != lOther$$_count) {
      return false;
    }
    final l$$_max = $_max;
    final lOther$$_max = other.$_max;
    if (_$data.containsKey('_max') != other._$data.containsKey('_max')) {
      return false;
    }
    if (l$$_max != lOther$$_max) {
      return false;
    }
    final l$$_min = $_min;
    final lOther$$_min = other.$_min;
    if (_$data.containsKey('_min') != other._$data.containsKey('_min')) {
      return false;
    }
    if (l$$_min != lOther$$_min) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$title = title;
    final lOther$title = other.title;
    if (_$data.containsKey('title') != other._$data.containsKey('title')) {
      return false;
    }
    if (l$title != lOther$title) {
      return false;
    }
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (_$data.containsKey('updatedAt') !=
        other._$data.containsKey('updatedAt')) {
      return false;
    }
    if (l$updatedAt != lOther$updatedAt) {
      return false;
    }
    final l$uuid = uuid;
    final lOther$uuid = other.uuid;
    if (_$data.containsKey('uuid') != other._$data.containsKey('uuid')) {
      return false;
    }
    if (l$uuid != lOther$uuid) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$$_count = $_count;
    final l$$_max = $_max;
    final l$$_min = $_min;
    final l$createdAt = createdAt;
    final l$title = title;
    final l$updatedAt = updatedAt;
    final l$uuid = uuid;
    return Object.hashAll([
      _$data.containsKey('_count') ? l$$_count : const {},
      _$data.containsKey('_max') ? l$$_max : const {},
      _$data.containsKey('_min') ? l$$_min : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('title') ? l$title : const {},
      _$data.containsKey('updatedAt') ? l$updatedAt : const {},
      _$data.containsKey('uuid') ? l$uuid : const {},
    ]);
  }
}

abstract class CopyWith$Input$BookOrderByWithAggregationInput<TRes> {
  factory CopyWith$Input$BookOrderByWithAggregationInput(
    Input$BookOrderByWithAggregationInput instance,
    TRes Function(Input$BookOrderByWithAggregationInput) then,
  ) = _CopyWithImpl$Input$BookOrderByWithAggregationInput;

  factory CopyWith$Input$BookOrderByWithAggregationInput.stub(TRes res) =
      _CopyWithStubImpl$Input$BookOrderByWithAggregationInput;

  TRes call({
    Input$BookCountOrderByAggregateInput? $_count,
    Input$BookMaxOrderByAggregateInput? $_max,
    Input$BookMinOrderByAggregateInput? $_min,
    Enum$SortOrder? createdAt,
    Enum$SortOrder? title,
    Enum$SortOrder? updatedAt,
    Enum$SortOrder? uuid,
  });
  CopyWith$Input$BookCountOrderByAggregateInput<TRes> get $_count;
  CopyWith$Input$BookMaxOrderByAggregateInput<TRes> get $_max;
  CopyWith$Input$BookMinOrderByAggregateInput<TRes> get $_min;
}

class _CopyWithImpl$Input$BookOrderByWithAggregationInput<TRes>
    implements CopyWith$Input$BookOrderByWithAggregationInput<TRes> {
  _CopyWithImpl$Input$BookOrderByWithAggregationInput(
    this._instance,
    this._then,
  );

  final Input$BookOrderByWithAggregationInput _instance;

  final TRes Function(Input$BookOrderByWithAggregationInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? $_count = _undefined,
    Object? $_max = _undefined,
    Object? $_min = _undefined,
    Object? createdAt = _undefined,
    Object? title = _undefined,
    Object? updatedAt = _undefined,
    Object? uuid = _undefined,
  }) =>
      _then(Input$BookOrderByWithAggregationInput._({
        ..._instance._$data,
        if ($_count != _undefined)
          '_count': ($_count as Input$BookCountOrderByAggregateInput?),
        if ($_max != _undefined)
          '_max': ($_max as Input$BookMaxOrderByAggregateInput?),
        if ($_min != _undefined)
          '_min': ($_min as Input$BookMinOrderByAggregateInput?),
        if (createdAt != _undefined)
          'createdAt': (createdAt as Enum$SortOrder?),
        if (title != _undefined) 'title': (title as Enum$SortOrder?),
        if (updatedAt != _undefined)
          'updatedAt': (updatedAt as Enum$SortOrder?),
        if (uuid != _undefined) 'uuid': (uuid as Enum$SortOrder?),
      }));

  CopyWith$Input$BookCountOrderByAggregateInput<TRes> get $_count {
    final local$$_count = _instance.$_count;
    return local$$_count == null
        ? CopyWith$Input$BookCountOrderByAggregateInput.stub(_then(_instance))
        : CopyWith$Input$BookCountOrderByAggregateInput(
            local$$_count, (e) => call($_count: e));
  }

  CopyWith$Input$BookMaxOrderByAggregateInput<TRes> get $_max {
    final local$$_max = _instance.$_max;
    return local$$_max == null
        ? CopyWith$Input$BookMaxOrderByAggregateInput.stub(_then(_instance))
        : CopyWith$Input$BookMaxOrderByAggregateInput(
            local$$_max, (e) => call($_max: e));
  }

  CopyWith$Input$BookMinOrderByAggregateInput<TRes> get $_min {
    final local$$_min = _instance.$_min;
    return local$$_min == null
        ? CopyWith$Input$BookMinOrderByAggregateInput.stub(_then(_instance))
        : CopyWith$Input$BookMinOrderByAggregateInput(
            local$$_min, (e) => call($_min: e));
  }
}

class _CopyWithStubImpl$Input$BookOrderByWithAggregationInput<TRes>
    implements CopyWith$Input$BookOrderByWithAggregationInput<TRes> {
  _CopyWithStubImpl$Input$BookOrderByWithAggregationInput(this._res);

  TRes _res;

  call({
    Input$BookCountOrderByAggregateInput? $_count,
    Input$BookMaxOrderByAggregateInput? $_max,
    Input$BookMinOrderByAggregateInput? $_min,
    Enum$SortOrder? createdAt,
    Enum$SortOrder? title,
    Enum$SortOrder? updatedAt,
    Enum$SortOrder? uuid,
  }) =>
      _res;

  CopyWith$Input$BookCountOrderByAggregateInput<TRes> get $_count =>
      CopyWith$Input$BookCountOrderByAggregateInput.stub(_res);

  CopyWith$Input$BookMaxOrderByAggregateInput<TRes> get $_max =>
      CopyWith$Input$BookMaxOrderByAggregateInput.stub(_res);

  CopyWith$Input$BookMinOrderByAggregateInput<TRes> get $_min =>
      CopyWith$Input$BookMinOrderByAggregateInput.stub(_res);
}

class Input$BookOrderByWithRelationInput {
  factory Input$BookOrderByWithRelationInput({
    Input$BookRevisionOrderByWithRelationInput? bookEdited,
    Input$BookRevisionOrderByWithRelationInput? bookRaw,
    Enum$SortOrder? createdAt,
    Enum$SortOrder? title,
    Enum$SortOrder? updatedAt,
    Enum$SortOrder? uuid,
  }) =>
      Input$BookOrderByWithRelationInput._({
        if (bookEdited != null) r'bookEdited': bookEdited,
        if (bookRaw != null) r'bookRaw': bookRaw,
        if (createdAt != null) r'createdAt': createdAt,
        if (title != null) r'title': title,
        if (updatedAt != null) r'updatedAt': updatedAt,
        if (uuid != null) r'uuid': uuid,
      });

  Input$BookOrderByWithRelationInput._(this._$data);

  factory Input$BookOrderByWithRelationInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('bookEdited')) {
      final l$bookEdited = data['bookEdited'];
      result$data['bookEdited'] = l$bookEdited == null
          ? null
          : Input$BookRevisionOrderByWithRelationInput.fromJson(
              (l$bookEdited as Map<String, dynamic>));
    }
    if (data.containsKey('bookRaw')) {
      final l$bookRaw = data['bookRaw'];
      result$data['bookRaw'] = l$bookRaw == null
          ? null
          : Input$BookRevisionOrderByWithRelationInput.fromJson(
              (l$bookRaw as Map<String, dynamic>));
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : fromJson$Enum$SortOrder((l$createdAt as String));
    }
    if (data.containsKey('title')) {
      final l$title = data['title'];
      result$data['title'] =
          l$title == null ? null : fromJson$Enum$SortOrder((l$title as String));
    }
    if (data.containsKey('updatedAt')) {
      final l$updatedAt = data['updatedAt'];
      result$data['updatedAt'] = l$updatedAt == null
          ? null
          : fromJson$Enum$SortOrder((l$updatedAt as String));
    }
    if (data.containsKey('uuid')) {
      final l$uuid = data['uuid'];
      result$data['uuid'] =
          l$uuid == null ? null : fromJson$Enum$SortOrder((l$uuid as String));
    }
    return Input$BookOrderByWithRelationInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$BookRevisionOrderByWithRelationInput? get bookEdited =>
      (_$data['bookEdited'] as Input$BookRevisionOrderByWithRelationInput?);

  Input$BookRevisionOrderByWithRelationInput? get bookRaw =>
      (_$data['bookRaw'] as Input$BookRevisionOrderByWithRelationInput?);

  Enum$SortOrder? get createdAt => (_$data['createdAt'] as Enum$SortOrder?);

  Enum$SortOrder? get title => (_$data['title'] as Enum$SortOrder?);

  Enum$SortOrder? get updatedAt => (_$data['updatedAt'] as Enum$SortOrder?);

  Enum$SortOrder? get uuid => (_$data['uuid'] as Enum$SortOrder?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('bookEdited')) {
      final l$bookEdited = bookEdited;
      result$data['bookEdited'] = l$bookEdited?.toJson();
    }
    if (_$data.containsKey('bookRaw')) {
      final l$bookRaw = bookRaw;
      result$data['bookRaw'] = l$bookRaw?.toJson();
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] =
          l$createdAt == null ? null : toJson$Enum$SortOrder(l$createdAt);
    }
    if (_$data.containsKey('title')) {
      final l$title = title;
      result$data['title'] =
          l$title == null ? null : toJson$Enum$SortOrder(l$title);
    }
    if (_$data.containsKey('updatedAt')) {
      final l$updatedAt = updatedAt;
      result$data['updatedAt'] =
          l$updatedAt == null ? null : toJson$Enum$SortOrder(l$updatedAt);
    }
    if (_$data.containsKey('uuid')) {
      final l$uuid = uuid;
      result$data['uuid'] =
          l$uuid == null ? null : toJson$Enum$SortOrder(l$uuid);
    }
    return result$data;
  }

  CopyWith$Input$BookOrderByWithRelationInput<
          Input$BookOrderByWithRelationInput>
      get copyWith => CopyWith$Input$BookOrderByWithRelationInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$BookOrderByWithRelationInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$bookEdited = bookEdited;
    final lOther$bookEdited = other.bookEdited;
    if (_$data.containsKey('bookEdited') !=
        other._$data.containsKey('bookEdited')) {
      return false;
    }
    if (l$bookEdited != lOther$bookEdited) {
      return false;
    }
    final l$bookRaw = bookRaw;
    final lOther$bookRaw = other.bookRaw;
    if (_$data.containsKey('bookRaw') != other._$data.containsKey('bookRaw')) {
      return false;
    }
    if (l$bookRaw != lOther$bookRaw) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$title = title;
    final lOther$title = other.title;
    if (_$data.containsKey('title') != other._$data.containsKey('title')) {
      return false;
    }
    if (l$title != lOther$title) {
      return false;
    }
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (_$data.containsKey('updatedAt') !=
        other._$data.containsKey('updatedAt')) {
      return false;
    }
    if (l$updatedAt != lOther$updatedAt) {
      return false;
    }
    final l$uuid = uuid;
    final lOther$uuid = other.uuid;
    if (_$data.containsKey('uuid') != other._$data.containsKey('uuid')) {
      return false;
    }
    if (l$uuid != lOther$uuid) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$bookEdited = bookEdited;
    final l$bookRaw = bookRaw;
    final l$createdAt = createdAt;
    final l$title = title;
    final l$updatedAt = updatedAt;
    final l$uuid = uuid;
    return Object.hashAll([
      _$data.containsKey('bookEdited') ? l$bookEdited : const {},
      _$data.containsKey('bookRaw') ? l$bookRaw : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('title') ? l$title : const {},
      _$data.containsKey('updatedAt') ? l$updatedAt : const {},
      _$data.containsKey('uuid') ? l$uuid : const {},
    ]);
  }
}

abstract class CopyWith$Input$BookOrderByWithRelationInput<TRes> {
  factory CopyWith$Input$BookOrderByWithRelationInput(
    Input$BookOrderByWithRelationInput instance,
    TRes Function(Input$BookOrderByWithRelationInput) then,
  ) = _CopyWithImpl$Input$BookOrderByWithRelationInput;

  factory CopyWith$Input$BookOrderByWithRelationInput.stub(TRes res) =
      _CopyWithStubImpl$Input$BookOrderByWithRelationInput;

  TRes call({
    Input$BookRevisionOrderByWithRelationInput? bookEdited,
    Input$BookRevisionOrderByWithRelationInput? bookRaw,
    Enum$SortOrder? createdAt,
    Enum$SortOrder? title,
    Enum$SortOrder? updatedAt,
    Enum$SortOrder? uuid,
  });
  CopyWith$Input$BookRevisionOrderByWithRelationInput<TRes> get bookEdited;
  CopyWith$Input$BookRevisionOrderByWithRelationInput<TRes> get bookRaw;
}

class _CopyWithImpl$Input$BookOrderByWithRelationInput<TRes>
    implements CopyWith$Input$BookOrderByWithRelationInput<TRes> {
  _CopyWithImpl$Input$BookOrderByWithRelationInput(
    this._instance,
    this._then,
  );

  final Input$BookOrderByWithRelationInput _instance;

  final TRes Function(Input$BookOrderByWithRelationInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? bookEdited = _undefined,
    Object? bookRaw = _undefined,
    Object? createdAt = _undefined,
    Object? title = _undefined,
    Object? updatedAt = _undefined,
    Object? uuid = _undefined,
  }) =>
      _then(Input$BookOrderByWithRelationInput._({
        ..._instance._$data,
        if (bookEdited != _undefined)
          'bookEdited':
              (bookEdited as Input$BookRevisionOrderByWithRelationInput?),
        if (bookRaw != _undefined)
          'bookRaw': (bookRaw as Input$BookRevisionOrderByWithRelationInput?),
        if (createdAt != _undefined)
          'createdAt': (createdAt as Enum$SortOrder?),
        if (title != _undefined) 'title': (title as Enum$SortOrder?),
        if (updatedAt != _undefined)
          'updatedAt': (updatedAt as Enum$SortOrder?),
        if (uuid != _undefined) 'uuid': (uuid as Enum$SortOrder?),
      }));

  CopyWith$Input$BookRevisionOrderByWithRelationInput<TRes> get bookEdited {
    final local$bookEdited = _instance.bookEdited;
    return local$bookEdited == null
        ? CopyWith$Input$BookRevisionOrderByWithRelationInput.stub(
            _then(_instance))
        : CopyWith$Input$BookRevisionOrderByWithRelationInput(
            local$bookEdited, (e) => call(bookEdited: e));
  }

  CopyWith$Input$BookRevisionOrderByWithRelationInput<TRes> get bookRaw {
    final local$bookRaw = _instance.bookRaw;
    return local$bookRaw == null
        ? CopyWith$Input$BookRevisionOrderByWithRelationInput.stub(
            _then(_instance))
        : CopyWith$Input$BookRevisionOrderByWithRelationInput(
            local$bookRaw, (e) => call(bookRaw: e));
  }
}

class _CopyWithStubImpl$Input$BookOrderByWithRelationInput<TRes>
    implements CopyWith$Input$BookOrderByWithRelationInput<TRes> {
  _CopyWithStubImpl$Input$BookOrderByWithRelationInput(this._res);

  TRes _res;

  call({
    Input$BookRevisionOrderByWithRelationInput? bookEdited,
    Input$BookRevisionOrderByWithRelationInput? bookRaw,
    Enum$SortOrder? createdAt,
    Enum$SortOrder? title,
    Enum$SortOrder? updatedAt,
    Enum$SortOrder? uuid,
  }) =>
      _res;

  CopyWith$Input$BookRevisionOrderByWithRelationInput<TRes> get bookEdited =>
      CopyWith$Input$BookRevisionOrderByWithRelationInput.stub(_res);

  CopyWith$Input$BookRevisionOrderByWithRelationInput<TRes> get bookRaw =>
      CopyWith$Input$BookRevisionOrderByWithRelationInput.stub(_res);
}

class Input$BookRevisionAvgOrderByAggregateInput {
  factory Input$BookRevisionAvgOrderByAggregateInput({
    Enum$SortOrder? completionTokens,
    Enum$SortOrder? promptTokens,
    Enum$SortOrder? totalTokens,
  }) =>
      Input$BookRevisionAvgOrderByAggregateInput._({
        if (completionTokens != null) r'completionTokens': completionTokens,
        if (promptTokens != null) r'promptTokens': promptTokens,
        if (totalTokens != null) r'totalTokens': totalTokens,
      });

  Input$BookRevisionAvgOrderByAggregateInput._(this._$data);

  factory Input$BookRevisionAvgOrderByAggregateInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('completionTokens')) {
      final l$completionTokens = data['completionTokens'];
      result$data['completionTokens'] = l$completionTokens == null
          ? null
          : fromJson$Enum$SortOrder((l$completionTokens as String));
    }
    if (data.containsKey('promptTokens')) {
      final l$promptTokens = data['promptTokens'];
      result$data['promptTokens'] = l$promptTokens == null
          ? null
          : fromJson$Enum$SortOrder((l$promptTokens as String));
    }
    if (data.containsKey('totalTokens')) {
      final l$totalTokens = data['totalTokens'];
      result$data['totalTokens'] = l$totalTokens == null
          ? null
          : fromJson$Enum$SortOrder((l$totalTokens as String));
    }
    return Input$BookRevisionAvgOrderByAggregateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$SortOrder? get completionTokens =>
      (_$data['completionTokens'] as Enum$SortOrder?);

  Enum$SortOrder? get promptTokens =>
      (_$data['promptTokens'] as Enum$SortOrder?);

  Enum$SortOrder? get totalTokens => (_$data['totalTokens'] as Enum$SortOrder?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('completionTokens')) {
      final l$completionTokens = completionTokens;
      result$data['completionTokens'] = l$completionTokens == null
          ? null
          : toJson$Enum$SortOrder(l$completionTokens);
    }
    if (_$data.containsKey('promptTokens')) {
      final l$promptTokens = promptTokens;
      result$data['promptTokens'] =
          l$promptTokens == null ? null : toJson$Enum$SortOrder(l$promptTokens);
    }
    if (_$data.containsKey('totalTokens')) {
      final l$totalTokens = totalTokens;
      result$data['totalTokens'] =
          l$totalTokens == null ? null : toJson$Enum$SortOrder(l$totalTokens);
    }
    return result$data;
  }

  CopyWith$Input$BookRevisionAvgOrderByAggregateInput<
          Input$BookRevisionAvgOrderByAggregateInput>
      get copyWith => CopyWith$Input$BookRevisionAvgOrderByAggregateInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$BookRevisionAvgOrderByAggregateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$completionTokens = completionTokens;
    final lOther$completionTokens = other.completionTokens;
    if (_$data.containsKey('completionTokens') !=
        other._$data.containsKey('completionTokens')) {
      return false;
    }
    if (l$completionTokens != lOther$completionTokens) {
      return false;
    }
    final l$promptTokens = promptTokens;
    final lOther$promptTokens = other.promptTokens;
    if (_$data.containsKey('promptTokens') !=
        other._$data.containsKey('promptTokens')) {
      return false;
    }
    if (l$promptTokens != lOther$promptTokens) {
      return false;
    }
    final l$totalTokens = totalTokens;
    final lOther$totalTokens = other.totalTokens;
    if (_$data.containsKey('totalTokens') !=
        other._$data.containsKey('totalTokens')) {
      return false;
    }
    if (l$totalTokens != lOther$totalTokens) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$completionTokens = completionTokens;
    final l$promptTokens = promptTokens;
    final l$totalTokens = totalTokens;
    return Object.hashAll([
      _$data.containsKey('completionTokens') ? l$completionTokens : const {},
      _$data.containsKey('promptTokens') ? l$promptTokens : const {},
      _$data.containsKey('totalTokens') ? l$totalTokens : const {},
    ]);
  }
}

abstract class CopyWith$Input$BookRevisionAvgOrderByAggregateInput<TRes> {
  factory CopyWith$Input$BookRevisionAvgOrderByAggregateInput(
    Input$BookRevisionAvgOrderByAggregateInput instance,
    TRes Function(Input$BookRevisionAvgOrderByAggregateInput) then,
  ) = _CopyWithImpl$Input$BookRevisionAvgOrderByAggregateInput;

  factory CopyWith$Input$BookRevisionAvgOrderByAggregateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$BookRevisionAvgOrderByAggregateInput;

  TRes call({
    Enum$SortOrder? completionTokens,
    Enum$SortOrder? promptTokens,
    Enum$SortOrder? totalTokens,
  });
}

class _CopyWithImpl$Input$BookRevisionAvgOrderByAggregateInput<TRes>
    implements CopyWith$Input$BookRevisionAvgOrderByAggregateInput<TRes> {
  _CopyWithImpl$Input$BookRevisionAvgOrderByAggregateInput(
    this._instance,
    this._then,
  );

  final Input$BookRevisionAvgOrderByAggregateInput _instance;

  final TRes Function(Input$BookRevisionAvgOrderByAggregateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? completionTokens = _undefined,
    Object? promptTokens = _undefined,
    Object? totalTokens = _undefined,
  }) =>
      _then(Input$BookRevisionAvgOrderByAggregateInput._({
        ..._instance._$data,
        if (completionTokens != _undefined)
          'completionTokens': (completionTokens as Enum$SortOrder?),
        if (promptTokens != _undefined)
          'promptTokens': (promptTokens as Enum$SortOrder?),
        if (totalTokens != _undefined)
          'totalTokens': (totalTokens as Enum$SortOrder?),
      }));
}

class _CopyWithStubImpl$Input$BookRevisionAvgOrderByAggregateInput<TRes>
    implements CopyWith$Input$BookRevisionAvgOrderByAggregateInput<TRes> {
  _CopyWithStubImpl$Input$BookRevisionAvgOrderByAggregateInput(this._res);

  TRes _res;

  call({
    Enum$SortOrder? completionTokens,
    Enum$SortOrder? promptTokens,
    Enum$SortOrder? totalTokens,
  }) =>
      _res;
}

class Input$BookRevisionCountOrderByAggregateInput {
  factory Input$BookRevisionCountOrderByAggregateInput({
    Enum$SortOrder? bookEditedId,
    Enum$SortOrder? bookRawId,
    Enum$SortOrder? completionTokens,
    Enum$SortOrder? content,
    Enum$SortOrder? createdAt,
    Enum$SortOrder? isRaw,
    Enum$SortOrder? model,
    Enum$SortOrder? promptTokens,
    Enum$SortOrder? raw,
    Enum$SortOrder? requestId,
    Enum$SortOrder? systemPrompt,
    Enum$SortOrder? totalTokens,
    Enum$SortOrder? updatedAt,
    Enum$SortOrder? userPrompt,
    Enum$SortOrder? uuid,
  }) =>
      Input$BookRevisionCountOrderByAggregateInput._({
        if (bookEditedId != null) r'bookEditedId': bookEditedId,
        if (bookRawId != null) r'bookRawId': bookRawId,
        if (completionTokens != null) r'completionTokens': completionTokens,
        if (content != null) r'content': content,
        if (createdAt != null) r'createdAt': createdAt,
        if (isRaw != null) r'isRaw': isRaw,
        if (model != null) r'model': model,
        if (promptTokens != null) r'promptTokens': promptTokens,
        if (raw != null) r'raw': raw,
        if (requestId != null) r'requestId': requestId,
        if (systemPrompt != null) r'systemPrompt': systemPrompt,
        if (totalTokens != null) r'totalTokens': totalTokens,
        if (updatedAt != null) r'updatedAt': updatedAt,
        if (userPrompt != null) r'userPrompt': userPrompt,
        if (uuid != null) r'uuid': uuid,
      });

  Input$BookRevisionCountOrderByAggregateInput._(this._$data);

  factory Input$BookRevisionCountOrderByAggregateInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('bookEditedId')) {
      final l$bookEditedId = data['bookEditedId'];
      result$data['bookEditedId'] = l$bookEditedId == null
          ? null
          : fromJson$Enum$SortOrder((l$bookEditedId as String));
    }
    if (data.containsKey('bookRawId')) {
      final l$bookRawId = data['bookRawId'];
      result$data['bookRawId'] = l$bookRawId == null
          ? null
          : fromJson$Enum$SortOrder((l$bookRawId as String));
    }
    if (data.containsKey('completionTokens')) {
      final l$completionTokens = data['completionTokens'];
      result$data['completionTokens'] = l$completionTokens == null
          ? null
          : fromJson$Enum$SortOrder((l$completionTokens as String));
    }
    if (data.containsKey('content')) {
      final l$content = data['content'];
      result$data['content'] = l$content == null
          ? null
          : fromJson$Enum$SortOrder((l$content as String));
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : fromJson$Enum$SortOrder((l$createdAt as String));
    }
    if (data.containsKey('isRaw')) {
      final l$isRaw = data['isRaw'];
      result$data['isRaw'] =
          l$isRaw == null ? null : fromJson$Enum$SortOrder((l$isRaw as String));
    }
    if (data.containsKey('model')) {
      final l$model = data['model'];
      result$data['model'] =
          l$model == null ? null : fromJson$Enum$SortOrder((l$model as String));
    }
    if (data.containsKey('promptTokens')) {
      final l$promptTokens = data['promptTokens'];
      result$data['promptTokens'] = l$promptTokens == null
          ? null
          : fromJson$Enum$SortOrder((l$promptTokens as String));
    }
    if (data.containsKey('raw')) {
      final l$raw = data['raw'];
      result$data['raw'] =
          l$raw == null ? null : fromJson$Enum$SortOrder((l$raw as String));
    }
    if (data.containsKey('requestId')) {
      final l$requestId = data['requestId'];
      result$data['requestId'] = l$requestId == null
          ? null
          : fromJson$Enum$SortOrder((l$requestId as String));
    }
    if (data.containsKey('systemPrompt')) {
      final l$systemPrompt = data['systemPrompt'];
      result$data['systemPrompt'] = l$systemPrompt == null
          ? null
          : fromJson$Enum$SortOrder((l$systemPrompt as String));
    }
    if (data.containsKey('totalTokens')) {
      final l$totalTokens = data['totalTokens'];
      result$data['totalTokens'] = l$totalTokens == null
          ? null
          : fromJson$Enum$SortOrder((l$totalTokens as String));
    }
    if (data.containsKey('updatedAt')) {
      final l$updatedAt = data['updatedAt'];
      result$data['updatedAt'] = l$updatedAt == null
          ? null
          : fromJson$Enum$SortOrder((l$updatedAt as String));
    }
    if (data.containsKey('userPrompt')) {
      final l$userPrompt = data['userPrompt'];
      result$data['userPrompt'] = l$userPrompt == null
          ? null
          : fromJson$Enum$SortOrder((l$userPrompt as String));
    }
    if (data.containsKey('uuid')) {
      final l$uuid = data['uuid'];
      result$data['uuid'] =
          l$uuid == null ? null : fromJson$Enum$SortOrder((l$uuid as String));
    }
    return Input$BookRevisionCountOrderByAggregateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$SortOrder? get bookEditedId =>
      (_$data['bookEditedId'] as Enum$SortOrder?);

  Enum$SortOrder? get bookRawId => (_$data['bookRawId'] as Enum$SortOrder?);

  Enum$SortOrder? get completionTokens =>
      (_$data['completionTokens'] as Enum$SortOrder?);

  Enum$SortOrder? get content => (_$data['content'] as Enum$SortOrder?);

  Enum$SortOrder? get createdAt => (_$data['createdAt'] as Enum$SortOrder?);

  Enum$SortOrder? get isRaw => (_$data['isRaw'] as Enum$SortOrder?);

  Enum$SortOrder? get model => (_$data['model'] as Enum$SortOrder?);

  Enum$SortOrder? get promptTokens =>
      (_$data['promptTokens'] as Enum$SortOrder?);

  Enum$SortOrder? get raw => (_$data['raw'] as Enum$SortOrder?);

  Enum$SortOrder? get requestId => (_$data['requestId'] as Enum$SortOrder?);

  Enum$SortOrder? get systemPrompt =>
      (_$data['systemPrompt'] as Enum$SortOrder?);

  Enum$SortOrder? get totalTokens => (_$data['totalTokens'] as Enum$SortOrder?);

  Enum$SortOrder? get updatedAt => (_$data['updatedAt'] as Enum$SortOrder?);

  Enum$SortOrder? get userPrompt => (_$data['userPrompt'] as Enum$SortOrder?);

  Enum$SortOrder? get uuid => (_$data['uuid'] as Enum$SortOrder?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('bookEditedId')) {
      final l$bookEditedId = bookEditedId;
      result$data['bookEditedId'] =
          l$bookEditedId == null ? null : toJson$Enum$SortOrder(l$bookEditedId);
    }
    if (_$data.containsKey('bookRawId')) {
      final l$bookRawId = bookRawId;
      result$data['bookRawId'] =
          l$bookRawId == null ? null : toJson$Enum$SortOrder(l$bookRawId);
    }
    if (_$data.containsKey('completionTokens')) {
      final l$completionTokens = completionTokens;
      result$data['completionTokens'] = l$completionTokens == null
          ? null
          : toJson$Enum$SortOrder(l$completionTokens);
    }
    if (_$data.containsKey('content')) {
      final l$content = content;
      result$data['content'] =
          l$content == null ? null : toJson$Enum$SortOrder(l$content);
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] =
          l$createdAt == null ? null : toJson$Enum$SortOrder(l$createdAt);
    }
    if (_$data.containsKey('isRaw')) {
      final l$isRaw = isRaw;
      result$data['isRaw'] =
          l$isRaw == null ? null : toJson$Enum$SortOrder(l$isRaw);
    }
    if (_$data.containsKey('model')) {
      final l$model = model;
      result$data['model'] =
          l$model == null ? null : toJson$Enum$SortOrder(l$model);
    }
    if (_$data.containsKey('promptTokens')) {
      final l$promptTokens = promptTokens;
      result$data['promptTokens'] =
          l$promptTokens == null ? null : toJson$Enum$SortOrder(l$promptTokens);
    }
    if (_$data.containsKey('raw')) {
      final l$raw = raw;
      result$data['raw'] = l$raw == null ? null : toJson$Enum$SortOrder(l$raw);
    }
    if (_$data.containsKey('requestId')) {
      final l$requestId = requestId;
      result$data['requestId'] =
          l$requestId == null ? null : toJson$Enum$SortOrder(l$requestId);
    }
    if (_$data.containsKey('systemPrompt')) {
      final l$systemPrompt = systemPrompt;
      result$data['systemPrompt'] =
          l$systemPrompt == null ? null : toJson$Enum$SortOrder(l$systemPrompt);
    }
    if (_$data.containsKey('totalTokens')) {
      final l$totalTokens = totalTokens;
      result$data['totalTokens'] =
          l$totalTokens == null ? null : toJson$Enum$SortOrder(l$totalTokens);
    }
    if (_$data.containsKey('updatedAt')) {
      final l$updatedAt = updatedAt;
      result$data['updatedAt'] =
          l$updatedAt == null ? null : toJson$Enum$SortOrder(l$updatedAt);
    }
    if (_$data.containsKey('userPrompt')) {
      final l$userPrompt = userPrompt;
      result$data['userPrompt'] =
          l$userPrompt == null ? null : toJson$Enum$SortOrder(l$userPrompt);
    }
    if (_$data.containsKey('uuid')) {
      final l$uuid = uuid;
      result$data['uuid'] =
          l$uuid == null ? null : toJson$Enum$SortOrder(l$uuid);
    }
    return result$data;
  }

  CopyWith$Input$BookRevisionCountOrderByAggregateInput<
          Input$BookRevisionCountOrderByAggregateInput>
      get copyWith => CopyWith$Input$BookRevisionCountOrderByAggregateInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$BookRevisionCountOrderByAggregateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$bookEditedId = bookEditedId;
    final lOther$bookEditedId = other.bookEditedId;
    if (_$data.containsKey('bookEditedId') !=
        other._$data.containsKey('bookEditedId')) {
      return false;
    }
    if (l$bookEditedId != lOther$bookEditedId) {
      return false;
    }
    final l$bookRawId = bookRawId;
    final lOther$bookRawId = other.bookRawId;
    if (_$data.containsKey('bookRawId') !=
        other._$data.containsKey('bookRawId')) {
      return false;
    }
    if (l$bookRawId != lOther$bookRawId) {
      return false;
    }
    final l$completionTokens = completionTokens;
    final lOther$completionTokens = other.completionTokens;
    if (_$data.containsKey('completionTokens') !=
        other._$data.containsKey('completionTokens')) {
      return false;
    }
    if (l$completionTokens != lOther$completionTokens) {
      return false;
    }
    final l$content = content;
    final lOther$content = other.content;
    if (_$data.containsKey('content') != other._$data.containsKey('content')) {
      return false;
    }
    if (l$content != lOther$content) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$isRaw = isRaw;
    final lOther$isRaw = other.isRaw;
    if (_$data.containsKey('isRaw') != other._$data.containsKey('isRaw')) {
      return false;
    }
    if (l$isRaw != lOther$isRaw) {
      return false;
    }
    final l$model = model;
    final lOther$model = other.model;
    if (_$data.containsKey('model') != other._$data.containsKey('model')) {
      return false;
    }
    if (l$model != lOther$model) {
      return false;
    }
    final l$promptTokens = promptTokens;
    final lOther$promptTokens = other.promptTokens;
    if (_$data.containsKey('promptTokens') !=
        other._$data.containsKey('promptTokens')) {
      return false;
    }
    if (l$promptTokens != lOther$promptTokens) {
      return false;
    }
    final l$raw = raw;
    final lOther$raw = other.raw;
    if (_$data.containsKey('raw') != other._$data.containsKey('raw')) {
      return false;
    }
    if (l$raw != lOther$raw) {
      return false;
    }
    final l$requestId = requestId;
    final lOther$requestId = other.requestId;
    if (_$data.containsKey('requestId') !=
        other._$data.containsKey('requestId')) {
      return false;
    }
    if (l$requestId != lOther$requestId) {
      return false;
    }
    final l$systemPrompt = systemPrompt;
    final lOther$systemPrompt = other.systemPrompt;
    if (_$data.containsKey('systemPrompt') !=
        other._$data.containsKey('systemPrompt')) {
      return false;
    }
    if (l$systemPrompt != lOther$systemPrompt) {
      return false;
    }
    final l$totalTokens = totalTokens;
    final lOther$totalTokens = other.totalTokens;
    if (_$data.containsKey('totalTokens') !=
        other._$data.containsKey('totalTokens')) {
      return false;
    }
    if (l$totalTokens != lOther$totalTokens) {
      return false;
    }
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (_$data.containsKey('updatedAt') !=
        other._$data.containsKey('updatedAt')) {
      return false;
    }
    if (l$updatedAt != lOther$updatedAt) {
      return false;
    }
    final l$userPrompt = userPrompt;
    final lOther$userPrompt = other.userPrompt;
    if (_$data.containsKey('userPrompt') !=
        other._$data.containsKey('userPrompt')) {
      return false;
    }
    if (l$userPrompt != lOther$userPrompt) {
      return false;
    }
    final l$uuid = uuid;
    final lOther$uuid = other.uuid;
    if (_$data.containsKey('uuid') != other._$data.containsKey('uuid')) {
      return false;
    }
    if (l$uuid != lOther$uuid) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$bookEditedId = bookEditedId;
    final l$bookRawId = bookRawId;
    final l$completionTokens = completionTokens;
    final l$content = content;
    final l$createdAt = createdAt;
    final l$isRaw = isRaw;
    final l$model = model;
    final l$promptTokens = promptTokens;
    final l$raw = raw;
    final l$requestId = requestId;
    final l$systemPrompt = systemPrompt;
    final l$totalTokens = totalTokens;
    final l$updatedAt = updatedAt;
    final l$userPrompt = userPrompt;
    final l$uuid = uuid;
    return Object.hashAll([
      _$data.containsKey('bookEditedId') ? l$bookEditedId : const {},
      _$data.containsKey('bookRawId') ? l$bookRawId : const {},
      _$data.containsKey('completionTokens') ? l$completionTokens : const {},
      _$data.containsKey('content') ? l$content : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('isRaw') ? l$isRaw : const {},
      _$data.containsKey('model') ? l$model : const {},
      _$data.containsKey('promptTokens') ? l$promptTokens : const {},
      _$data.containsKey('raw') ? l$raw : const {},
      _$data.containsKey('requestId') ? l$requestId : const {},
      _$data.containsKey('systemPrompt') ? l$systemPrompt : const {},
      _$data.containsKey('totalTokens') ? l$totalTokens : const {},
      _$data.containsKey('updatedAt') ? l$updatedAt : const {},
      _$data.containsKey('userPrompt') ? l$userPrompt : const {},
      _$data.containsKey('uuid') ? l$uuid : const {},
    ]);
  }
}

abstract class CopyWith$Input$BookRevisionCountOrderByAggregateInput<TRes> {
  factory CopyWith$Input$BookRevisionCountOrderByAggregateInput(
    Input$BookRevisionCountOrderByAggregateInput instance,
    TRes Function(Input$BookRevisionCountOrderByAggregateInput) then,
  ) = _CopyWithImpl$Input$BookRevisionCountOrderByAggregateInput;

  factory CopyWith$Input$BookRevisionCountOrderByAggregateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$BookRevisionCountOrderByAggregateInput;

  TRes call({
    Enum$SortOrder? bookEditedId,
    Enum$SortOrder? bookRawId,
    Enum$SortOrder? completionTokens,
    Enum$SortOrder? content,
    Enum$SortOrder? createdAt,
    Enum$SortOrder? isRaw,
    Enum$SortOrder? model,
    Enum$SortOrder? promptTokens,
    Enum$SortOrder? raw,
    Enum$SortOrder? requestId,
    Enum$SortOrder? systemPrompt,
    Enum$SortOrder? totalTokens,
    Enum$SortOrder? updatedAt,
    Enum$SortOrder? userPrompt,
    Enum$SortOrder? uuid,
  });
}

class _CopyWithImpl$Input$BookRevisionCountOrderByAggregateInput<TRes>
    implements CopyWith$Input$BookRevisionCountOrderByAggregateInput<TRes> {
  _CopyWithImpl$Input$BookRevisionCountOrderByAggregateInput(
    this._instance,
    this._then,
  );

  final Input$BookRevisionCountOrderByAggregateInput _instance;

  final TRes Function(Input$BookRevisionCountOrderByAggregateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? bookEditedId = _undefined,
    Object? bookRawId = _undefined,
    Object? completionTokens = _undefined,
    Object? content = _undefined,
    Object? createdAt = _undefined,
    Object? isRaw = _undefined,
    Object? model = _undefined,
    Object? promptTokens = _undefined,
    Object? raw = _undefined,
    Object? requestId = _undefined,
    Object? systemPrompt = _undefined,
    Object? totalTokens = _undefined,
    Object? updatedAt = _undefined,
    Object? userPrompt = _undefined,
    Object? uuid = _undefined,
  }) =>
      _then(Input$BookRevisionCountOrderByAggregateInput._({
        ..._instance._$data,
        if (bookEditedId != _undefined)
          'bookEditedId': (bookEditedId as Enum$SortOrder?),
        if (bookRawId != _undefined)
          'bookRawId': (bookRawId as Enum$SortOrder?),
        if (completionTokens != _undefined)
          'completionTokens': (completionTokens as Enum$SortOrder?),
        if (content != _undefined) 'content': (content as Enum$SortOrder?),
        if (createdAt != _undefined)
          'createdAt': (createdAt as Enum$SortOrder?),
        if (isRaw != _undefined) 'isRaw': (isRaw as Enum$SortOrder?),
        if (model != _undefined) 'model': (model as Enum$SortOrder?),
        if (promptTokens != _undefined)
          'promptTokens': (promptTokens as Enum$SortOrder?),
        if (raw != _undefined) 'raw': (raw as Enum$SortOrder?),
        if (requestId != _undefined)
          'requestId': (requestId as Enum$SortOrder?),
        if (systemPrompt != _undefined)
          'systemPrompt': (systemPrompt as Enum$SortOrder?),
        if (totalTokens != _undefined)
          'totalTokens': (totalTokens as Enum$SortOrder?),
        if (updatedAt != _undefined)
          'updatedAt': (updatedAt as Enum$SortOrder?),
        if (userPrompt != _undefined)
          'userPrompt': (userPrompt as Enum$SortOrder?),
        if (uuid != _undefined) 'uuid': (uuid as Enum$SortOrder?),
      }));
}

class _CopyWithStubImpl$Input$BookRevisionCountOrderByAggregateInput<TRes>
    implements CopyWith$Input$BookRevisionCountOrderByAggregateInput<TRes> {
  _CopyWithStubImpl$Input$BookRevisionCountOrderByAggregateInput(this._res);

  TRes _res;

  call({
    Enum$SortOrder? bookEditedId,
    Enum$SortOrder? bookRawId,
    Enum$SortOrder? completionTokens,
    Enum$SortOrder? content,
    Enum$SortOrder? createdAt,
    Enum$SortOrder? isRaw,
    Enum$SortOrder? model,
    Enum$SortOrder? promptTokens,
    Enum$SortOrder? raw,
    Enum$SortOrder? requestId,
    Enum$SortOrder? systemPrompt,
    Enum$SortOrder? totalTokens,
    Enum$SortOrder? updatedAt,
    Enum$SortOrder? userPrompt,
    Enum$SortOrder? uuid,
  }) =>
      _res;
}

class Input$BookRevisionCreateInput {
  factory Input$BookRevisionCreateInput({
    Input$BookCreateNestedOneWithoutBookEditedInput? bookEdited,
    Input$BookCreateNestedOneWithoutBookRawInput? bookRaw,
    int? completionTokens,
    Input$BookRevisionCreatecontentInput? content,
    String? createdAt,
    bool? isRaw,
    String? model,
    int? promptTokens,
    String? raw,
    String? requestId,
    String? systemPrompt,
    int? totalTokens,
    String? updatedAt,
    String? userPrompt,
    String? uuid,
  }) =>
      Input$BookRevisionCreateInput._({
        if (bookEdited != null) r'bookEdited': bookEdited,
        if (bookRaw != null) r'bookRaw': bookRaw,
        if (completionTokens != null) r'completionTokens': completionTokens,
        if (content != null) r'content': content,
        if (createdAt != null) r'createdAt': createdAt,
        if (isRaw != null) r'isRaw': isRaw,
        if (model != null) r'model': model,
        if (promptTokens != null) r'promptTokens': promptTokens,
        if (raw != null) r'raw': raw,
        if (requestId != null) r'requestId': requestId,
        if (systemPrompt != null) r'systemPrompt': systemPrompt,
        if (totalTokens != null) r'totalTokens': totalTokens,
        if (updatedAt != null) r'updatedAt': updatedAt,
        if (userPrompt != null) r'userPrompt': userPrompt,
        if (uuid != null) r'uuid': uuid,
      });

  Input$BookRevisionCreateInput._(this._$data);

  factory Input$BookRevisionCreateInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('bookEdited')) {
      final l$bookEdited = data['bookEdited'];
      result$data['bookEdited'] = l$bookEdited == null
          ? null
          : Input$BookCreateNestedOneWithoutBookEditedInput.fromJson(
              (l$bookEdited as Map<String, dynamic>));
    }
    if (data.containsKey('bookRaw')) {
      final l$bookRaw = data['bookRaw'];
      result$data['bookRaw'] = l$bookRaw == null
          ? null
          : Input$BookCreateNestedOneWithoutBookRawInput.fromJson(
              (l$bookRaw as Map<String, dynamic>));
    }
    if (data.containsKey('completionTokens')) {
      final l$completionTokens = data['completionTokens'];
      result$data['completionTokens'] = (l$completionTokens as int?);
    }
    if (data.containsKey('content')) {
      final l$content = data['content'];
      result$data['content'] = l$content == null
          ? null
          : Input$BookRevisionCreatecontentInput.fromJson(
              (l$content as Map<String, dynamic>));
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = (l$createdAt as String?);
    }
    if (data.containsKey('isRaw')) {
      final l$isRaw = data['isRaw'];
      result$data['isRaw'] = (l$isRaw as bool?);
    }
    if (data.containsKey('model')) {
      final l$model = data['model'];
      result$data['model'] = (l$model as String?);
    }
    if (data.containsKey('promptTokens')) {
      final l$promptTokens = data['promptTokens'];
      result$data['promptTokens'] = (l$promptTokens as int?);
    }
    if (data.containsKey('raw')) {
      final l$raw = data['raw'];
      result$data['raw'] = (l$raw as String?);
    }
    if (data.containsKey('requestId')) {
      final l$requestId = data['requestId'];
      result$data['requestId'] = (l$requestId as String?);
    }
    if (data.containsKey('systemPrompt')) {
      final l$systemPrompt = data['systemPrompt'];
      result$data['systemPrompt'] = (l$systemPrompt as String?);
    }
    if (data.containsKey('totalTokens')) {
      final l$totalTokens = data['totalTokens'];
      result$data['totalTokens'] = (l$totalTokens as int?);
    }
    if (data.containsKey('updatedAt')) {
      final l$updatedAt = data['updatedAt'];
      result$data['updatedAt'] = (l$updatedAt as String?);
    }
    if (data.containsKey('userPrompt')) {
      final l$userPrompt = data['userPrompt'];
      result$data['userPrompt'] = (l$userPrompt as String?);
    }
    if (data.containsKey('uuid')) {
      final l$uuid = data['uuid'];
      result$data['uuid'] = (l$uuid as String?);
    }
    return Input$BookRevisionCreateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$BookCreateNestedOneWithoutBookEditedInput? get bookEdited =>
      (_$data['bookEdited']
          as Input$BookCreateNestedOneWithoutBookEditedInput?);

  Input$BookCreateNestedOneWithoutBookRawInput? get bookRaw =>
      (_$data['bookRaw'] as Input$BookCreateNestedOneWithoutBookRawInput?);

  int? get completionTokens => (_$data['completionTokens'] as int?);

  Input$BookRevisionCreatecontentInput? get content =>
      (_$data['content'] as Input$BookRevisionCreatecontentInput?);

  String? get createdAt => (_$data['createdAt'] as String?);

  bool? get isRaw => (_$data['isRaw'] as bool?);

  String? get model => (_$data['model'] as String?);

  int? get promptTokens => (_$data['promptTokens'] as int?);

  String? get raw => (_$data['raw'] as String?);

  String? get requestId => (_$data['requestId'] as String?);

  String? get systemPrompt => (_$data['systemPrompt'] as String?);

  int? get totalTokens => (_$data['totalTokens'] as int?);

  String? get updatedAt => (_$data['updatedAt'] as String?);

  String? get userPrompt => (_$data['userPrompt'] as String?);

  String? get uuid => (_$data['uuid'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('bookEdited')) {
      final l$bookEdited = bookEdited;
      result$data['bookEdited'] = l$bookEdited?.toJson();
    }
    if (_$data.containsKey('bookRaw')) {
      final l$bookRaw = bookRaw;
      result$data['bookRaw'] = l$bookRaw?.toJson();
    }
    if (_$data.containsKey('completionTokens')) {
      final l$completionTokens = completionTokens;
      result$data['completionTokens'] = l$completionTokens;
    }
    if (_$data.containsKey('content')) {
      final l$content = content;
      result$data['content'] = l$content?.toJson();
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt;
    }
    if (_$data.containsKey('isRaw')) {
      final l$isRaw = isRaw;
      result$data['isRaw'] = l$isRaw;
    }
    if (_$data.containsKey('model')) {
      final l$model = model;
      result$data['model'] = l$model;
    }
    if (_$data.containsKey('promptTokens')) {
      final l$promptTokens = promptTokens;
      result$data['promptTokens'] = l$promptTokens;
    }
    if (_$data.containsKey('raw')) {
      final l$raw = raw;
      result$data['raw'] = l$raw;
    }
    if (_$data.containsKey('requestId')) {
      final l$requestId = requestId;
      result$data['requestId'] = l$requestId;
    }
    if (_$data.containsKey('systemPrompt')) {
      final l$systemPrompt = systemPrompt;
      result$data['systemPrompt'] = l$systemPrompt;
    }
    if (_$data.containsKey('totalTokens')) {
      final l$totalTokens = totalTokens;
      result$data['totalTokens'] = l$totalTokens;
    }
    if (_$data.containsKey('updatedAt')) {
      final l$updatedAt = updatedAt;
      result$data['updatedAt'] = l$updatedAt;
    }
    if (_$data.containsKey('userPrompt')) {
      final l$userPrompt = userPrompt;
      result$data['userPrompt'] = l$userPrompt;
    }
    if (_$data.containsKey('uuid')) {
      final l$uuid = uuid;
      result$data['uuid'] = l$uuid;
    }
    return result$data;
  }

  CopyWith$Input$BookRevisionCreateInput<Input$BookRevisionCreateInput>
      get copyWith => CopyWith$Input$BookRevisionCreateInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$BookRevisionCreateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$bookEdited = bookEdited;
    final lOther$bookEdited = other.bookEdited;
    if (_$data.containsKey('bookEdited') !=
        other._$data.containsKey('bookEdited')) {
      return false;
    }
    if (l$bookEdited != lOther$bookEdited) {
      return false;
    }
    final l$bookRaw = bookRaw;
    final lOther$bookRaw = other.bookRaw;
    if (_$data.containsKey('bookRaw') != other._$data.containsKey('bookRaw')) {
      return false;
    }
    if (l$bookRaw != lOther$bookRaw) {
      return false;
    }
    final l$completionTokens = completionTokens;
    final lOther$completionTokens = other.completionTokens;
    if (_$data.containsKey('completionTokens') !=
        other._$data.containsKey('completionTokens')) {
      return false;
    }
    if (l$completionTokens != lOther$completionTokens) {
      return false;
    }
    final l$content = content;
    final lOther$content = other.content;
    if (_$data.containsKey('content') != other._$data.containsKey('content')) {
      return false;
    }
    if (l$content != lOther$content) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$isRaw = isRaw;
    final lOther$isRaw = other.isRaw;
    if (_$data.containsKey('isRaw') != other._$data.containsKey('isRaw')) {
      return false;
    }
    if (l$isRaw != lOther$isRaw) {
      return false;
    }
    final l$model = model;
    final lOther$model = other.model;
    if (_$data.containsKey('model') != other._$data.containsKey('model')) {
      return false;
    }
    if (l$model != lOther$model) {
      return false;
    }
    final l$promptTokens = promptTokens;
    final lOther$promptTokens = other.promptTokens;
    if (_$data.containsKey('promptTokens') !=
        other._$data.containsKey('promptTokens')) {
      return false;
    }
    if (l$promptTokens != lOther$promptTokens) {
      return false;
    }
    final l$raw = raw;
    final lOther$raw = other.raw;
    if (_$data.containsKey('raw') != other._$data.containsKey('raw')) {
      return false;
    }
    if (l$raw != lOther$raw) {
      return false;
    }
    final l$requestId = requestId;
    final lOther$requestId = other.requestId;
    if (_$data.containsKey('requestId') !=
        other._$data.containsKey('requestId')) {
      return false;
    }
    if (l$requestId != lOther$requestId) {
      return false;
    }
    final l$systemPrompt = systemPrompt;
    final lOther$systemPrompt = other.systemPrompt;
    if (_$data.containsKey('systemPrompt') !=
        other._$data.containsKey('systemPrompt')) {
      return false;
    }
    if (l$systemPrompt != lOther$systemPrompt) {
      return false;
    }
    final l$totalTokens = totalTokens;
    final lOther$totalTokens = other.totalTokens;
    if (_$data.containsKey('totalTokens') !=
        other._$data.containsKey('totalTokens')) {
      return false;
    }
    if (l$totalTokens != lOther$totalTokens) {
      return false;
    }
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (_$data.containsKey('updatedAt') !=
        other._$data.containsKey('updatedAt')) {
      return false;
    }
    if (l$updatedAt != lOther$updatedAt) {
      return false;
    }
    final l$userPrompt = userPrompt;
    final lOther$userPrompt = other.userPrompt;
    if (_$data.containsKey('userPrompt') !=
        other._$data.containsKey('userPrompt')) {
      return false;
    }
    if (l$userPrompt != lOther$userPrompt) {
      return false;
    }
    final l$uuid = uuid;
    final lOther$uuid = other.uuid;
    if (_$data.containsKey('uuid') != other._$data.containsKey('uuid')) {
      return false;
    }
    if (l$uuid != lOther$uuid) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$bookEdited = bookEdited;
    final l$bookRaw = bookRaw;
    final l$completionTokens = completionTokens;
    final l$content = content;
    final l$createdAt = createdAt;
    final l$isRaw = isRaw;
    final l$model = model;
    final l$promptTokens = promptTokens;
    final l$raw = raw;
    final l$requestId = requestId;
    final l$systemPrompt = systemPrompt;
    final l$totalTokens = totalTokens;
    final l$updatedAt = updatedAt;
    final l$userPrompt = userPrompt;
    final l$uuid = uuid;
    return Object.hashAll([
      _$data.containsKey('bookEdited') ? l$bookEdited : const {},
      _$data.containsKey('bookRaw') ? l$bookRaw : const {},
      _$data.containsKey('completionTokens') ? l$completionTokens : const {},
      _$data.containsKey('content') ? l$content : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('isRaw') ? l$isRaw : const {},
      _$data.containsKey('model') ? l$model : const {},
      _$data.containsKey('promptTokens') ? l$promptTokens : const {},
      _$data.containsKey('raw') ? l$raw : const {},
      _$data.containsKey('requestId') ? l$requestId : const {},
      _$data.containsKey('systemPrompt') ? l$systemPrompt : const {},
      _$data.containsKey('totalTokens') ? l$totalTokens : const {},
      _$data.containsKey('updatedAt') ? l$updatedAt : const {},
      _$data.containsKey('userPrompt') ? l$userPrompt : const {},
      _$data.containsKey('uuid') ? l$uuid : const {},
    ]);
  }
}

abstract class CopyWith$Input$BookRevisionCreateInput<TRes> {
  factory CopyWith$Input$BookRevisionCreateInput(
    Input$BookRevisionCreateInput instance,
    TRes Function(Input$BookRevisionCreateInput) then,
  ) = _CopyWithImpl$Input$BookRevisionCreateInput;

  factory CopyWith$Input$BookRevisionCreateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$BookRevisionCreateInput;

  TRes call({
    Input$BookCreateNestedOneWithoutBookEditedInput? bookEdited,
    Input$BookCreateNestedOneWithoutBookRawInput? bookRaw,
    int? completionTokens,
    Input$BookRevisionCreatecontentInput? content,
    String? createdAt,
    bool? isRaw,
    String? model,
    int? promptTokens,
    String? raw,
    String? requestId,
    String? systemPrompt,
    int? totalTokens,
    String? updatedAt,
    String? userPrompt,
    String? uuid,
  });
  CopyWith$Input$BookCreateNestedOneWithoutBookEditedInput<TRes> get bookEdited;
  CopyWith$Input$BookCreateNestedOneWithoutBookRawInput<TRes> get bookRaw;
  CopyWith$Input$BookRevisionCreatecontentInput<TRes> get content;
}

class _CopyWithImpl$Input$BookRevisionCreateInput<TRes>
    implements CopyWith$Input$BookRevisionCreateInput<TRes> {
  _CopyWithImpl$Input$BookRevisionCreateInput(
    this._instance,
    this._then,
  );

  final Input$BookRevisionCreateInput _instance;

  final TRes Function(Input$BookRevisionCreateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? bookEdited = _undefined,
    Object? bookRaw = _undefined,
    Object? completionTokens = _undefined,
    Object? content = _undefined,
    Object? createdAt = _undefined,
    Object? isRaw = _undefined,
    Object? model = _undefined,
    Object? promptTokens = _undefined,
    Object? raw = _undefined,
    Object? requestId = _undefined,
    Object? systemPrompt = _undefined,
    Object? totalTokens = _undefined,
    Object? updatedAt = _undefined,
    Object? userPrompt = _undefined,
    Object? uuid = _undefined,
  }) =>
      _then(Input$BookRevisionCreateInput._({
        ..._instance._$data,
        if (bookEdited != _undefined)
          'bookEdited':
              (bookEdited as Input$BookCreateNestedOneWithoutBookEditedInput?),
        if (bookRaw != _undefined)
          'bookRaw': (bookRaw as Input$BookCreateNestedOneWithoutBookRawInput?),
        if (completionTokens != _undefined)
          'completionTokens': (completionTokens as int?),
        if (content != _undefined)
          'content': (content as Input$BookRevisionCreatecontentInput?),
        if (createdAt != _undefined) 'createdAt': (createdAt as String?),
        if (isRaw != _undefined) 'isRaw': (isRaw as bool?),
        if (model != _undefined) 'model': (model as String?),
        if (promptTokens != _undefined) 'promptTokens': (promptTokens as int?),
        if (raw != _undefined) 'raw': (raw as String?),
        if (requestId != _undefined) 'requestId': (requestId as String?),
        if (systemPrompt != _undefined)
          'systemPrompt': (systemPrompt as String?),
        if (totalTokens != _undefined) 'totalTokens': (totalTokens as int?),
        if (updatedAt != _undefined) 'updatedAt': (updatedAt as String?),
        if (userPrompt != _undefined) 'userPrompt': (userPrompt as String?),
        if (uuid != _undefined) 'uuid': (uuid as String?),
      }));

  CopyWith$Input$BookCreateNestedOneWithoutBookEditedInput<TRes>
      get bookEdited {
    final local$bookEdited = _instance.bookEdited;
    return local$bookEdited == null
        ? CopyWith$Input$BookCreateNestedOneWithoutBookEditedInput.stub(
            _then(_instance))
        : CopyWith$Input$BookCreateNestedOneWithoutBookEditedInput(
            local$bookEdited, (e) => call(bookEdited: e));
  }

  CopyWith$Input$BookCreateNestedOneWithoutBookRawInput<TRes> get bookRaw {
    final local$bookRaw = _instance.bookRaw;
    return local$bookRaw == null
        ? CopyWith$Input$BookCreateNestedOneWithoutBookRawInput.stub(
            _then(_instance))
        : CopyWith$Input$BookCreateNestedOneWithoutBookRawInput(
            local$bookRaw, (e) => call(bookRaw: e));
  }

  CopyWith$Input$BookRevisionCreatecontentInput<TRes> get content {
    final local$content = _instance.content;
    return local$content == null
        ? CopyWith$Input$BookRevisionCreatecontentInput.stub(_then(_instance))
        : CopyWith$Input$BookRevisionCreatecontentInput(
            local$content, (e) => call(content: e));
  }
}

class _CopyWithStubImpl$Input$BookRevisionCreateInput<TRes>
    implements CopyWith$Input$BookRevisionCreateInput<TRes> {
  _CopyWithStubImpl$Input$BookRevisionCreateInput(this._res);

  TRes _res;

  call({
    Input$BookCreateNestedOneWithoutBookEditedInput? bookEdited,
    Input$BookCreateNestedOneWithoutBookRawInput? bookRaw,
    int? completionTokens,
    Input$BookRevisionCreatecontentInput? content,
    String? createdAt,
    bool? isRaw,
    String? model,
    int? promptTokens,
    String? raw,
    String? requestId,
    String? systemPrompt,
    int? totalTokens,
    String? updatedAt,
    String? userPrompt,
    String? uuid,
  }) =>
      _res;

  CopyWith$Input$BookCreateNestedOneWithoutBookEditedInput<TRes>
      get bookEdited =>
          CopyWith$Input$BookCreateNestedOneWithoutBookEditedInput.stub(_res);

  CopyWith$Input$BookCreateNestedOneWithoutBookRawInput<TRes> get bookRaw =>
      CopyWith$Input$BookCreateNestedOneWithoutBookRawInput.stub(_res);

  CopyWith$Input$BookRevisionCreatecontentInput<TRes> get content =>
      CopyWith$Input$BookRevisionCreatecontentInput.stub(_res);
}

class Input$BookRevisionCreateManyInput {
  factory Input$BookRevisionCreateManyInput({
    String? bookEditedId,
    String? bookRawId,
    int? completionTokens,
    Input$BookRevisionCreatecontentInput? content,
    String? createdAt,
    bool? isRaw,
    String? model,
    int? promptTokens,
    String? raw,
    String? requestId,
    String? systemPrompt,
    int? totalTokens,
    String? updatedAt,
    String? userPrompt,
    String? uuid,
  }) =>
      Input$BookRevisionCreateManyInput._({
        if (bookEditedId != null) r'bookEditedId': bookEditedId,
        if (bookRawId != null) r'bookRawId': bookRawId,
        if (completionTokens != null) r'completionTokens': completionTokens,
        if (content != null) r'content': content,
        if (createdAt != null) r'createdAt': createdAt,
        if (isRaw != null) r'isRaw': isRaw,
        if (model != null) r'model': model,
        if (promptTokens != null) r'promptTokens': promptTokens,
        if (raw != null) r'raw': raw,
        if (requestId != null) r'requestId': requestId,
        if (systemPrompt != null) r'systemPrompt': systemPrompt,
        if (totalTokens != null) r'totalTokens': totalTokens,
        if (updatedAt != null) r'updatedAt': updatedAt,
        if (userPrompt != null) r'userPrompt': userPrompt,
        if (uuid != null) r'uuid': uuid,
      });

  Input$BookRevisionCreateManyInput._(this._$data);

  factory Input$BookRevisionCreateManyInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('bookEditedId')) {
      final l$bookEditedId = data['bookEditedId'];
      result$data['bookEditedId'] = (l$bookEditedId as String?);
    }
    if (data.containsKey('bookRawId')) {
      final l$bookRawId = data['bookRawId'];
      result$data['bookRawId'] = (l$bookRawId as String?);
    }
    if (data.containsKey('completionTokens')) {
      final l$completionTokens = data['completionTokens'];
      result$data['completionTokens'] = (l$completionTokens as int?);
    }
    if (data.containsKey('content')) {
      final l$content = data['content'];
      result$data['content'] = l$content == null
          ? null
          : Input$BookRevisionCreatecontentInput.fromJson(
              (l$content as Map<String, dynamic>));
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = (l$createdAt as String?);
    }
    if (data.containsKey('isRaw')) {
      final l$isRaw = data['isRaw'];
      result$data['isRaw'] = (l$isRaw as bool?);
    }
    if (data.containsKey('model')) {
      final l$model = data['model'];
      result$data['model'] = (l$model as String?);
    }
    if (data.containsKey('promptTokens')) {
      final l$promptTokens = data['promptTokens'];
      result$data['promptTokens'] = (l$promptTokens as int?);
    }
    if (data.containsKey('raw')) {
      final l$raw = data['raw'];
      result$data['raw'] = (l$raw as String?);
    }
    if (data.containsKey('requestId')) {
      final l$requestId = data['requestId'];
      result$data['requestId'] = (l$requestId as String?);
    }
    if (data.containsKey('systemPrompt')) {
      final l$systemPrompt = data['systemPrompt'];
      result$data['systemPrompt'] = (l$systemPrompt as String?);
    }
    if (data.containsKey('totalTokens')) {
      final l$totalTokens = data['totalTokens'];
      result$data['totalTokens'] = (l$totalTokens as int?);
    }
    if (data.containsKey('updatedAt')) {
      final l$updatedAt = data['updatedAt'];
      result$data['updatedAt'] = (l$updatedAt as String?);
    }
    if (data.containsKey('userPrompt')) {
      final l$userPrompt = data['userPrompt'];
      result$data['userPrompt'] = (l$userPrompt as String?);
    }
    if (data.containsKey('uuid')) {
      final l$uuid = data['uuid'];
      result$data['uuid'] = (l$uuid as String?);
    }
    return Input$BookRevisionCreateManyInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get bookEditedId => (_$data['bookEditedId'] as String?);

  String? get bookRawId => (_$data['bookRawId'] as String?);

  int? get completionTokens => (_$data['completionTokens'] as int?);

  Input$BookRevisionCreatecontentInput? get content =>
      (_$data['content'] as Input$BookRevisionCreatecontentInput?);

  String? get createdAt => (_$data['createdAt'] as String?);

  bool? get isRaw => (_$data['isRaw'] as bool?);

  String? get model => (_$data['model'] as String?);

  int? get promptTokens => (_$data['promptTokens'] as int?);

  String? get raw => (_$data['raw'] as String?);

  String? get requestId => (_$data['requestId'] as String?);

  String? get systemPrompt => (_$data['systemPrompt'] as String?);

  int? get totalTokens => (_$data['totalTokens'] as int?);

  String? get updatedAt => (_$data['updatedAt'] as String?);

  String? get userPrompt => (_$data['userPrompt'] as String?);

  String? get uuid => (_$data['uuid'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('bookEditedId')) {
      final l$bookEditedId = bookEditedId;
      result$data['bookEditedId'] = l$bookEditedId;
    }
    if (_$data.containsKey('bookRawId')) {
      final l$bookRawId = bookRawId;
      result$data['bookRawId'] = l$bookRawId;
    }
    if (_$data.containsKey('completionTokens')) {
      final l$completionTokens = completionTokens;
      result$data['completionTokens'] = l$completionTokens;
    }
    if (_$data.containsKey('content')) {
      final l$content = content;
      result$data['content'] = l$content?.toJson();
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt;
    }
    if (_$data.containsKey('isRaw')) {
      final l$isRaw = isRaw;
      result$data['isRaw'] = l$isRaw;
    }
    if (_$data.containsKey('model')) {
      final l$model = model;
      result$data['model'] = l$model;
    }
    if (_$data.containsKey('promptTokens')) {
      final l$promptTokens = promptTokens;
      result$data['promptTokens'] = l$promptTokens;
    }
    if (_$data.containsKey('raw')) {
      final l$raw = raw;
      result$data['raw'] = l$raw;
    }
    if (_$data.containsKey('requestId')) {
      final l$requestId = requestId;
      result$data['requestId'] = l$requestId;
    }
    if (_$data.containsKey('systemPrompt')) {
      final l$systemPrompt = systemPrompt;
      result$data['systemPrompt'] = l$systemPrompt;
    }
    if (_$data.containsKey('totalTokens')) {
      final l$totalTokens = totalTokens;
      result$data['totalTokens'] = l$totalTokens;
    }
    if (_$data.containsKey('updatedAt')) {
      final l$updatedAt = updatedAt;
      result$data['updatedAt'] = l$updatedAt;
    }
    if (_$data.containsKey('userPrompt')) {
      final l$userPrompt = userPrompt;
      result$data['userPrompt'] = l$userPrompt;
    }
    if (_$data.containsKey('uuid')) {
      final l$uuid = uuid;
      result$data['uuid'] = l$uuid;
    }
    return result$data;
  }

  CopyWith$Input$BookRevisionCreateManyInput<Input$BookRevisionCreateManyInput>
      get copyWith => CopyWith$Input$BookRevisionCreateManyInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$BookRevisionCreateManyInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$bookEditedId = bookEditedId;
    final lOther$bookEditedId = other.bookEditedId;
    if (_$data.containsKey('bookEditedId') !=
        other._$data.containsKey('bookEditedId')) {
      return false;
    }
    if (l$bookEditedId != lOther$bookEditedId) {
      return false;
    }
    final l$bookRawId = bookRawId;
    final lOther$bookRawId = other.bookRawId;
    if (_$data.containsKey('bookRawId') !=
        other._$data.containsKey('bookRawId')) {
      return false;
    }
    if (l$bookRawId != lOther$bookRawId) {
      return false;
    }
    final l$completionTokens = completionTokens;
    final lOther$completionTokens = other.completionTokens;
    if (_$data.containsKey('completionTokens') !=
        other._$data.containsKey('completionTokens')) {
      return false;
    }
    if (l$completionTokens != lOther$completionTokens) {
      return false;
    }
    final l$content = content;
    final lOther$content = other.content;
    if (_$data.containsKey('content') != other._$data.containsKey('content')) {
      return false;
    }
    if (l$content != lOther$content) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$isRaw = isRaw;
    final lOther$isRaw = other.isRaw;
    if (_$data.containsKey('isRaw') != other._$data.containsKey('isRaw')) {
      return false;
    }
    if (l$isRaw != lOther$isRaw) {
      return false;
    }
    final l$model = model;
    final lOther$model = other.model;
    if (_$data.containsKey('model') != other._$data.containsKey('model')) {
      return false;
    }
    if (l$model != lOther$model) {
      return false;
    }
    final l$promptTokens = promptTokens;
    final lOther$promptTokens = other.promptTokens;
    if (_$data.containsKey('promptTokens') !=
        other._$data.containsKey('promptTokens')) {
      return false;
    }
    if (l$promptTokens != lOther$promptTokens) {
      return false;
    }
    final l$raw = raw;
    final lOther$raw = other.raw;
    if (_$data.containsKey('raw') != other._$data.containsKey('raw')) {
      return false;
    }
    if (l$raw != lOther$raw) {
      return false;
    }
    final l$requestId = requestId;
    final lOther$requestId = other.requestId;
    if (_$data.containsKey('requestId') !=
        other._$data.containsKey('requestId')) {
      return false;
    }
    if (l$requestId != lOther$requestId) {
      return false;
    }
    final l$systemPrompt = systemPrompt;
    final lOther$systemPrompt = other.systemPrompt;
    if (_$data.containsKey('systemPrompt') !=
        other._$data.containsKey('systemPrompt')) {
      return false;
    }
    if (l$systemPrompt != lOther$systemPrompt) {
      return false;
    }
    final l$totalTokens = totalTokens;
    final lOther$totalTokens = other.totalTokens;
    if (_$data.containsKey('totalTokens') !=
        other._$data.containsKey('totalTokens')) {
      return false;
    }
    if (l$totalTokens != lOther$totalTokens) {
      return false;
    }
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (_$data.containsKey('updatedAt') !=
        other._$data.containsKey('updatedAt')) {
      return false;
    }
    if (l$updatedAt != lOther$updatedAt) {
      return false;
    }
    final l$userPrompt = userPrompt;
    final lOther$userPrompt = other.userPrompt;
    if (_$data.containsKey('userPrompt') !=
        other._$data.containsKey('userPrompt')) {
      return false;
    }
    if (l$userPrompt != lOther$userPrompt) {
      return false;
    }
    final l$uuid = uuid;
    final lOther$uuid = other.uuid;
    if (_$data.containsKey('uuid') != other._$data.containsKey('uuid')) {
      return false;
    }
    if (l$uuid != lOther$uuid) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$bookEditedId = bookEditedId;
    final l$bookRawId = bookRawId;
    final l$completionTokens = completionTokens;
    final l$content = content;
    final l$createdAt = createdAt;
    final l$isRaw = isRaw;
    final l$model = model;
    final l$promptTokens = promptTokens;
    final l$raw = raw;
    final l$requestId = requestId;
    final l$systemPrompt = systemPrompt;
    final l$totalTokens = totalTokens;
    final l$updatedAt = updatedAt;
    final l$userPrompt = userPrompt;
    final l$uuid = uuid;
    return Object.hashAll([
      _$data.containsKey('bookEditedId') ? l$bookEditedId : const {},
      _$data.containsKey('bookRawId') ? l$bookRawId : const {},
      _$data.containsKey('completionTokens') ? l$completionTokens : const {},
      _$data.containsKey('content') ? l$content : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('isRaw') ? l$isRaw : const {},
      _$data.containsKey('model') ? l$model : const {},
      _$data.containsKey('promptTokens') ? l$promptTokens : const {},
      _$data.containsKey('raw') ? l$raw : const {},
      _$data.containsKey('requestId') ? l$requestId : const {},
      _$data.containsKey('systemPrompt') ? l$systemPrompt : const {},
      _$data.containsKey('totalTokens') ? l$totalTokens : const {},
      _$data.containsKey('updatedAt') ? l$updatedAt : const {},
      _$data.containsKey('userPrompt') ? l$userPrompt : const {},
      _$data.containsKey('uuid') ? l$uuid : const {},
    ]);
  }
}

abstract class CopyWith$Input$BookRevisionCreateManyInput<TRes> {
  factory CopyWith$Input$BookRevisionCreateManyInput(
    Input$BookRevisionCreateManyInput instance,
    TRes Function(Input$BookRevisionCreateManyInput) then,
  ) = _CopyWithImpl$Input$BookRevisionCreateManyInput;

  factory CopyWith$Input$BookRevisionCreateManyInput.stub(TRes res) =
      _CopyWithStubImpl$Input$BookRevisionCreateManyInput;

  TRes call({
    String? bookEditedId,
    String? bookRawId,
    int? completionTokens,
    Input$BookRevisionCreatecontentInput? content,
    String? createdAt,
    bool? isRaw,
    String? model,
    int? promptTokens,
    String? raw,
    String? requestId,
    String? systemPrompt,
    int? totalTokens,
    String? updatedAt,
    String? userPrompt,
    String? uuid,
  });
  CopyWith$Input$BookRevisionCreatecontentInput<TRes> get content;
}

class _CopyWithImpl$Input$BookRevisionCreateManyInput<TRes>
    implements CopyWith$Input$BookRevisionCreateManyInput<TRes> {
  _CopyWithImpl$Input$BookRevisionCreateManyInput(
    this._instance,
    this._then,
  );

  final Input$BookRevisionCreateManyInput _instance;

  final TRes Function(Input$BookRevisionCreateManyInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? bookEditedId = _undefined,
    Object? bookRawId = _undefined,
    Object? completionTokens = _undefined,
    Object? content = _undefined,
    Object? createdAt = _undefined,
    Object? isRaw = _undefined,
    Object? model = _undefined,
    Object? promptTokens = _undefined,
    Object? raw = _undefined,
    Object? requestId = _undefined,
    Object? systemPrompt = _undefined,
    Object? totalTokens = _undefined,
    Object? updatedAt = _undefined,
    Object? userPrompt = _undefined,
    Object? uuid = _undefined,
  }) =>
      _then(Input$BookRevisionCreateManyInput._({
        ..._instance._$data,
        if (bookEditedId != _undefined)
          'bookEditedId': (bookEditedId as String?),
        if (bookRawId != _undefined) 'bookRawId': (bookRawId as String?),
        if (completionTokens != _undefined)
          'completionTokens': (completionTokens as int?),
        if (content != _undefined)
          'content': (content as Input$BookRevisionCreatecontentInput?),
        if (createdAt != _undefined) 'createdAt': (createdAt as String?),
        if (isRaw != _undefined) 'isRaw': (isRaw as bool?),
        if (model != _undefined) 'model': (model as String?),
        if (promptTokens != _undefined) 'promptTokens': (promptTokens as int?),
        if (raw != _undefined) 'raw': (raw as String?),
        if (requestId != _undefined) 'requestId': (requestId as String?),
        if (systemPrompt != _undefined)
          'systemPrompt': (systemPrompt as String?),
        if (totalTokens != _undefined) 'totalTokens': (totalTokens as int?),
        if (updatedAt != _undefined) 'updatedAt': (updatedAt as String?),
        if (userPrompt != _undefined) 'userPrompt': (userPrompt as String?),
        if (uuid != _undefined) 'uuid': (uuid as String?),
      }));

  CopyWith$Input$BookRevisionCreatecontentInput<TRes> get content {
    final local$content = _instance.content;
    return local$content == null
        ? CopyWith$Input$BookRevisionCreatecontentInput.stub(_then(_instance))
        : CopyWith$Input$BookRevisionCreatecontentInput(
            local$content, (e) => call(content: e));
  }
}

class _CopyWithStubImpl$Input$BookRevisionCreateManyInput<TRes>
    implements CopyWith$Input$BookRevisionCreateManyInput<TRes> {
  _CopyWithStubImpl$Input$BookRevisionCreateManyInput(this._res);

  TRes _res;

  call({
    String? bookEditedId,
    String? bookRawId,
    int? completionTokens,
    Input$BookRevisionCreatecontentInput? content,
    String? createdAt,
    bool? isRaw,
    String? model,
    int? promptTokens,
    String? raw,
    String? requestId,
    String? systemPrompt,
    int? totalTokens,
    String? updatedAt,
    String? userPrompt,
    String? uuid,
  }) =>
      _res;

  CopyWith$Input$BookRevisionCreatecontentInput<TRes> get content =>
      CopyWith$Input$BookRevisionCreatecontentInput.stub(_res);
}

class Input$BookRevisionCreateNestedOneWithoutBookEditedInput {
  factory Input$BookRevisionCreateNestedOneWithoutBookEditedInput({
    Input$BookRevisionWhereUniqueInput? connect,
    Input$BookRevisionCreateOrConnectWithoutBookEditedInput? connectOrCreate,
    Input$BookRevisionCreateWithoutBookEditedInput? create,
  }) =>
      Input$BookRevisionCreateNestedOneWithoutBookEditedInput._({
        if (connect != null) r'connect': connect,
        if (connectOrCreate != null) r'connectOrCreate': connectOrCreate,
        if (create != null) r'create': create,
      });

  Input$BookRevisionCreateNestedOneWithoutBookEditedInput._(this._$data);

  factory Input$BookRevisionCreateNestedOneWithoutBookEditedInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('connect')) {
      final l$connect = data['connect'];
      result$data['connect'] = l$connect == null
          ? null
          : Input$BookRevisionWhereUniqueInput.fromJson(
              (l$connect as Map<String, dynamic>));
    }
    if (data.containsKey('connectOrCreate')) {
      final l$connectOrCreate = data['connectOrCreate'];
      result$data['connectOrCreate'] = l$connectOrCreate == null
          ? null
          : Input$BookRevisionCreateOrConnectWithoutBookEditedInput.fromJson(
              (l$connectOrCreate as Map<String, dynamic>));
    }
    if (data.containsKey('create')) {
      final l$create = data['create'];
      result$data['create'] = l$create == null
          ? null
          : Input$BookRevisionCreateWithoutBookEditedInput.fromJson(
              (l$create as Map<String, dynamic>));
    }
    return Input$BookRevisionCreateNestedOneWithoutBookEditedInput._(
        result$data);
  }

  Map<String, dynamic> _$data;

  Input$BookRevisionWhereUniqueInput? get connect =>
      (_$data['connect'] as Input$BookRevisionWhereUniqueInput?);

  Input$BookRevisionCreateOrConnectWithoutBookEditedInput?
      get connectOrCreate => (_$data['connectOrCreate']
          as Input$BookRevisionCreateOrConnectWithoutBookEditedInput?);

  Input$BookRevisionCreateWithoutBookEditedInput? get create =>
      (_$data['create'] as Input$BookRevisionCreateWithoutBookEditedInput?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('connect')) {
      final l$connect = connect;
      result$data['connect'] = l$connect?.toJson();
    }
    if (_$data.containsKey('connectOrCreate')) {
      final l$connectOrCreate = connectOrCreate;
      result$data['connectOrCreate'] = l$connectOrCreate?.toJson();
    }
    if (_$data.containsKey('create')) {
      final l$create = create;
      result$data['create'] = l$create?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$BookRevisionCreateNestedOneWithoutBookEditedInput<
          Input$BookRevisionCreateNestedOneWithoutBookEditedInput>
      get copyWith =>
          CopyWith$Input$BookRevisionCreateNestedOneWithoutBookEditedInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$BookRevisionCreateNestedOneWithoutBookEditedInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$connect = connect;
    final lOther$connect = other.connect;
    if (_$data.containsKey('connect') != other._$data.containsKey('connect')) {
      return false;
    }
    if (l$connect != lOther$connect) {
      return false;
    }
    final l$connectOrCreate = connectOrCreate;
    final lOther$connectOrCreate = other.connectOrCreate;
    if (_$data.containsKey('connectOrCreate') !=
        other._$data.containsKey('connectOrCreate')) {
      return false;
    }
    if (l$connectOrCreate != lOther$connectOrCreate) {
      return false;
    }
    final l$create = create;
    final lOther$create = other.create;
    if (_$data.containsKey('create') != other._$data.containsKey('create')) {
      return false;
    }
    if (l$create != lOther$create) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$connect = connect;
    final l$connectOrCreate = connectOrCreate;
    final l$create = create;
    return Object.hashAll([
      _$data.containsKey('connect') ? l$connect : const {},
      _$data.containsKey('connectOrCreate') ? l$connectOrCreate : const {},
      _$data.containsKey('create') ? l$create : const {},
    ]);
  }
}

abstract class CopyWith$Input$BookRevisionCreateNestedOneWithoutBookEditedInput<
    TRes> {
  factory CopyWith$Input$BookRevisionCreateNestedOneWithoutBookEditedInput(
    Input$BookRevisionCreateNestedOneWithoutBookEditedInput instance,
    TRes Function(Input$BookRevisionCreateNestedOneWithoutBookEditedInput) then,
  ) = _CopyWithImpl$Input$BookRevisionCreateNestedOneWithoutBookEditedInput;

  factory CopyWith$Input$BookRevisionCreateNestedOneWithoutBookEditedInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$BookRevisionCreateNestedOneWithoutBookEditedInput;

  TRes call({
    Input$BookRevisionWhereUniqueInput? connect,
    Input$BookRevisionCreateOrConnectWithoutBookEditedInput? connectOrCreate,
    Input$BookRevisionCreateWithoutBookEditedInput? create,
  });
  CopyWith$Input$BookRevisionWhereUniqueInput<TRes> get connect;
  CopyWith$Input$BookRevisionCreateOrConnectWithoutBookEditedInput<TRes>
      get connectOrCreate;
  CopyWith$Input$BookRevisionCreateWithoutBookEditedInput<TRes> get create;
}

class _CopyWithImpl$Input$BookRevisionCreateNestedOneWithoutBookEditedInput<
        TRes>
    implements
        CopyWith$Input$BookRevisionCreateNestedOneWithoutBookEditedInput<TRes> {
  _CopyWithImpl$Input$BookRevisionCreateNestedOneWithoutBookEditedInput(
    this._instance,
    this._then,
  );

  final Input$BookRevisionCreateNestedOneWithoutBookEditedInput _instance;

  final TRes Function(Input$BookRevisionCreateNestedOneWithoutBookEditedInput)
      _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? connect = _undefined,
    Object? connectOrCreate = _undefined,
    Object? create = _undefined,
  }) =>
      _then(Input$BookRevisionCreateNestedOneWithoutBookEditedInput._({
        ..._instance._$data,
        if (connect != _undefined)
          'connect': (connect as Input$BookRevisionWhereUniqueInput?),
        if (connectOrCreate != _undefined)
          'connectOrCreate': (connectOrCreate
              as Input$BookRevisionCreateOrConnectWithoutBookEditedInput?),
        if (create != _undefined)
          'create': (create as Input$BookRevisionCreateWithoutBookEditedInput?),
      }));

  CopyWith$Input$BookRevisionWhereUniqueInput<TRes> get connect {
    final local$connect = _instance.connect;
    return local$connect == null
        ? CopyWith$Input$BookRevisionWhereUniqueInput.stub(_then(_instance))
        : CopyWith$Input$BookRevisionWhereUniqueInput(
            local$connect, (e) => call(connect: e));
  }

  CopyWith$Input$BookRevisionCreateOrConnectWithoutBookEditedInput<TRes>
      get connectOrCreate {
    final local$connectOrCreate = _instance.connectOrCreate;
    return local$connectOrCreate == null
        ? CopyWith$Input$BookRevisionCreateOrConnectWithoutBookEditedInput.stub(
            _then(_instance))
        : CopyWith$Input$BookRevisionCreateOrConnectWithoutBookEditedInput(
            local$connectOrCreate, (e) => call(connectOrCreate: e));
  }

  CopyWith$Input$BookRevisionCreateWithoutBookEditedInput<TRes> get create {
    final local$create = _instance.create;
    return local$create == null
        ? CopyWith$Input$BookRevisionCreateWithoutBookEditedInput.stub(
            _then(_instance))
        : CopyWith$Input$BookRevisionCreateWithoutBookEditedInput(
            local$create, (e) => call(create: e));
  }
}

class _CopyWithStubImpl$Input$BookRevisionCreateNestedOneWithoutBookEditedInput<
        TRes>
    implements
        CopyWith$Input$BookRevisionCreateNestedOneWithoutBookEditedInput<TRes> {
  _CopyWithStubImpl$Input$BookRevisionCreateNestedOneWithoutBookEditedInput(
      this._res);

  TRes _res;

  call({
    Input$BookRevisionWhereUniqueInput? connect,
    Input$BookRevisionCreateOrConnectWithoutBookEditedInput? connectOrCreate,
    Input$BookRevisionCreateWithoutBookEditedInput? create,
  }) =>
      _res;

  CopyWith$Input$BookRevisionWhereUniqueInput<TRes> get connect =>
      CopyWith$Input$BookRevisionWhereUniqueInput.stub(_res);

  CopyWith$Input$BookRevisionCreateOrConnectWithoutBookEditedInput<TRes>
      get connectOrCreate =>
          CopyWith$Input$BookRevisionCreateOrConnectWithoutBookEditedInput.stub(
              _res);

  CopyWith$Input$BookRevisionCreateWithoutBookEditedInput<TRes> get create =>
      CopyWith$Input$BookRevisionCreateWithoutBookEditedInput.stub(_res);
}

class Input$BookRevisionCreateNestedOneWithoutBookRawInput {
  factory Input$BookRevisionCreateNestedOneWithoutBookRawInput({
    Input$BookRevisionWhereUniqueInput? connect,
    Input$BookRevisionCreateOrConnectWithoutBookRawInput? connectOrCreate,
    Input$BookRevisionCreateWithoutBookRawInput? create,
  }) =>
      Input$BookRevisionCreateNestedOneWithoutBookRawInput._({
        if (connect != null) r'connect': connect,
        if (connectOrCreate != null) r'connectOrCreate': connectOrCreate,
        if (create != null) r'create': create,
      });

  Input$BookRevisionCreateNestedOneWithoutBookRawInput._(this._$data);

  factory Input$BookRevisionCreateNestedOneWithoutBookRawInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('connect')) {
      final l$connect = data['connect'];
      result$data['connect'] = l$connect == null
          ? null
          : Input$BookRevisionWhereUniqueInput.fromJson(
              (l$connect as Map<String, dynamic>));
    }
    if (data.containsKey('connectOrCreate')) {
      final l$connectOrCreate = data['connectOrCreate'];
      result$data['connectOrCreate'] = l$connectOrCreate == null
          ? null
          : Input$BookRevisionCreateOrConnectWithoutBookRawInput.fromJson(
              (l$connectOrCreate as Map<String, dynamic>));
    }
    if (data.containsKey('create')) {
      final l$create = data['create'];
      result$data['create'] = l$create == null
          ? null
          : Input$BookRevisionCreateWithoutBookRawInput.fromJson(
              (l$create as Map<String, dynamic>));
    }
    return Input$BookRevisionCreateNestedOneWithoutBookRawInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$BookRevisionWhereUniqueInput? get connect =>
      (_$data['connect'] as Input$BookRevisionWhereUniqueInput?);

  Input$BookRevisionCreateOrConnectWithoutBookRawInput? get connectOrCreate =>
      (_$data['connectOrCreate']
          as Input$BookRevisionCreateOrConnectWithoutBookRawInput?);

  Input$BookRevisionCreateWithoutBookRawInput? get create =>
      (_$data['create'] as Input$BookRevisionCreateWithoutBookRawInput?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('connect')) {
      final l$connect = connect;
      result$data['connect'] = l$connect?.toJson();
    }
    if (_$data.containsKey('connectOrCreate')) {
      final l$connectOrCreate = connectOrCreate;
      result$data['connectOrCreate'] = l$connectOrCreate?.toJson();
    }
    if (_$data.containsKey('create')) {
      final l$create = create;
      result$data['create'] = l$create?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$BookRevisionCreateNestedOneWithoutBookRawInput<
          Input$BookRevisionCreateNestedOneWithoutBookRawInput>
      get copyWith =>
          CopyWith$Input$BookRevisionCreateNestedOneWithoutBookRawInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$BookRevisionCreateNestedOneWithoutBookRawInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$connect = connect;
    final lOther$connect = other.connect;
    if (_$data.containsKey('connect') != other._$data.containsKey('connect')) {
      return false;
    }
    if (l$connect != lOther$connect) {
      return false;
    }
    final l$connectOrCreate = connectOrCreate;
    final lOther$connectOrCreate = other.connectOrCreate;
    if (_$data.containsKey('connectOrCreate') !=
        other._$data.containsKey('connectOrCreate')) {
      return false;
    }
    if (l$connectOrCreate != lOther$connectOrCreate) {
      return false;
    }
    final l$create = create;
    final lOther$create = other.create;
    if (_$data.containsKey('create') != other._$data.containsKey('create')) {
      return false;
    }
    if (l$create != lOther$create) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$connect = connect;
    final l$connectOrCreate = connectOrCreate;
    final l$create = create;
    return Object.hashAll([
      _$data.containsKey('connect') ? l$connect : const {},
      _$data.containsKey('connectOrCreate') ? l$connectOrCreate : const {},
      _$data.containsKey('create') ? l$create : const {},
    ]);
  }
}

abstract class CopyWith$Input$BookRevisionCreateNestedOneWithoutBookRawInput<
    TRes> {
  factory CopyWith$Input$BookRevisionCreateNestedOneWithoutBookRawInput(
    Input$BookRevisionCreateNestedOneWithoutBookRawInput instance,
    TRes Function(Input$BookRevisionCreateNestedOneWithoutBookRawInput) then,
  ) = _CopyWithImpl$Input$BookRevisionCreateNestedOneWithoutBookRawInput;

  factory CopyWith$Input$BookRevisionCreateNestedOneWithoutBookRawInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$BookRevisionCreateNestedOneWithoutBookRawInput;

  TRes call({
    Input$BookRevisionWhereUniqueInput? connect,
    Input$BookRevisionCreateOrConnectWithoutBookRawInput? connectOrCreate,
    Input$BookRevisionCreateWithoutBookRawInput? create,
  });
  CopyWith$Input$BookRevisionWhereUniqueInput<TRes> get connect;
  CopyWith$Input$BookRevisionCreateOrConnectWithoutBookRawInput<TRes>
      get connectOrCreate;
  CopyWith$Input$BookRevisionCreateWithoutBookRawInput<TRes> get create;
}

class _CopyWithImpl$Input$BookRevisionCreateNestedOneWithoutBookRawInput<TRes>
    implements
        CopyWith$Input$BookRevisionCreateNestedOneWithoutBookRawInput<TRes> {
  _CopyWithImpl$Input$BookRevisionCreateNestedOneWithoutBookRawInput(
    this._instance,
    this._then,
  );

  final Input$BookRevisionCreateNestedOneWithoutBookRawInput _instance;

  final TRes Function(Input$BookRevisionCreateNestedOneWithoutBookRawInput)
      _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? connect = _undefined,
    Object? connectOrCreate = _undefined,
    Object? create = _undefined,
  }) =>
      _then(Input$BookRevisionCreateNestedOneWithoutBookRawInput._({
        ..._instance._$data,
        if (connect != _undefined)
          'connect': (connect as Input$BookRevisionWhereUniqueInput?),
        if (connectOrCreate != _undefined)
          'connectOrCreate': (connectOrCreate
              as Input$BookRevisionCreateOrConnectWithoutBookRawInput?),
        if (create != _undefined)
          'create': (create as Input$BookRevisionCreateWithoutBookRawInput?),
      }));

  CopyWith$Input$BookRevisionWhereUniqueInput<TRes> get connect {
    final local$connect = _instance.connect;
    return local$connect == null
        ? CopyWith$Input$BookRevisionWhereUniqueInput.stub(_then(_instance))
        : CopyWith$Input$BookRevisionWhereUniqueInput(
            local$connect, (e) => call(connect: e));
  }

  CopyWith$Input$BookRevisionCreateOrConnectWithoutBookRawInput<TRes>
      get connectOrCreate {
    final local$connectOrCreate = _instance.connectOrCreate;
    return local$connectOrCreate == null
        ? CopyWith$Input$BookRevisionCreateOrConnectWithoutBookRawInput.stub(
            _then(_instance))
        : CopyWith$Input$BookRevisionCreateOrConnectWithoutBookRawInput(
            local$connectOrCreate, (e) => call(connectOrCreate: e));
  }

  CopyWith$Input$BookRevisionCreateWithoutBookRawInput<TRes> get create {
    final local$create = _instance.create;
    return local$create == null
        ? CopyWith$Input$BookRevisionCreateWithoutBookRawInput.stub(
            _then(_instance))
        : CopyWith$Input$BookRevisionCreateWithoutBookRawInput(
            local$create, (e) => call(create: e));
  }
}

class _CopyWithStubImpl$Input$BookRevisionCreateNestedOneWithoutBookRawInput<
        TRes>
    implements
        CopyWith$Input$BookRevisionCreateNestedOneWithoutBookRawInput<TRes> {
  _CopyWithStubImpl$Input$BookRevisionCreateNestedOneWithoutBookRawInput(
      this._res);

  TRes _res;

  call({
    Input$BookRevisionWhereUniqueInput? connect,
    Input$BookRevisionCreateOrConnectWithoutBookRawInput? connectOrCreate,
    Input$BookRevisionCreateWithoutBookRawInput? create,
  }) =>
      _res;

  CopyWith$Input$BookRevisionWhereUniqueInput<TRes> get connect =>
      CopyWith$Input$BookRevisionWhereUniqueInput.stub(_res);

  CopyWith$Input$BookRevisionCreateOrConnectWithoutBookRawInput<TRes>
      get connectOrCreate =>
          CopyWith$Input$BookRevisionCreateOrConnectWithoutBookRawInput.stub(
              _res);

  CopyWith$Input$BookRevisionCreateWithoutBookRawInput<TRes> get create =>
      CopyWith$Input$BookRevisionCreateWithoutBookRawInput.stub(_res);
}

class Input$BookRevisionCreateOrConnectWithoutBookEditedInput {
  factory Input$BookRevisionCreateOrConnectWithoutBookEditedInput({
    required Input$BookRevisionCreateWithoutBookEditedInput create,
    required Input$BookRevisionWhereUniqueInput where,
  }) =>
      Input$BookRevisionCreateOrConnectWithoutBookEditedInput._({
        r'create': create,
        r'where': where,
      });

  Input$BookRevisionCreateOrConnectWithoutBookEditedInput._(this._$data);

  factory Input$BookRevisionCreateOrConnectWithoutBookEditedInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$create = data['create'];
    result$data['create'] =
        Input$BookRevisionCreateWithoutBookEditedInput.fromJson(
            (l$create as Map<String, dynamic>));
    final l$where = data['where'];
    result$data['where'] = Input$BookRevisionWhereUniqueInput.fromJson(
        (l$where as Map<String, dynamic>));
    return Input$BookRevisionCreateOrConnectWithoutBookEditedInput._(
        result$data);
  }

  Map<String, dynamic> _$data;

  Input$BookRevisionCreateWithoutBookEditedInput get create =>
      (_$data['create'] as Input$BookRevisionCreateWithoutBookEditedInput);

  Input$BookRevisionWhereUniqueInput get where =>
      (_$data['where'] as Input$BookRevisionWhereUniqueInput);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$create = create;
    result$data['create'] = l$create.toJson();
    final l$where = where;
    result$data['where'] = l$where.toJson();
    return result$data;
  }

  CopyWith$Input$BookRevisionCreateOrConnectWithoutBookEditedInput<
          Input$BookRevisionCreateOrConnectWithoutBookEditedInput>
      get copyWith =>
          CopyWith$Input$BookRevisionCreateOrConnectWithoutBookEditedInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$BookRevisionCreateOrConnectWithoutBookEditedInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != lOther$create) {
      return false;
    }
    final l$where = where;
    final lOther$where = other.where;
    if (l$where != lOther$where) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$create = create;
    final l$where = where;
    return Object.hashAll([
      l$create,
      l$where,
    ]);
  }
}

abstract class CopyWith$Input$BookRevisionCreateOrConnectWithoutBookEditedInput<
    TRes> {
  factory CopyWith$Input$BookRevisionCreateOrConnectWithoutBookEditedInput(
    Input$BookRevisionCreateOrConnectWithoutBookEditedInput instance,
    TRes Function(Input$BookRevisionCreateOrConnectWithoutBookEditedInput) then,
  ) = _CopyWithImpl$Input$BookRevisionCreateOrConnectWithoutBookEditedInput;

  factory CopyWith$Input$BookRevisionCreateOrConnectWithoutBookEditedInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$BookRevisionCreateOrConnectWithoutBookEditedInput;

  TRes call({
    Input$BookRevisionCreateWithoutBookEditedInput? create,
    Input$BookRevisionWhereUniqueInput? where,
  });
  CopyWith$Input$BookRevisionCreateWithoutBookEditedInput<TRes> get create;
  CopyWith$Input$BookRevisionWhereUniqueInput<TRes> get where;
}

class _CopyWithImpl$Input$BookRevisionCreateOrConnectWithoutBookEditedInput<
        TRes>
    implements
        CopyWith$Input$BookRevisionCreateOrConnectWithoutBookEditedInput<TRes> {
  _CopyWithImpl$Input$BookRevisionCreateOrConnectWithoutBookEditedInput(
    this._instance,
    this._then,
  );

  final Input$BookRevisionCreateOrConnectWithoutBookEditedInput _instance;

  final TRes Function(Input$BookRevisionCreateOrConnectWithoutBookEditedInput)
      _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? create = _undefined,
    Object? where = _undefined,
  }) =>
      _then(Input$BookRevisionCreateOrConnectWithoutBookEditedInput._({
        ..._instance._$data,
        if (create != _undefined && create != null)
          'create': (create as Input$BookRevisionCreateWithoutBookEditedInput),
        if (where != _undefined && where != null)
          'where': (where as Input$BookRevisionWhereUniqueInput),
      }));

  CopyWith$Input$BookRevisionCreateWithoutBookEditedInput<TRes> get create {
    final local$create = _instance.create;
    return CopyWith$Input$BookRevisionCreateWithoutBookEditedInput(
        local$create, (e) => call(create: e));
  }

  CopyWith$Input$BookRevisionWhereUniqueInput<TRes> get where {
    final local$where = _instance.where;
    return CopyWith$Input$BookRevisionWhereUniqueInput(
        local$where, (e) => call(where: e));
  }
}

class _CopyWithStubImpl$Input$BookRevisionCreateOrConnectWithoutBookEditedInput<
        TRes>
    implements
        CopyWith$Input$BookRevisionCreateOrConnectWithoutBookEditedInput<TRes> {
  _CopyWithStubImpl$Input$BookRevisionCreateOrConnectWithoutBookEditedInput(
      this._res);

  TRes _res;

  call({
    Input$BookRevisionCreateWithoutBookEditedInput? create,
    Input$BookRevisionWhereUniqueInput? where,
  }) =>
      _res;

  CopyWith$Input$BookRevisionCreateWithoutBookEditedInput<TRes> get create =>
      CopyWith$Input$BookRevisionCreateWithoutBookEditedInput.stub(_res);

  CopyWith$Input$BookRevisionWhereUniqueInput<TRes> get where =>
      CopyWith$Input$BookRevisionWhereUniqueInput.stub(_res);
}

class Input$BookRevisionCreateOrConnectWithoutBookRawInput {
  factory Input$BookRevisionCreateOrConnectWithoutBookRawInput({
    required Input$BookRevisionCreateWithoutBookRawInput create,
    required Input$BookRevisionWhereUniqueInput where,
  }) =>
      Input$BookRevisionCreateOrConnectWithoutBookRawInput._({
        r'create': create,
        r'where': where,
      });

  Input$BookRevisionCreateOrConnectWithoutBookRawInput._(this._$data);

  factory Input$BookRevisionCreateOrConnectWithoutBookRawInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$create = data['create'];
    result$data['create'] =
        Input$BookRevisionCreateWithoutBookRawInput.fromJson(
            (l$create as Map<String, dynamic>));
    final l$where = data['where'];
    result$data['where'] = Input$BookRevisionWhereUniqueInput.fromJson(
        (l$where as Map<String, dynamic>));
    return Input$BookRevisionCreateOrConnectWithoutBookRawInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$BookRevisionCreateWithoutBookRawInput get create =>
      (_$data['create'] as Input$BookRevisionCreateWithoutBookRawInput);

  Input$BookRevisionWhereUniqueInput get where =>
      (_$data['where'] as Input$BookRevisionWhereUniqueInput);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$create = create;
    result$data['create'] = l$create.toJson();
    final l$where = where;
    result$data['where'] = l$where.toJson();
    return result$data;
  }

  CopyWith$Input$BookRevisionCreateOrConnectWithoutBookRawInput<
          Input$BookRevisionCreateOrConnectWithoutBookRawInput>
      get copyWith =>
          CopyWith$Input$BookRevisionCreateOrConnectWithoutBookRawInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$BookRevisionCreateOrConnectWithoutBookRawInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != lOther$create) {
      return false;
    }
    final l$where = where;
    final lOther$where = other.where;
    if (l$where != lOther$where) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$create = create;
    final l$where = where;
    return Object.hashAll([
      l$create,
      l$where,
    ]);
  }
}

abstract class CopyWith$Input$BookRevisionCreateOrConnectWithoutBookRawInput<
    TRes> {
  factory CopyWith$Input$BookRevisionCreateOrConnectWithoutBookRawInput(
    Input$BookRevisionCreateOrConnectWithoutBookRawInput instance,
    TRes Function(Input$BookRevisionCreateOrConnectWithoutBookRawInput) then,
  ) = _CopyWithImpl$Input$BookRevisionCreateOrConnectWithoutBookRawInput;

  factory CopyWith$Input$BookRevisionCreateOrConnectWithoutBookRawInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$BookRevisionCreateOrConnectWithoutBookRawInput;

  TRes call({
    Input$BookRevisionCreateWithoutBookRawInput? create,
    Input$BookRevisionWhereUniqueInput? where,
  });
  CopyWith$Input$BookRevisionCreateWithoutBookRawInput<TRes> get create;
  CopyWith$Input$BookRevisionWhereUniqueInput<TRes> get where;
}

class _CopyWithImpl$Input$BookRevisionCreateOrConnectWithoutBookRawInput<TRes>
    implements
        CopyWith$Input$BookRevisionCreateOrConnectWithoutBookRawInput<TRes> {
  _CopyWithImpl$Input$BookRevisionCreateOrConnectWithoutBookRawInput(
    this._instance,
    this._then,
  );

  final Input$BookRevisionCreateOrConnectWithoutBookRawInput _instance;

  final TRes Function(Input$BookRevisionCreateOrConnectWithoutBookRawInput)
      _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? create = _undefined,
    Object? where = _undefined,
  }) =>
      _then(Input$BookRevisionCreateOrConnectWithoutBookRawInput._({
        ..._instance._$data,
        if (create != _undefined && create != null)
          'create': (create as Input$BookRevisionCreateWithoutBookRawInput),
        if (where != _undefined && where != null)
          'where': (where as Input$BookRevisionWhereUniqueInput),
      }));

  CopyWith$Input$BookRevisionCreateWithoutBookRawInput<TRes> get create {
    final local$create = _instance.create;
    return CopyWith$Input$BookRevisionCreateWithoutBookRawInput(
        local$create, (e) => call(create: e));
  }

  CopyWith$Input$BookRevisionWhereUniqueInput<TRes> get where {
    final local$where = _instance.where;
    return CopyWith$Input$BookRevisionWhereUniqueInput(
        local$where, (e) => call(where: e));
  }
}

class _CopyWithStubImpl$Input$BookRevisionCreateOrConnectWithoutBookRawInput<
        TRes>
    implements
        CopyWith$Input$BookRevisionCreateOrConnectWithoutBookRawInput<TRes> {
  _CopyWithStubImpl$Input$BookRevisionCreateOrConnectWithoutBookRawInput(
      this._res);

  TRes _res;

  call({
    Input$BookRevisionCreateWithoutBookRawInput? create,
    Input$BookRevisionWhereUniqueInput? where,
  }) =>
      _res;

  CopyWith$Input$BookRevisionCreateWithoutBookRawInput<TRes> get create =>
      CopyWith$Input$BookRevisionCreateWithoutBookRawInput.stub(_res);

  CopyWith$Input$BookRevisionWhereUniqueInput<TRes> get where =>
      CopyWith$Input$BookRevisionWhereUniqueInput.stub(_res);
}

class Input$BookRevisionCreateWithoutBookEditedInput {
  factory Input$BookRevisionCreateWithoutBookEditedInput({
    Input$BookCreateNestedOneWithoutBookRawInput? bookRaw,
    int? completionTokens,
    Input$BookRevisionCreatecontentInput? content,
    String? createdAt,
    bool? isRaw,
    String? model,
    int? promptTokens,
    String? raw,
    String? requestId,
    String? systemPrompt,
    int? totalTokens,
    String? updatedAt,
    String? userPrompt,
    String? uuid,
  }) =>
      Input$BookRevisionCreateWithoutBookEditedInput._({
        if (bookRaw != null) r'bookRaw': bookRaw,
        if (completionTokens != null) r'completionTokens': completionTokens,
        if (content != null) r'content': content,
        if (createdAt != null) r'createdAt': createdAt,
        if (isRaw != null) r'isRaw': isRaw,
        if (model != null) r'model': model,
        if (promptTokens != null) r'promptTokens': promptTokens,
        if (raw != null) r'raw': raw,
        if (requestId != null) r'requestId': requestId,
        if (systemPrompt != null) r'systemPrompt': systemPrompt,
        if (totalTokens != null) r'totalTokens': totalTokens,
        if (updatedAt != null) r'updatedAt': updatedAt,
        if (userPrompt != null) r'userPrompt': userPrompt,
        if (uuid != null) r'uuid': uuid,
      });

  Input$BookRevisionCreateWithoutBookEditedInput._(this._$data);

  factory Input$BookRevisionCreateWithoutBookEditedInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('bookRaw')) {
      final l$bookRaw = data['bookRaw'];
      result$data['bookRaw'] = l$bookRaw == null
          ? null
          : Input$BookCreateNestedOneWithoutBookRawInput.fromJson(
              (l$bookRaw as Map<String, dynamic>));
    }
    if (data.containsKey('completionTokens')) {
      final l$completionTokens = data['completionTokens'];
      result$data['completionTokens'] = (l$completionTokens as int?);
    }
    if (data.containsKey('content')) {
      final l$content = data['content'];
      result$data['content'] = l$content == null
          ? null
          : Input$BookRevisionCreatecontentInput.fromJson(
              (l$content as Map<String, dynamic>));
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = (l$createdAt as String?);
    }
    if (data.containsKey('isRaw')) {
      final l$isRaw = data['isRaw'];
      result$data['isRaw'] = (l$isRaw as bool?);
    }
    if (data.containsKey('model')) {
      final l$model = data['model'];
      result$data['model'] = (l$model as String?);
    }
    if (data.containsKey('promptTokens')) {
      final l$promptTokens = data['promptTokens'];
      result$data['promptTokens'] = (l$promptTokens as int?);
    }
    if (data.containsKey('raw')) {
      final l$raw = data['raw'];
      result$data['raw'] = (l$raw as String?);
    }
    if (data.containsKey('requestId')) {
      final l$requestId = data['requestId'];
      result$data['requestId'] = (l$requestId as String?);
    }
    if (data.containsKey('systemPrompt')) {
      final l$systemPrompt = data['systemPrompt'];
      result$data['systemPrompt'] = (l$systemPrompt as String?);
    }
    if (data.containsKey('totalTokens')) {
      final l$totalTokens = data['totalTokens'];
      result$data['totalTokens'] = (l$totalTokens as int?);
    }
    if (data.containsKey('updatedAt')) {
      final l$updatedAt = data['updatedAt'];
      result$data['updatedAt'] = (l$updatedAt as String?);
    }
    if (data.containsKey('userPrompt')) {
      final l$userPrompt = data['userPrompt'];
      result$data['userPrompt'] = (l$userPrompt as String?);
    }
    if (data.containsKey('uuid')) {
      final l$uuid = data['uuid'];
      result$data['uuid'] = (l$uuid as String?);
    }
    return Input$BookRevisionCreateWithoutBookEditedInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$BookCreateNestedOneWithoutBookRawInput? get bookRaw =>
      (_$data['bookRaw'] as Input$BookCreateNestedOneWithoutBookRawInput?);

  int? get completionTokens => (_$data['completionTokens'] as int?);

  Input$BookRevisionCreatecontentInput? get content =>
      (_$data['content'] as Input$BookRevisionCreatecontentInput?);

  String? get createdAt => (_$data['createdAt'] as String?);

  bool? get isRaw => (_$data['isRaw'] as bool?);

  String? get model => (_$data['model'] as String?);

  int? get promptTokens => (_$data['promptTokens'] as int?);

  String? get raw => (_$data['raw'] as String?);

  String? get requestId => (_$data['requestId'] as String?);

  String? get systemPrompt => (_$data['systemPrompt'] as String?);

  int? get totalTokens => (_$data['totalTokens'] as int?);

  String? get updatedAt => (_$data['updatedAt'] as String?);

  String? get userPrompt => (_$data['userPrompt'] as String?);

  String? get uuid => (_$data['uuid'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('bookRaw')) {
      final l$bookRaw = bookRaw;
      result$data['bookRaw'] = l$bookRaw?.toJson();
    }
    if (_$data.containsKey('completionTokens')) {
      final l$completionTokens = completionTokens;
      result$data['completionTokens'] = l$completionTokens;
    }
    if (_$data.containsKey('content')) {
      final l$content = content;
      result$data['content'] = l$content?.toJson();
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt;
    }
    if (_$data.containsKey('isRaw')) {
      final l$isRaw = isRaw;
      result$data['isRaw'] = l$isRaw;
    }
    if (_$data.containsKey('model')) {
      final l$model = model;
      result$data['model'] = l$model;
    }
    if (_$data.containsKey('promptTokens')) {
      final l$promptTokens = promptTokens;
      result$data['promptTokens'] = l$promptTokens;
    }
    if (_$data.containsKey('raw')) {
      final l$raw = raw;
      result$data['raw'] = l$raw;
    }
    if (_$data.containsKey('requestId')) {
      final l$requestId = requestId;
      result$data['requestId'] = l$requestId;
    }
    if (_$data.containsKey('systemPrompt')) {
      final l$systemPrompt = systemPrompt;
      result$data['systemPrompt'] = l$systemPrompt;
    }
    if (_$data.containsKey('totalTokens')) {
      final l$totalTokens = totalTokens;
      result$data['totalTokens'] = l$totalTokens;
    }
    if (_$data.containsKey('updatedAt')) {
      final l$updatedAt = updatedAt;
      result$data['updatedAt'] = l$updatedAt;
    }
    if (_$data.containsKey('userPrompt')) {
      final l$userPrompt = userPrompt;
      result$data['userPrompt'] = l$userPrompt;
    }
    if (_$data.containsKey('uuid')) {
      final l$uuid = uuid;
      result$data['uuid'] = l$uuid;
    }
    return result$data;
  }

  CopyWith$Input$BookRevisionCreateWithoutBookEditedInput<
          Input$BookRevisionCreateWithoutBookEditedInput>
      get copyWith => CopyWith$Input$BookRevisionCreateWithoutBookEditedInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$BookRevisionCreateWithoutBookEditedInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$bookRaw = bookRaw;
    final lOther$bookRaw = other.bookRaw;
    if (_$data.containsKey('bookRaw') != other._$data.containsKey('bookRaw')) {
      return false;
    }
    if (l$bookRaw != lOther$bookRaw) {
      return false;
    }
    final l$completionTokens = completionTokens;
    final lOther$completionTokens = other.completionTokens;
    if (_$data.containsKey('completionTokens') !=
        other._$data.containsKey('completionTokens')) {
      return false;
    }
    if (l$completionTokens != lOther$completionTokens) {
      return false;
    }
    final l$content = content;
    final lOther$content = other.content;
    if (_$data.containsKey('content') != other._$data.containsKey('content')) {
      return false;
    }
    if (l$content != lOther$content) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$isRaw = isRaw;
    final lOther$isRaw = other.isRaw;
    if (_$data.containsKey('isRaw') != other._$data.containsKey('isRaw')) {
      return false;
    }
    if (l$isRaw != lOther$isRaw) {
      return false;
    }
    final l$model = model;
    final lOther$model = other.model;
    if (_$data.containsKey('model') != other._$data.containsKey('model')) {
      return false;
    }
    if (l$model != lOther$model) {
      return false;
    }
    final l$promptTokens = promptTokens;
    final lOther$promptTokens = other.promptTokens;
    if (_$data.containsKey('promptTokens') !=
        other._$data.containsKey('promptTokens')) {
      return false;
    }
    if (l$promptTokens != lOther$promptTokens) {
      return false;
    }
    final l$raw = raw;
    final lOther$raw = other.raw;
    if (_$data.containsKey('raw') != other._$data.containsKey('raw')) {
      return false;
    }
    if (l$raw != lOther$raw) {
      return false;
    }
    final l$requestId = requestId;
    final lOther$requestId = other.requestId;
    if (_$data.containsKey('requestId') !=
        other._$data.containsKey('requestId')) {
      return false;
    }
    if (l$requestId != lOther$requestId) {
      return false;
    }
    final l$systemPrompt = systemPrompt;
    final lOther$systemPrompt = other.systemPrompt;
    if (_$data.containsKey('systemPrompt') !=
        other._$data.containsKey('systemPrompt')) {
      return false;
    }
    if (l$systemPrompt != lOther$systemPrompt) {
      return false;
    }
    final l$totalTokens = totalTokens;
    final lOther$totalTokens = other.totalTokens;
    if (_$data.containsKey('totalTokens') !=
        other._$data.containsKey('totalTokens')) {
      return false;
    }
    if (l$totalTokens != lOther$totalTokens) {
      return false;
    }
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (_$data.containsKey('updatedAt') !=
        other._$data.containsKey('updatedAt')) {
      return false;
    }
    if (l$updatedAt != lOther$updatedAt) {
      return false;
    }
    final l$userPrompt = userPrompt;
    final lOther$userPrompt = other.userPrompt;
    if (_$data.containsKey('userPrompt') !=
        other._$data.containsKey('userPrompt')) {
      return false;
    }
    if (l$userPrompt != lOther$userPrompt) {
      return false;
    }
    final l$uuid = uuid;
    final lOther$uuid = other.uuid;
    if (_$data.containsKey('uuid') != other._$data.containsKey('uuid')) {
      return false;
    }
    if (l$uuid != lOther$uuid) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$bookRaw = bookRaw;
    final l$completionTokens = completionTokens;
    final l$content = content;
    final l$createdAt = createdAt;
    final l$isRaw = isRaw;
    final l$model = model;
    final l$promptTokens = promptTokens;
    final l$raw = raw;
    final l$requestId = requestId;
    final l$systemPrompt = systemPrompt;
    final l$totalTokens = totalTokens;
    final l$updatedAt = updatedAt;
    final l$userPrompt = userPrompt;
    final l$uuid = uuid;
    return Object.hashAll([
      _$data.containsKey('bookRaw') ? l$bookRaw : const {},
      _$data.containsKey('completionTokens') ? l$completionTokens : const {},
      _$data.containsKey('content') ? l$content : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('isRaw') ? l$isRaw : const {},
      _$data.containsKey('model') ? l$model : const {},
      _$data.containsKey('promptTokens') ? l$promptTokens : const {},
      _$data.containsKey('raw') ? l$raw : const {},
      _$data.containsKey('requestId') ? l$requestId : const {},
      _$data.containsKey('systemPrompt') ? l$systemPrompt : const {},
      _$data.containsKey('totalTokens') ? l$totalTokens : const {},
      _$data.containsKey('updatedAt') ? l$updatedAt : const {},
      _$data.containsKey('userPrompt') ? l$userPrompt : const {},
      _$data.containsKey('uuid') ? l$uuid : const {},
    ]);
  }
}

abstract class CopyWith$Input$BookRevisionCreateWithoutBookEditedInput<TRes> {
  factory CopyWith$Input$BookRevisionCreateWithoutBookEditedInput(
    Input$BookRevisionCreateWithoutBookEditedInput instance,
    TRes Function(Input$BookRevisionCreateWithoutBookEditedInput) then,
  ) = _CopyWithImpl$Input$BookRevisionCreateWithoutBookEditedInput;

  factory CopyWith$Input$BookRevisionCreateWithoutBookEditedInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$BookRevisionCreateWithoutBookEditedInput;

  TRes call({
    Input$BookCreateNestedOneWithoutBookRawInput? bookRaw,
    int? completionTokens,
    Input$BookRevisionCreatecontentInput? content,
    String? createdAt,
    bool? isRaw,
    String? model,
    int? promptTokens,
    String? raw,
    String? requestId,
    String? systemPrompt,
    int? totalTokens,
    String? updatedAt,
    String? userPrompt,
    String? uuid,
  });
  CopyWith$Input$BookCreateNestedOneWithoutBookRawInput<TRes> get bookRaw;
  CopyWith$Input$BookRevisionCreatecontentInput<TRes> get content;
}

class _CopyWithImpl$Input$BookRevisionCreateWithoutBookEditedInput<TRes>
    implements CopyWith$Input$BookRevisionCreateWithoutBookEditedInput<TRes> {
  _CopyWithImpl$Input$BookRevisionCreateWithoutBookEditedInput(
    this._instance,
    this._then,
  );

  final Input$BookRevisionCreateWithoutBookEditedInput _instance;

  final TRes Function(Input$BookRevisionCreateWithoutBookEditedInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? bookRaw = _undefined,
    Object? completionTokens = _undefined,
    Object? content = _undefined,
    Object? createdAt = _undefined,
    Object? isRaw = _undefined,
    Object? model = _undefined,
    Object? promptTokens = _undefined,
    Object? raw = _undefined,
    Object? requestId = _undefined,
    Object? systemPrompt = _undefined,
    Object? totalTokens = _undefined,
    Object? updatedAt = _undefined,
    Object? userPrompt = _undefined,
    Object? uuid = _undefined,
  }) =>
      _then(Input$BookRevisionCreateWithoutBookEditedInput._({
        ..._instance._$data,
        if (bookRaw != _undefined)
          'bookRaw': (bookRaw as Input$BookCreateNestedOneWithoutBookRawInput?),
        if (completionTokens != _undefined)
          'completionTokens': (completionTokens as int?),
        if (content != _undefined)
          'content': (content as Input$BookRevisionCreatecontentInput?),
        if (createdAt != _undefined) 'createdAt': (createdAt as String?),
        if (isRaw != _undefined) 'isRaw': (isRaw as bool?),
        if (model != _undefined) 'model': (model as String?),
        if (promptTokens != _undefined) 'promptTokens': (promptTokens as int?),
        if (raw != _undefined) 'raw': (raw as String?),
        if (requestId != _undefined) 'requestId': (requestId as String?),
        if (systemPrompt != _undefined)
          'systemPrompt': (systemPrompt as String?),
        if (totalTokens != _undefined) 'totalTokens': (totalTokens as int?),
        if (updatedAt != _undefined) 'updatedAt': (updatedAt as String?),
        if (userPrompt != _undefined) 'userPrompt': (userPrompt as String?),
        if (uuid != _undefined) 'uuid': (uuid as String?),
      }));

  CopyWith$Input$BookCreateNestedOneWithoutBookRawInput<TRes> get bookRaw {
    final local$bookRaw = _instance.bookRaw;
    return local$bookRaw == null
        ? CopyWith$Input$BookCreateNestedOneWithoutBookRawInput.stub(
            _then(_instance))
        : CopyWith$Input$BookCreateNestedOneWithoutBookRawInput(
            local$bookRaw, (e) => call(bookRaw: e));
  }

  CopyWith$Input$BookRevisionCreatecontentInput<TRes> get content {
    final local$content = _instance.content;
    return local$content == null
        ? CopyWith$Input$BookRevisionCreatecontentInput.stub(_then(_instance))
        : CopyWith$Input$BookRevisionCreatecontentInput(
            local$content, (e) => call(content: e));
  }
}

class _CopyWithStubImpl$Input$BookRevisionCreateWithoutBookEditedInput<TRes>
    implements CopyWith$Input$BookRevisionCreateWithoutBookEditedInput<TRes> {
  _CopyWithStubImpl$Input$BookRevisionCreateWithoutBookEditedInput(this._res);

  TRes _res;

  call({
    Input$BookCreateNestedOneWithoutBookRawInput? bookRaw,
    int? completionTokens,
    Input$BookRevisionCreatecontentInput? content,
    String? createdAt,
    bool? isRaw,
    String? model,
    int? promptTokens,
    String? raw,
    String? requestId,
    String? systemPrompt,
    int? totalTokens,
    String? updatedAt,
    String? userPrompt,
    String? uuid,
  }) =>
      _res;

  CopyWith$Input$BookCreateNestedOneWithoutBookRawInput<TRes> get bookRaw =>
      CopyWith$Input$BookCreateNestedOneWithoutBookRawInput.stub(_res);

  CopyWith$Input$BookRevisionCreatecontentInput<TRes> get content =>
      CopyWith$Input$BookRevisionCreatecontentInput.stub(_res);
}

class Input$BookRevisionCreateWithoutBookRawInput {
  factory Input$BookRevisionCreateWithoutBookRawInput({
    Input$BookCreateNestedOneWithoutBookEditedInput? bookEdited,
    int? completionTokens,
    Input$BookRevisionCreatecontentInput? content,
    String? createdAt,
    bool? isRaw,
    String? model,
    int? promptTokens,
    String? raw,
    String? requestId,
    String? systemPrompt,
    int? totalTokens,
    String? updatedAt,
    String? userPrompt,
    String? uuid,
  }) =>
      Input$BookRevisionCreateWithoutBookRawInput._({
        if (bookEdited != null) r'bookEdited': bookEdited,
        if (completionTokens != null) r'completionTokens': completionTokens,
        if (content != null) r'content': content,
        if (createdAt != null) r'createdAt': createdAt,
        if (isRaw != null) r'isRaw': isRaw,
        if (model != null) r'model': model,
        if (promptTokens != null) r'promptTokens': promptTokens,
        if (raw != null) r'raw': raw,
        if (requestId != null) r'requestId': requestId,
        if (systemPrompt != null) r'systemPrompt': systemPrompt,
        if (totalTokens != null) r'totalTokens': totalTokens,
        if (updatedAt != null) r'updatedAt': updatedAt,
        if (userPrompt != null) r'userPrompt': userPrompt,
        if (uuid != null) r'uuid': uuid,
      });

  Input$BookRevisionCreateWithoutBookRawInput._(this._$data);

  factory Input$BookRevisionCreateWithoutBookRawInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('bookEdited')) {
      final l$bookEdited = data['bookEdited'];
      result$data['bookEdited'] = l$bookEdited == null
          ? null
          : Input$BookCreateNestedOneWithoutBookEditedInput.fromJson(
              (l$bookEdited as Map<String, dynamic>));
    }
    if (data.containsKey('completionTokens')) {
      final l$completionTokens = data['completionTokens'];
      result$data['completionTokens'] = (l$completionTokens as int?);
    }
    if (data.containsKey('content')) {
      final l$content = data['content'];
      result$data['content'] = l$content == null
          ? null
          : Input$BookRevisionCreatecontentInput.fromJson(
              (l$content as Map<String, dynamic>));
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = (l$createdAt as String?);
    }
    if (data.containsKey('isRaw')) {
      final l$isRaw = data['isRaw'];
      result$data['isRaw'] = (l$isRaw as bool?);
    }
    if (data.containsKey('model')) {
      final l$model = data['model'];
      result$data['model'] = (l$model as String?);
    }
    if (data.containsKey('promptTokens')) {
      final l$promptTokens = data['promptTokens'];
      result$data['promptTokens'] = (l$promptTokens as int?);
    }
    if (data.containsKey('raw')) {
      final l$raw = data['raw'];
      result$data['raw'] = (l$raw as String?);
    }
    if (data.containsKey('requestId')) {
      final l$requestId = data['requestId'];
      result$data['requestId'] = (l$requestId as String?);
    }
    if (data.containsKey('systemPrompt')) {
      final l$systemPrompt = data['systemPrompt'];
      result$data['systemPrompt'] = (l$systemPrompt as String?);
    }
    if (data.containsKey('totalTokens')) {
      final l$totalTokens = data['totalTokens'];
      result$data['totalTokens'] = (l$totalTokens as int?);
    }
    if (data.containsKey('updatedAt')) {
      final l$updatedAt = data['updatedAt'];
      result$data['updatedAt'] = (l$updatedAt as String?);
    }
    if (data.containsKey('userPrompt')) {
      final l$userPrompt = data['userPrompt'];
      result$data['userPrompt'] = (l$userPrompt as String?);
    }
    if (data.containsKey('uuid')) {
      final l$uuid = data['uuid'];
      result$data['uuid'] = (l$uuid as String?);
    }
    return Input$BookRevisionCreateWithoutBookRawInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$BookCreateNestedOneWithoutBookEditedInput? get bookEdited =>
      (_$data['bookEdited']
          as Input$BookCreateNestedOneWithoutBookEditedInput?);

  int? get completionTokens => (_$data['completionTokens'] as int?);

  Input$BookRevisionCreatecontentInput? get content =>
      (_$data['content'] as Input$BookRevisionCreatecontentInput?);

  String? get createdAt => (_$data['createdAt'] as String?);

  bool? get isRaw => (_$data['isRaw'] as bool?);

  String? get model => (_$data['model'] as String?);

  int? get promptTokens => (_$data['promptTokens'] as int?);

  String? get raw => (_$data['raw'] as String?);

  String? get requestId => (_$data['requestId'] as String?);

  String? get systemPrompt => (_$data['systemPrompt'] as String?);

  int? get totalTokens => (_$data['totalTokens'] as int?);

  String? get updatedAt => (_$data['updatedAt'] as String?);

  String? get userPrompt => (_$data['userPrompt'] as String?);

  String? get uuid => (_$data['uuid'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('bookEdited')) {
      final l$bookEdited = bookEdited;
      result$data['bookEdited'] = l$bookEdited?.toJson();
    }
    if (_$data.containsKey('completionTokens')) {
      final l$completionTokens = completionTokens;
      result$data['completionTokens'] = l$completionTokens;
    }
    if (_$data.containsKey('content')) {
      final l$content = content;
      result$data['content'] = l$content?.toJson();
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt;
    }
    if (_$data.containsKey('isRaw')) {
      final l$isRaw = isRaw;
      result$data['isRaw'] = l$isRaw;
    }
    if (_$data.containsKey('model')) {
      final l$model = model;
      result$data['model'] = l$model;
    }
    if (_$data.containsKey('promptTokens')) {
      final l$promptTokens = promptTokens;
      result$data['promptTokens'] = l$promptTokens;
    }
    if (_$data.containsKey('raw')) {
      final l$raw = raw;
      result$data['raw'] = l$raw;
    }
    if (_$data.containsKey('requestId')) {
      final l$requestId = requestId;
      result$data['requestId'] = l$requestId;
    }
    if (_$data.containsKey('systemPrompt')) {
      final l$systemPrompt = systemPrompt;
      result$data['systemPrompt'] = l$systemPrompt;
    }
    if (_$data.containsKey('totalTokens')) {
      final l$totalTokens = totalTokens;
      result$data['totalTokens'] = l$totalTokens;
    }
    if (_$data.containsKey('updatedAt')) {
      final l$updatedAt = updatedAt;
      result$data['updatedAt'] = l$updatedAt;
    }
    if (_$data.containsKey('userPrompt')) {
      final l$userPrompt = userPrompt;
      result$data['userPrompt'] = l$userPrompt;
    }
    if (_$data.containsKey('uuid')) {
      final l$uuid = uuid;
      result$data['uuid'] = l$uuid;
    }
    return result$data;
  }

  CopyWith$Input$BookRevisionCreateWithoutBookRawInput<
          Input$BookRevisionCreateWithoutBookRawInput>
      get copyWith => CopyWith$Input$BookRevisionCreateWithoutBookRawInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$BookRevisionCreateWithoutBookRawInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$bookEdited = bookEdited;
    final lOther$bookEdited = other.bookEdited;
    if (_$data.containsKey('bookEdited') !=
        other._$data.containsKey('bookEdited')) {
      return false;
    }
    if (l$bookEdited != lOther$bookEdited) {
      return false;
    }
    final l$completionTokens = completionTokens;
    final lOther$completionTokens = other.completionTokens;
    if (_$data.containsKey('completionTokens') !=
        other._$data.containsKey('completionTokens')) {
      return false;
    }
    if (l$completionTokens != lOther$completionTokens) {
      return false;
    }
    final l$content = content;
    final lOther$content = other.content;
    if (_$data.containsKey('content') != other._$data.containsKey('content')) {
      return false;
    }
    if (l$content != lOther$content) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$isRaw = isRaw;
    final lOther$isRaw = other.isRaw;
    if (_$data.containsKey('isRaw') != other._$data.containsKey('isRaw')) {
      return false;
    }
    if (l$isRaw != lOther$isRaw) {
      return false;
    }
    final l$model = model;
    final lOther$model = other.model;
    if (_$data.containsKey('model') != other._$data.containsKey('model')) {
      return false;
    }
    if (l$model != lOther$model) {
      return false;
    }
    final l$promptTokens = promptTokens;
    final lOther$promptTokens = other.promptTokens;
    if (_$data.containsKey('promptTokens') !=
        other._$data.containsKey('promptTokens')) {
      return false;
    }
    if (l$promptTokens != lOther$promptTokens) {
      return false;
    }
    final l$raw = raw;
    final lOther$raw = other.raw;
    if (_$data.containsKey('raw') != other._$data.containsKey('raw')) {
      return false;
    }
    if (l$raw != lOther$raw) {
      return false;
    }
    final l$requestId = requestId;
    final lOther$requestId = other.requestId;
    if (_$data.containsKey('requestId') !=
        other._$data.containsKey('requestId')) {
      return false;
    }
    if (l$requestId != lOther$requestId) {
      return false;
    }
    final l$systemPrompt = systemPrompt;
    final lOther$systemPrompt = other.systemPrompt;
    if (_$data.containsKey('systemPrompt') !=
        other._$data.containsKey('systemPrompt')) {
      return false;
    }
    if (l$systemPrompt != lOther$systemPrompt) {
      return false;
    }
    final l$totalTokens = totalTokens;
    final lOther$totalTokens = other.totalTokens;
    if (_$data.containsKey('totalTokens') !=
        other._$data.containsKey('totalTokens')) {
      return false;
    }
    if (l$totalTokens != lOther$totalTokens) {
      return false;
    }
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (_$data.containsKey('updatedAt') !=
        other._$data.containsKey('updatedAt')) {
      return false;
    }
    if (l$updatedAt != lOther$updatedAt) {
      return false;
    }
    final l$userPrompt = userPrompt;
    final lOther$userPrompt = other.userPrompt;
    if (_$data.containsKey('userPrompt') !=
        other._$data.containsKey('userPrompt')) {
      return false;
    }
    if (l$userPrompt != lOther$userPrompt) {
      return false;
    }
    final l$uuid = uuid;
    final lOther$uuid = other.uuid;
    if (_$data.containsKey('uuid') != other._$data.containsKey('uuid')) {
      return false;
    }
    if (l$uuid != lOther$uuid) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$bookEdited = bookEdited;
    final l$completionTokens = completionTokens;
    final l$content = content;
    final l$createdAt = createdAt;
    final l$isRaw = isRaw;
    final l$model = model;
    final l$promptTokens = promptTokens;
    final l$raw = raw;
    final l$requestId = requestId;
    final l$systemPrompt = systemPrompt;
    final l$totalTokens = totalTokens;
    final l$updatedAt = updatedAt;
    final l$userPrompt = userPrompt;
    final l$uuid = uuid;
    return Object.hashAll([
      _$data.containsKey('bookEdited') ? l$bookEdited : const {},
      _$data.containsKey('completionTokens') ? l$completionTokens : const {},
      _$data.containsKey('content') ? l$content : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('isRaw') ? l$isRaw : const {},
      _$data.containsKey('model') ? l$model : const {},
      _$data.containsKey('promptTokens') ? l$promptTokens : const {},
      _$data.containsKey('raw') ? l$raw : const {},
      _$data.containsKey('requestId') ? l$requestId : const {},
      _$data.containsKey('systemPrompt') ? l$systemPrompt : const {},
      _$data.containsKey('totalTokens') ? l$totalTokens : const {},
      _$data.containsKey('updatedAt') ? l$updatedAt : const {},
      _$data.containsKey('userPrompt') ? l$userPrompt : const {},
      _$data.containsKey('uuid') ? l$uuid : const {},
    ]);
  }
}

abstract class CopyWith$Input$BookRevisionCreateWithoutBookRawInput<TRes> {
  factory CopyWith$Input$BookRevisionCreateWithoutBookRawInput(
    Input$BookRevisionCreateWithoutBookRawInput instance,
    TRes Function(Input$BookRevisionCreateWithoutBookRawInput) then,
  ) = _CopyWithImpl$Input$BookRevisionCreateWithoutBookRawInput;

  factory CopyWith$Input$BookRevisionCreateWithoutBookRawInput.stub(TRes res) =
      _CopyWithStubImpl$Input$BookRevisionCreateWithoutBookRawInput;

  TRes call({
    Input$BookCreateNestedOneWithoutBookEditedInput? bookEdited,
    int? completionTokens,
    Input$BookRevisionCreatecontentInput? content,
    String? createdAt,
    bool? isRaw,
    String? model,
    int? promptTokens,
    String? raw,
    String? requestId,
    String? systemPrompt,
    int? totalTokens,
    String? updatedAt,
    String? userPrompt,
    String? uuid,
  });
  CopyWith$Input$BookCreateNestedOneWithoutBookEditedInput<TRes> get bookEdited;
  CopyWith$Input$BookRevisionCreatecontentInput<TRes> get content;
}

class _CopyWithImpl$Input$BookRevisionCreateWithoutBookRawInput<TRes>
    implements CopyWith$Input$BookRevisionCreateWithoutBookRawInput<TRes> {
  _CopyWithImpl$Input$BookRevisionCreateWithoutBookRawInput(
    this._instance,
    this._then,
  );

  final Input$BookRevisionCreateWithoutBookRawInput _instance;

  final TRes Function(Input$BookRevisionCreateWithoutBookRawInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? bookEdited = _undefined,
    Object? completionTokens = _undefined,
    Object? content = _undefined,
    Object? createdAt = _undefined,
    Object? isRaw = _undefined,
    Object? model = _undefined,
    Object? promptTokens = _undefined,
    Object? raw = _undefined,
    Object? requestId = _undefined,
    Object? systemPrompt = _undefined,
    Object? totalTokens = _undefined,
    Object? updatedAt = _undefined,
    Object? userPrompt = _undefined,
    Object? uuid = _undefined,
  }) =>
      _then(Input$BookRevisionCreateWithoutBookRawInput._({
        ..._instance._$data,
        if (bookEdited != _undefined)
          'bookEdited':
              (bookEdited as Input$BookCreateNestedOneWithoutBookEditedInput?),
        if (completionTokens != _undefined)
          'completionTokens': (completionTokens as int?),
        if (content != _undefined)
          'content': (content as Input$BookRevisionCreatecontentInput?),
        if (createdAt != _undefined) 'createdAt': (createdAt as String?),
        if (isRaw != _undefined) 'isRaw': (isRaw as bool?),
        if (model != _undefined) 'model': (model as String?),
        if (promptTokens != _undefined) 'promptTokens': (promptTokens as int?),
        if (raw != _undefined) 'raw': (raw as String?),
        if (requestId != _undefined) 'requestId': (requestId as String?),
        if (systemPrompt != _undefined)
          'systemPrompt': (systemPrompt as String?),
        if (totalTokens != _undefined) 'totalTokens': (totalTokens as int?),
        if (updatedAt != _undefined) 'updatedAt': (updatedAt as String?),
        if (userPrompt != _undefined) 'userPrompt': (userPrompt as String?),
        if (uuid != _undefined) 'uuid': (uuid as String?),
      }));

  CopyWith$Input$BookCreateNestedOneWithoutBookEditedInput<TRes>
      get bookEdited {
    final local$bookEdited = _instance.bookEdited;
    return local$bookEdited == null
        ? CopyWith$Input$BookCreateNestedOneWithoutBookEditedInput.stub(
            _then(_instance))
        : CopyWith$Input$BookCreateNestedOneWithoutBookEditedInput(
            local$bookEdited, (e) => call(bookEdited: e));
  }

  CopyWith$Input$BookRevisionCreatecontentInput<TRes> get content {
    final local$content = _instance.content;
    return local$content == null
        ? CopyWith$Input$BookRevisionCreatecontentInput.stub(_then(_instance))
        : CopyWith$Input$BookRevisionCreatecontentInput(
            local$content, (e) => call(content: e));
  }
}

class _CopyWithStubImpl$Input$BookRevisionCreateWithoutBookRawInput<TRes>
    implements CopyWith$Input$BookRevisionCreateWithoutBookRawInput<TRes> {
  _CopyWithStubImpl$Input$BookRevisionCreateWithoutBookRawInput(this._res);

  TRes _res;

  call({
    Input$BookCreateNestedOneWithoutBookEditedInput? bookEdited,
    int? completionTokens,
    Input$BookRevisionCreatecontentInput? content,
    String? createdAt,
    bool? isRaw,
    String? model,
    int? promptTokens,
    String? raw,
    String? requestId,
    String? systemPrompt,
    int? totalTokens,
    String? updatedAt,
    String? userPrompt,
    String? uuid,
  }) =>
      _res;

  CopyWith$Input$BookCreateNestedOneWithoutBookEditedInput<TRes>
      get bookEdited =>
          CopyWith$Input$BookCreateNestedOneWithoutBookEditedInput.stub(_res);

  CopyWith$Input$BookRevisionCreatecontentInput<TRes> get content =>
      CopyWith$Input$BookRevisionCreatecontentInput.stub(_res);
}

class Input$BookRevisionCreatecontentInput {
  factory Input$BookRevisionCreatecontentInput({required List<String> $set}) =>
      Input$BookRevisionCreatecontentInput._({
        r'set': $set,
      });

  Input$BookRevisionCreatecontentInput._(this._$data);

  factory Input$BookRevisionCreatecontentInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$$set = data['set'];
    result$data['set'] =
        (l$$set as List<dynamic>).map((e) => (e as String)).toList();
    return Input$BookRevisionCreatecontentInput._(result$data);
  }

  Map<String, dynamic> _$data;

  List<String> get $set => (_$data['set'] as List<String>);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$$set = $set;
    result$data['set'] = l$$set.map((e) => e).toList();
    return result$data;
  }

  CopyWith$Input$BookRevisionCreatecontentInput<
          Input$BookRevisionCreatecontentInput>
      get copyWith => CopyWith$Input$BookRevisionCreatecontentInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$BookRevisionCreatecontentInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$$set = $set;
    final lOther$$set = other.$set;
    if (l$$set.length != lOther$$set.length) {
      return false;
    }
    for (int i = 0; i < l$$set.length; i++) {
      final l$$set$entry = l$$set[i];
      final lOther$$set$entry = lOther$$set[i];
      if (l$$set$entry != lOther$$set$entry) {
        return false;
      }
    }
    return true;
  }

  @override
  int get hashCode {
    final l$$set = $set;
    return Object.hashAll([Object.hashAll(l$$set.map((v) => v))]);
  }
}

abstract class CopyWith$Input$BookRevisionCreatecontentInput<TRes> {
  factory CopyWith$Input$BookRevisionCreatecontentInput(
    Input$BookRevisionCreatecontentInput instance,
    TRes Function(Input$BookRevisionCreatecontentInput) then,
  ) = _CopyWithImpl$Input$BookRevisionCreatecontentInput;

  factory CopyWith$Input$BookRevisionCreatecontentInput.stub(TRes res) =
      _CopyWithStubImpl$Input$BookRevisionCreatecontentInput;

  TRes call({List<String>? $set});
}

class _CopyWithImpl$Input$BookRevisionCreatecontentInput<TRes>
    implements CopyWith$Input$BookRevisionCreatecontentInput<TRes> {
  _CopyWithImpl$Input$BookRevisionCreatecontentInput(
    this._instance,
    this._then,
  );

  final Input$BookRevisionCreatecontentInput _instance;

  final TRes Function(Input$BookRevisionCreatecontentInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({Object? $set = _undefined}) =>
      _then(Input$BookRevisionCreatecontentInput._({
        ..._instance._$data,
        if ($set != _undefined && $set != null) 'set': ($set as List<String>),
      }));
}

class _CopyWithStubImpl$Input$BookRevisionCreatecontentInput<TRes>
    implements CopyWith$Input$BookRevisionCreatecontentInput<TRes> {
  _CopyWithStubImpl$Input$BookRevisionCreatecontentInput(this._res);

  TRes _res;

  call({List<String>? $set}) => _res;
}

class Input$BookRevisionMaxOrderByAggregateInput {
  factory Input$BookRevisionMaxOrderByAggregateInput({
    Enum$SortOrder? bookEditedId,
    Enum$SortOrder? bookRawId,
    Enum$SortOrder? completionTokens,
    Enum$SortOrder? createdAt,
    Enum$SortOrder? isRaw,
    Enum$SortOrder? model,
    Enum$SortOrder? promptTokens,
    Enum$SortOrder? raw,
    Enum$SortOrder? requestId,
    Enum$SortOrder? systemPrompt,
    Enum$SortOrder? totalTokens,
    Enum$SortOrder? updatedAt,
    Enum$SortOrder? userPrompt,
    Enum$SortOrder? uuid,
  }) =>
      Input$BookRevisionMaxOrderByAggregateInput._({
        if (bookEditedId != null) r'bookEditedId': bookEditedId,
        if (bookRawId != null) r'bookRawId': bookRawId,
        if (completionTokens != null) r'completionTokens': completionTokens,
        if (createdAt != null) r'createdAt': createdAt,
        if (isRaw != null) r'isRaw': isRaw,
        if (model != null) r'model': model,
        if (promptTokens != null) r'promptTokens': promptTokens,
        if (raw != null) r'raw': raw,
        if (requestId != null) r'requestId': requestId,
        if (systemPrompt != null) r'systemPrompt': systemPrompt,
        if (totalTokens != null) r'totalTokens': totalTokens,
        if (updatedAt != null) r'updatedAt': updatedAt,
        if (userPrompt != null) r'userPrompt': userPrompt,
        if (uuid != null) r'uuid': uuid,
      });

  Input$BookRevisionMaxOrderByAggregateInput._(this._$data);

  factory Input$BookRevisionMaxOrderByAggregateInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('bookEditedId')) {
      final l$bookEditedId = data['bookEditedId'];
      result$data['bookEditedId'] = l$bookEditedId == null
          ? null
          : fromJson$Enum$SortOrder((l$bookEditedId as String));
    }
    if (data.containsKey('bookRawId')) {
      final l$bookRawId = data['bookRawId'];
      result$data['bookRawId'] = l$bookRawId == null
          ? null
          : fromJson$Enum$SortOrder((l$bookRawId as String));
    }
    if (data.containsKey('completionTokens')) {
      final l$completionTokens = data['completionTokens'];
      result$data['completionTokens'] = l$completionTokens == null
          ? null
          : fromJson$Enum$SortOrder((l$completionTokens as String));
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : fromJson$Enum$SortOrder((l$createdAt as String));
    }
    if (data.containsKey('isRaw')) {
      final l$isRaw = data['isRaw'];
      result$data['isRaw'] =
          l$isRaw == null ? null : fromJson$Enum$SortOrder((l$isRaw as String));
    }
    if (data.containsKey('model')) {
      final l$model = data['model'];
      result$data['model'] =
          l$model == null ? null : fromJson$Enum$SortOrder((l$model as String));
    }
    if (data.containsKey('promptTokens')) {
      final l$promptTokens = data['promptTokens'];
      result$data['promptTokens'] = l$promptTokens == null
          ? null
          : fromJson$Enum$SortOrder((l$promptTokens as String));
    }
    if (data.containsKey('raw')) {
      final l$raw = data['raw'];
      result$data['raw'] =
          l$raw == null ? null : fromJson$Enum$SortOrder((l$raw as String));
    }
    if (data.containsKey('requestId')) {
      final l$requestId = data['requestId'];
      result$data['requestId'] = l$requestId == null
          ? null
          : fromJson$Enum$SortOrder((l$requestId as String));
    }
    if (data.containsKey('systemPrompt')) {
      final l$systemPrompt = data['systemPrompt'];
      result$data['systemPrompt'] = l$systemPrompt == null
          ? null
          : fromJson$Enum$SortOrder((l$systemPrompt as String));
    }
    if (data.containsKey('totalTokens')) {
      final l$totalTokens = data['totalTokens'];
      result$data['totalTokens'] = l$totalTokens == null
          ? null
          : fromJson$Enum$SortOrder((l$totalTokens as String));
    }
    if (data.containsKey('updatedAt')) {
      final l$updatedAt = data['updatedAt'];
      result$data['updatedAt'] = l$updatedAt == null
          ? null
          : fromJson$Enum$SortOrder((l$updatedAt as String));
    }
    if (data.containsKey('userPrompt')) {
      final l$userPrompt = data['userPrompt'];
      result$data['userPrompt'] = l$userPrompt == null
          ? null
          : fromJson$Enum$SortOrder((l$userPrompt as String));
    }
    if (data.containsKey('uuid')) {
      final l$uuid = data['uuid'];
      result$data['uuid'] =
          l$uuid == null ? null : fromJson$Enum$SortOrder((l$uuid as String));
    }
    return Input$BookRevisionMaxOrderByAggregateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$SortOrder? get bookEditedId =>
      (_$data['bookEditedId'] as Enum$SortOrder?);

  Enum$SortOrder? get bookRawId => (_$data['bookRawId'] as Enum$SortOrder?);

  Enum$SortOrder? get completionTokens =>
      (_$data['completionTokens'] as Enum$SortOrder?);

  Enum$SortOrder? get createdAt => (_$data['createdAt'] as Enum$SortOrder?);

  Enum$SortOrder? get isRaw => (_$data['isRaw'] as Enum$SortOrder?);

  Enum$SortOrder? get model => (_$data['model'] as Enum$SortOrder?);

  Enum$SortOrder? get promptTokens =>
      (_$data['promptTokens'] as Enum$SortOrder?);

  Enum$SortOrder? get raw => (_$data['raw'] as Enum$SortOrder?);

  Enum$SortOrder? get requestId => (_$data['requestId'] as Enum$SortOrder?);

  Enum$SortOrder? get systemPrompt =>
      (_$data['systemPrompt'] as Enum$SortOrder?);

  Enum$SortOrder? get totalTokens => (_$data['totalTokens'] as Enum$SortOrder?);

  Enum$SortOrder? get updatedAt => (_$data['updatedAt'] as Enum$SortOrder?);

  Enum$SortOrder? get userPrompt => (_$data['userPrompt'] as Enum$SortOrder?);

  Enum$SortOrder? get uuid => (_$data['uuid'] as Enum$SortOrder?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('bookEditedId')) {
      final l$bookEditedId = bookEditedId;
      result$data['bookEditedId'] =
          l$bookEditedId == null ? null : toJson$Enum$SortOrder(l$bookEditedId);
    }
    if (_$data.containsKey('bookRawId')) {
      final l$bookRawId = bookRawId;
      result$data['bookRawId'] =
          l$bookRawId == null ? null : toJson$Enum$SortOrder(l$bookRawId);
    }
    if (_$data.containsKey('completionTokens')) {
      final l$completionTokens = completionTokens;
      result$data['completionTokens'] = l$completionTokens == null
          ? null
          : toJson$Enum$SortOrder(l$completionTokens);
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] =
          l$createdAt == null ? null : toJson$Enum$SortOrder(l$createdAt);
    }
    if (_$data.containsKey('isRaw')) {
      final l$isRaw = isRaw;
      result$data['isRaw'] =
          l$isRaw == null ? null : toJson$Enum$SortOrder(l$isRaw);
    }
    if (_$data.containsKey('model')) {
      final l$model = model;
      result$data['model'] =
          l$model == null ? null : toJson$Enum$SortOrder(l$model);
    }
    if (_$data.containsKey('promptTokens')) {
      final l$promptTokens = promptTokens;
      result$data['promptTokens'] =
          l$promptTokens == null ? null : toJson$Enum$SortOrder(l$promptTokens);
    }
    if (_$data.containsKey('raw')) {
      final l$raw = raw;
      result$data['raw'] = l$raw == null ? null : toJson$Enum$SortOrder(l$raw);
    }
    if (_$data.containsKey('requestId')) {
      final l$requestId = requestId;
      result$data['requestId'] =
          l$requestId == null ? null : toJson$Enum$SortOrder(l$requestId);
    }
    if (_$data.containsKey('systemPrompt')) {
      final l$systemPrompt = systemPrompt;
      result$data['systemPrompt'] =
          l$systemPrompt == null ? null : toJson$Enum$SortOrder(l$systemPrompt);
    }
    if (_$data.containsKey('totalTokens')) {
      final l$totalTokens = totalTokens;
      result$data['totalTokens'] =
          l$totalTokens == null ? null : toJson$Enum$SortOrder(l$totalTokens);
    }
    if (_$data.containsKey('updatedAt')) {
      final l$updatedAt = updatedAt;
      result$data['updatedAt'] =
          l$updatedAt == null ? null : toJson$Enum$SortOrder(l$updatedAt);
    }
    if (_$data.containsKey('userPrompt')) {
      final l$userPrompt = userPrompt;
      result$data['userPrompt'] =
          l$userPrompt == null ? null : toJson$Enum$SortOrder(l$userPrompt);
    }
    if (_$data.containsKey('uuid')) {
      final l$uuid = uuid;
      result$data['uuid'] =
          l$uuid == null ? null : toJson$Enum$SortOrder(l$uuid);
    }
    return result$data;
  }

  CopyWith$Input$BookRevisionMaxOrderByAggregateInput<
          Input$BookRevisionMaxOrderByAggregateInput>
      get copyWith => CopyWith$Input$BookRevisionMaxOrderByAggregateInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$BookRevisionMaxOrderByAggregateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$bookEditedId = bookEditedId;
    final lOther$bookEditedId = other.bookEditedId;
    if (_$data.containsKey('bookEditedId') !=
        other._$data.containsKey('bookEditedId')) {
      return false;
    }
    if (l$bookEditedId != lOther$bookEditedId) {
      return false;
    }
    final l$bookRawId = bookRawId;
    final lOther$bookRawId = other.bookRawId;
    if (_$data.containsKey('bookRawId') !=
        other._$data.containsKey('bookRawId')) {
      return false;
    }
    if (l$bookRawId != lOther$bookRawId) {
      return false;
    }
    final l$completionTokens = completionTokens;
    final lOther$completionTokens = other.completionTokens;
    if (_$data.containsKey('completionTokens') !=
        other._$data.containsKey('completionTokens')) {
      return false;
    }
    if (l$completionTokens != lOther$completionTokens) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$isRaw = isRaw;
    final lOther$isRaw = other.isRaw;
    if (_$data.containsKey('isRaw') != other._$data.containsKey('isRaw')) {
      return false;
    }
    if (l$isRaw != lOther$isRaw) {
      return false;
    }
    final l$model = model;
    final lOther$model = other.model;
    if (_$data.containsKey('model') != other._$data.containsKey('model')) {
      return false;
    }
    if (l$model != lOther$model) {
      return false;
    }
    final l$promptTokens = promptTokens;
    final lOther$promptTokens = other.promptTokens;
    if (_$data.containsKey('promptTokens') !=
        other._$data.containsKey('promptTokens')) {
      return false;
    }
    if (l$promptTokens != lOther$promptTokens) {
      return false;
    }
    final l$raw = raw;
    final lOther$raw = other.raw;
    if (_$data.containsKey('raw') != other._$data.containsKey('raw')) {
      return false;
    }
    if (l$raw != lOther$raw) {
      return false;
    }
    final l$requestId = requestId;
    final lOther$requestId = other.requestId;
    if (_$data.containsKey('requestId') !=
        other._$data.containsKey('requestId')) {
      return false;
    }
    if (l$requestId != lOther$requestId) {
      return false;
    }
    final l$systemPrompt = systemPrompt;
    final lOther$systemPrompt = other.systemPrompt;
    if (_$data.containsKey('systemPrompt') !=
        other._$data.containsKey('systemPrompt')) {
      return false;
    }
    if (l$systemPrompt != lOther$systemPrompt) {
      return false;
    }
    final l$totalTokens = totalTokens;
    final lOther$totalTokens = other.totalTokens;
    if (_$data.containsKey('totalTokens') !=
        other._$data.containsKey('totalTokens')) {
      return false;
    }
    if (l$totalTokens != lOther$totalTokens) {
      return false;
    }
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (_$data.containsKey('updatedAt') !=
        other._$data.containsKey('updatedAt')) {
      return false;
    }
    if (l$updatedAt != lOther$updatedAt) {
      return false;
    }
    final l$userPrompt = userPrompt;
    final lOther$userPrompt = other.userPrompt;
    if (_$data.containsKey('userPrompt') !=
        other._$data.containsKey('userPrompt')) {
      return false;
    }
    if (l$userPrompt != lOther$userPrompt) {
      return false;
    }
    final l$uuid = uuid;
    final lOther$uuid = other.uuid;
    if (_$data.containsKey('uuid') != other._$data.containsKey('uuid')) {
      return false;
    }
    if (l$uuid != lOther$uuid) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$bookEditedId = bookEditedId;
    final l$bookRawId = bookRawId;
    final l$completionTokens = completionTokens;
    final l$createdAt = createdAt;
    final l$isRaw = isRaw;
    final l$model = model;
    final l$promptTokens = promptTokens;
    final l$raw = raw;
    final l$requestId = requestId;
    final l$systemPrompt = systemPrompt;
    final l$totalTokens = totalTokens;
    final l$updatedAt = updatedAt;
    final l$userPrompt = userPrompt;
    final l$uuid = uuid;
    return Object.hashAll([
      _$data.containsKey('bookEditedId') ? l$bookEditedId : const {},
      _$data.containsKey('bookRawId') ? l$bookRawId : const {},
      _$data.containsKey('completionTokens') ? l$completionTokens : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('isRaw') ? l$isRaw : const {},
      _$data.containsKey('model') ? l$model : const {},
      _$data.containsKey('promptTokens') ? l$promptTokens : const {},
      _$data.containsKey('raw') ? l$raw : const {},
      _$data.containsKey('requestId') ? l$requestId : const {},
      _$data.containsKey('systemPrompt') ? l$systemPrompt : const {},
      _$data.containsKey('totalTokens') ? l$totalTokens : const {},
      _$data.containsKey('updatedAt') ? l$updatedAt : const {},
      _$data.containsKey('userPrompt') ? l$userPrompt : const {},
      _$data.containsKey('uuid') ? l$uuid : const {},
    ]);
  }
}

abstract class CopyWith$Input$BookRevisionMaxOrderByAggregateInput<TRes> {
  factory CopyWith$Input$BookRevisionMaxOrderByAggregateInput(
    Input$BookRevisionMaxOrderByAggregateInput instance,
    TRes Function(Input$BookRevisionMaxOrderByAggregateInput) then,
  ) = _CopyWithImpl$Input$BookRevisionMaxOrderByAggregateInput;

  factory CopyWith$Input$BookRevisionMaxOrderByAggregateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$BookRevisionMaxOrderByAggregateInput;

  TRes call({
    Enum$SortOrder? bookEditedId,
    Enum$SortOrder? bookRawId,
    Enum$SortOrder? completionTokens,
    Enum$SortOrder? createdAt,
    Enum$SortOrder? isRaw,
    Enum$SortOrder? model,
    Enum$SortOrder? promptTokens,
    Enum$SortOrder? raw,
    Enum$SortOrder? requestId,
    Enum$SortOrder? systemPrompt,
    Enum$SortOrder? totalTokens,
    Enum$SortOrder? updatedAt,
    Enum$SortOrder? userPrompt,
    Enum$SortOrder? uuid,
  });
}

class _CopyWithImpl$Input$BookRevisionMaxOrderByAggregateInput<TRes>
    implements CopyWith$Input$BookRevisionMaxOrderByAggregateInput<TRes> {
  _CopyWithImpl$Input$BookRevisionMaxOrderByAggregateInput(
    this._instance,
    this._then,
  );

  final Input$BookRevisionMaxOrderByAggregateInput _instance;

  final TRes Function(Input$BookRevisionMaxOrderByAggregateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? bookEditedId = _undefined,
    Object? bookRawId = _undefined,
    Object? completionTokens = _undefined,
    Object? createdAt = _undefined,
    Object? isRaw = _undefined,
    Object? model = _undefined,
    Object? promptTokens = _undefined,
    Object? raw = _undefined,
    Object? requestId = _undefined,
    Object? systemPrompt = _undefined,
    Object? totalTokens = _undefined,
    Object? updatedAt = _undefined,
    Object? userPrompt = _undefined,
    Object? uuid = _undefined,
  }) =>
      _then(Input$BookRevisionMaxOrderByAggregateInput._({
        ..._instance._$data,
        if (bookEditedId != _undefined)
          'bookEditedId': (bookEditedId as Enum$SortOrder?),
        if (bookRawId != _undefined)
          'bookRawId': (bookRawId as Enum$SortOrder?),
        if (completionTokens != _undefined)
          'completionTokens': (completionTokens as Enum$SortOrder?),
        if (createdAt != _undefined)
          'createdAt': (createdAt as Enum$SortOrder?),
        if (isRaw != _undefined) 'isRaw': (isRaw as Enum$SortOrder?),
        if (model != _undefined) 'model': (model as Enum$SortOrder?),
        if (promptTokens != _undefined)
          'promptTokens': (promptTokens as Enum$SortOrder?),
        if (raw != _undefined) 'raw': (raw as Enum$SortOrder?),
        if (requestId != _undefined)
          'requestId': (requestId as Enum$SortOrder?),
        if (systemPrompt != _undefined)
          'systemPrompt': (systemPrompt as Enum$SortOrder?),
        if (totalTokens != _undefined)
          'totalTokens': (totalTokens as Enum$SortOrder?),
        if (updatedAt != _undefined)
          'updatedAt': (updatedAt as Enum$SortOrder?),
        if (userPrompt != _undefined)
          'userPrompt': (userPrompt as Enum$SortOrder?),
        if (uuid != _undefined) 'uuid': (uuid as Enum$SortOrder?),
      }));
}

class _CopyWithStubImpl$Input$BookRevisionMaxOrderByAggregateInput<TRes>
    implements CopyWith$Input$BookRevisionMaxOrderByAggregateInput<TRes> {
  _CopyWithStubImpl$Input$BookRevisionMaxOrderByAggregateInput(this._res);

  TRes _res;

  call({
    Enum$SortOrder? bookEditedId,
    Enum$SortOrder? bookRawId,
    Enum$SortOrder? completionTokens,
    Enum$SortOrder? createdAt,
    Enum$SortOrder? isRaw,
    Enum$SortOrder? model,
    Enum$SortOrder? promptTokens,
    Enum$SortOrder? raw,
    Enum$SortOrder? requestId,
    Enum$SortOrder? systemPrompt,
    Enum$SortOrder? totalTokens,
    Enum$SortOrder? updatedAt,
    Enum$SortOrder? userPrompt,
    Enum$SortOrder? uuid,
  }) =>
      _res;
}

class Input$BookRevisionMinOrderByAggregateInput {
  factory Input$BookRevisionMinOrderByAggregateInput({
    Enum$SortOrder? bookEditedId,
    Enum$SortOrder? bookRawId,
    Enum$SortOrder? completionTokens,
    Enum$SortOrder? createdAt,
    Enum$SortOrder? isRaw,
    Enum$SortOrder? model,
    Enum$SortOrder? promptTokens,
    Enum$SortOrder? raw,
    Enum$SortOrder? requestId,
    Enum$SortOrder? systemPrompt,
    Enum$SortOrder? totalTokens,
    Enum$SortOrder? updatedAt,
    Enum$SortOrder? userPrompt,
    Enum$SortOrder? uuid,
  }) =>
      Input$BookRevisionMinOrderByAggregateInput._({
        if (bookEditedId != null) r'bookEditedId': bookEditedId,
        if (bookRawId != null) r'bookRawId': bookRawId,
        if (completionTokens != null) r'completionTokens': completionTokens,
        if (createdAt != null) r'createdAt': createdAt,
        if (isRaw != null) r'isRaw': isRaw,
        if (model != null) r'model': model,
        if (promptTokens != null) r'promptTokens': promptTokens,
        if (raw != null) r'raw': raw,
        if (requestId != null) r'requestId': requestId,
        if (systemPrompt != null) r'systemPrompt': systemPrompt,
        if (totalTokens != null) r'totalTokens': totalTokens,
        if (updatedAt != null) r'updatedAt': updatedAt,
        if (userPrompt != null) r'userPrompt': userPrompt,
        if (uuid != null) r'uuid': uuid,
      });

  Input$BookRevisionMinOrderByAggregateInput._(this._$data);

  factory Input$BookRevisionMinOrderByAggregateInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('bookEditedId')) {
      final l$bookEditedId = data['bookEditedId'];
      result$data['bookEditedId'] = l$bookEditedId == null
          ? null
          : fromJson$Enum$SortOrder((l$bookEditedId as String));
    }
    if (data.containsKey('bookRawId')) {
      final l$bookRawId = data['bookRawId'];
      result$data['bookRawId'] = l$bookRawId == null
          ? null
          : fromJson$Enum$SortOrder((l$bookRawId as String));
    }
    if (data.containsKey('completionTokens')) {
      final l$completionTokens = data['completionTokens'];
      result$data['completionTokens'] = l$completionTokens == null
          ? null
          : fromJson$Enum$SortOrder((l$completionTokens as String));
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : fromJson$Enum$SortOrder((l$createdAt as String));
    }
    if (data.containsKey('isRaw')) {
      final l$isRaw = data['isRaw'];
      result$data['isRaw'] =
          l$isRaw == null ? null : fromJson$Enum$SortOrder((l$isRaw as String));
    }
    if (data.containsKey('model')) {
      final l$model = data['model'];
      result$data['model'] =
          l$model == null ? null : fromJson$Enum$SortOrder((l$model as String));
    }
    if (data.containsKey('promptTokens')) {
      final l$promptTokens = data['promptTokens'];
      result$data['promptTokens'] = l$promptTokens == null
          ? null
          : fromJson$Enum$SortOrder((l$promptTokens as String));
    }
    if (data.containsKey('raw')) {
      final l$raw = data['raw'];
      result$data['raw'] =
          l$raw == null ? null : fromJson$Enum$SortOrder((l$raw as String));
    }
    if (data.containsKey('requestId')) {
      final l$requestId = data['requestId'];
      result$data['requestId'] = l$requestId == null
          ? null
          : fromJson$Enum$SortOrder((l$requestId as String));
    }
    if (data.containsKey('systemPrompt')) {
      final l$systemPrompt = data['systemPrompt'];
      result$data['systemPrompt'] = l$systemPrompt == null
          ? null
          : fromJson$Enum$SortOrder((l$systemPrompt as String));
    }
    if (data.containsKey('totalTokens')) {
      final l$totalTokens = data['totalTokens'];
      result$data['totalTokens'] = l$totalTokens == null
          ? null
          : fromJson$Enum$SortOrder((l$totalTokens as String));
    }
    if (data.containsKey('updatedAt')) {
      final l$updatedAt = data['updatedAt'];
      result$data['updatedAt'] = l$updatedAt == null
          ? null
          : fromJson$Enum$SortOrder((l$updatedAt as String));
    }
    if (data.containsKey('userPrompt')) {
      final l$userPrompt = data['userPrompt'];
      result$data['userPrompt'] = l$userPrompt == null
          ? null
          : fromJson$Enum$SortOrder((l$userPrompt as String));
    }
    if (data.containsKey('uuid')) {
      final l$uuid = data['uuid'];
      result$data['uuid'] =
          l$uuid == null ? null : fromJson$Enum$SortOrder((l$uuid as String));
    }
    return Input$BookRevisionMinOrderByAggregateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$SortOrder? get bookEditedId =>
      (_$data['bookEditedId'] as Enum$SortOrder?);

  Enum$SortOrder? get bookRawId => (_$data['bookRawId'] as Enum$SortOrder?);

  Enum$SortOrder? get completionTokens =>
      (_$data['completionTokens'] as Enum$SortOrder?);

  Enum$SortOrder? get createdAt => (_$data['createdAt'] as Enum$SortOrder?);

  Enum$SortOrder? get isRaw => (_$data['isRaw'] as Enum$SortOrder?);

  Enum$SortOrder? get model => (_$data['model'] as Enum$SortOrder?);

  Enum$SortOrder? get promptTokens =>
      (_$data['promptTokens'] as Enum$SortOrder?);

  Enum$SortOrder? get raw => (_$data['raw'] as Enum$SortOrder?);

  Enum$SortOrder? get requestId => (_$data['requestId'] as Enum$SortOrder?);

  Enum$SortOrder? get systemPrompt =>
      (_$data['systemPrompt'] as Enum$SortOrder?);

  Enum$SortOrder? get totalTokens => (_$data['totalTokens'] as Enum$SortOrder?);

  Enum$SortOrder? get updatedAt => (_$data['updatedAt'] as Enum$SortOrder?);

  Enum$SortOrder? get userPrompt => (_$data['userPrompt'] as Enum$SortOrder?);

  Enum$SortOrder? get uuid => (_$data['uuid'] as Enum$SortOrder?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('bookEditedId')) {
      final l$bookEditedId = bookEditedId;
      result$data['bookEditedId'] =
          l$bookEditedId == null ? null : toJson$Enum$SortOrder(l$bookEditedId);
    }
    if (_$data.containsKey('bookRawId')) {
      final l$bookRawId = bookRawId;
      result$data['bookRawId'] =
          l$bookRawId == null ? null : toJson$Enum$SortOrder(l$bookRawId);
    }
    if (_$data.containsKey('completionTokens')) {
      final l$completionTokens = completionTokens;
      result$data['completionTokens'] = l$completionTokens == null
          ? null
          : toJson$Enum$SortOrder(l$completionTokens);
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] =
          l$createdAt == null ? null : toJson$Enum$SortOrder(l$createdAt);
    }
    if (_$data.containsKey('isRaw')) {
      final l$isRaw = isRaw;
      result$data['isRaw'] =
          l$isRaw == null ? null : toJson$Enum$SortOrder(l$isRaw);
    }
    if (_$data.containsKey('model')) {
      final l$model = model;
      result$data['model'] =
          l$model == null ? null : toJson$Enum$SortOrder(l$model);
    }
    if (_$data.containsKey('promptTokens')) {
      final l$promptTokens = promptTokens;
      result$data['promptTokens'] =
          l$promptTokens == null ? null : toJson$Enum$SortOrder(l$promptTokens);
    }
    if (_$data.containsKey('raw')) {
      final l$raw = raw;
      result$data['raw'] = l$raw == null ? null : toJson$Enum$SortOrder(l$raw);
    }
    if (_$data.containsKey('requestId')) {
      final l$requestId = requestId;
      result$data['requestId'] =
          l$requestId == null ? null : toJson$Enum$SortOrder(l$requestId);
    }
    if (_$data.containsKey('systemPrompt')) {
      final l$systemPrompt = systemPrompt;
      result$data['systemPrompt'] =
          l$systemPrompt == null ? null : toJson$Enum$SortOrder(l$systemPrompt);
    }
    if (_$data.containsKey('totalTokens')) {
      final l$totalTokens = totalTokens;
      result$data['totalTokens'] =
          l$totalTokens == null ? null : toJson$Enum$SortOrder(l$totalTokens);
    }
    if (_$data.containsKey('updatedAt')) {
      final l$updatedAt = updatedAt;
      result$data['updatedAt'] =
          l$updatedAt == null ? null : toJson$Enum$SortOrder(l$updatedAt);
    }
    if (_$data.containsKey('userPrompt')) {
      final l$userPrompt = userPrompt;
      result$data['userPrompt'] =
          l$userPrompt == null ? null : toJson$Enum$SortOrder(l$userPrompt);
    }
    if (_$data.containsKey('uuid')) {
      final l$uuid = uuid;
      result$data['uuid'] =
          l$uuid == null ? null : toJson$Enum$SortOrder(l$uuid);
    }
    return result$data;
  }

  CopyWith$Input$BookRevisionMinOrderByAggregateInput<
          Input$BookRevisionMinOrderByAggregateInput>
      get copyWith => CopyWith$Input$BookRevisionMinOrderByAggregateInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$BookRevisionMinOrderByAggregateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$bookEditedId = bookEditedId;
    final lOther$bookEditedId = other.bookEditedId;
    if (_$data.containsKey('bookEditedId') !=
        other._$data.containsKey('bookEditedId')) {
      return false;
    }
    if (l$bookEditedId != lOther$bookEditedId) {
      return false;
    }
    final l$bookRawId = bookRawId;
    final lOther$bookRawId = other.bookRawId;
    if (_$data.containsKey('bookRawId') !=
        other._$data.containsKey('bookRawId')) {
      return false;
    }
    if (l$bookRawId != lOther$bookRawId) {
      return false;
    }
    final l$completionTokens = completionTokens;
    final lOther$completionTokens = other.completionTokens;
    if (_$data.containsKey('completionTokens') !=
        other._$data.containsKey('completionTokens')) {
      return false;
    }
    if (l$completionTokens != lOther$completionTokens) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$isRaw = isRaw;
    final lOther$isRaw = other.isRaw;
    if (_$data.containsKey('isRaw') != other._$data.containsKey('isRaw')) {
      return false;
    }
    if (l$isRaw != lOther$isRaw) {
      return false;
    }
    final l$model = model;
    final lOther$model = other.model;
    if (_$data.containsKey('model') != other._$data.containsKey('model')) {
      return false;
    }
    if (l$model != lOther$model) {
      return false;
    }
    final l$promptTokens = promptTokens;
    final lOther$promptTokens = other.promptTokens;
    if (_$data.containsKey('promptTokens') !=
        other._$data.containsKey('promptTokens')) {
      return false;
    }
    if (l$promptTokens != lOther$promptTokens) {
      return false;
    }
    final l$raw = raw;
    final lOther$raw = other.raw;
    if (_$data.containsKey('raw') != other._$data.containsKey('raw')) {
      return false;
    }
    if (l$raw != lOther$raw) {
      return false;
    }
    final l$requestId = requestId;
    final lOther$requestId = other.requestId;
    if (_$data.containsKey('requestId') !=
        other._$data.containsKey('requestId')) {
      return false;
    }
    if (l$requestId != lOther$requestId) {
      return false;
    }
    final l$systemPrompt = systemPrompt;
    final lOther$systemPrompt = other.systemPrompt;
    if (_$data.containsKey('systemPrompt') !=
        other._$data.containsKey('systemPrompt')) {
      return false;
    }
    if (l$systemPrompt != lOther$systemPrompt) {
      return false;
    }
    final l$totalTokens = totalTokens;
    final lOther$totalTokens = other.totalTokens;
    if (_$data.containsKey('totalTokens') !=
        other._$data.containsKey('totalTokens')) {
      return false;
    }
    if (l$totalTokens != lOther$totalTokens) {
      return false;
    }
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (_$data.containsKey('updatedAt') !=
        other._$data.containsKey('updatedAt')) {
      return false;
    }
    if (l$updatedAt != lOther$updatedAt) {
      return false;
    }
    final l$userPrompt = userPrompt;
    final lOther$userPrompt = other.userPrompt;
    if (_$data.containsKey('userPrompt') !=
        other._$data.containsKey('userPrompt')) {
      return false;
    }
    if (l$userPrompt != lOther$userPrompt) {
      return false;
    }
    final l$uuid = uuid;
    final lOther$uuid = other.uuid;
    if (_$data.containsKey('uuid') != other._$data.containsKey('uuid')) {
      return false;
    }
    if (l$uuid != lOther$uuid) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$bookEditedId = bookEditedId;
    final l$bookRawId = bookRawId;
    final l$completionTokens = completionTokens;
    final l$createdAt = createdAt;
    final l$isRaw = isRaw;
    final l$model = model;
    final l$promptTokens = promptTokens;
    final l$raw = raw;
    final l$requestId = requestId;
    final l$systemPrompt = systemPrompt;
    final l$totalTokens = totalTokens;
    final l$updatedAt = updatedAt;
    final l$userPrompt = userPrompt;
    final l$uuid = uuid;
    return Object.hashAll([
      _$data.containsKey('bookEditedId') ? l$bookEditedId : const {},
      _$data.containsKey('bookRawId') ? l$bookRawId : const {},
      _$data.containsKey('completionTokens') ? l$completionTokens : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('isRaw') ? l$isRaw : const {},
      _$data.containsKey('model') ? l$model : const {},
      _$data.containsKey('promptTokens') ? l$promptTokens : const {},
      _$data.containsKey('raw') ? l$raw : const {},
      _$data.containsKey('requestId') ? l$requestId : const {},
      _$data.containsKey('systemPrompt') ? l$systemPrompt : const {},
      _$data.containsKey('totalTokens') ? l$totalTokens : const {},
      _$data.containsKey('updatedAt') ? l$updatedAt : const {},
      _$data.containsKey('userPrompt') ? l$userPrompt : const {},
      _$data.containsKey('uuid') ? l$uuid : const {},
    ]);
  }
}

abstract class CopyWith$Input$BookRevisionMinOrderByAggregateInput<TRes> {
  factory CopyWith$Input$BookRevisionMinOrderByAggregateInput(
    Input$BookRevisionMinOrderByAggregateInput instance,
    TRes Function(Input$BookRevisionMinOrderByAggregateInput) then,
  ) = _CopyWithImpl$Input$BookRevisionMinOrderByAggregateInput;

  factory CopyWith$Input$BookRevisionMinOrderByAggregateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$BookRevisionMinOrderByAggregateInput;

  TRes call({
    Enum$SortOrder? bookEditedId,
    Enum$SortOrder? bookRawId,
    Enum$SortOrder? completionTokens,
    Enum$SortOrder? createdAt,
    Enum$SortOrder? isRaw,
    Enum$SortOrder? model,
    Enum$SortOrder? promptTokens,
    Enum$SortOrder? raw,
    Enum$SortOrder? requestId,
    Enum$SortOrder? systemPrompt,
    Enum$SortOrder? totalTokens,
    Enum$SortOrder? updatedAt,
    Enum$SortOrder? userPrompt,
    Enum$SortOrder? uuid,
  });
}

class _CopyWithImpl$Input$BookRevisionMinOrderByAggregateInput<TRes>
    implements CopyWith$Input$BookRevisionMinOrderByAggregateInput<TRes> {
  _CopyWithImpl$Input$BookRevisionMinOrderByAggregateInput(
    this._instance,
    this._then,
  );

  final Input$BookRevisionMinOrderByAggregateInput _instance;

  final TRes Function(Input$BookRevisionMinOrderByAggregateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? bookEditedId = _undefined,
    Object? bookRawId = _undefined,
    Object? completionTokens = _undefined,
    Object? createdAt = _undefined,
    Object? isRaw = _undefined,
    Object? model = _undefined,
    Object? promptTokens = _undefined,
    Object? raw = _undefined,
    Object? requestId = _undefined,
    Object? systemPrompt = _undefined,
    Object? totalTokens = _undefined,
    Object? updatedAt = _undefined,
    Object? userPrompt = _undefined,
    Object? uuid = _undefined,
  }) =>
      _then(Input$BookRevisionMinOrderByAggregateInput._({
        ..._instance._$data,
        if (bookEditedId != _undefined)
          'bookEditedId': (bookEditedId as Enum$SortOrder?),
        if (bookRawId != _undefined)
          'bookRawId': (bookRawId as Enum$SortOrder?),
        if (completionTokens != _undefined)
          'completionTokens': (completionTokens as Enum$SortOrder?),
        if (createdAt != _undefined)
          'createdAt': (createdAt as Enum$SortOrder?),
        if (isRaw != _undefined) 'isRaw': (isRaw as Enum$SortOrder?),
        if (model != _undefined) 'model': (model as Enum$SortOrder?),
        if (promptTokens != _undefined)
          'promptTokens': (promptTokens as Enum$SortOrder?),
        if (raw != _undefined) 'raw': (raw as Enum$SortOrder?),
        if (requestId != _undefined)
          'requestId': (requestId as Enum$SortOrder?),
        if (systemPrompt != _undefined)
          'systemPrompt': (systemPrompt as Enum$SortOrder?),
        if (totalTokens != _undefined)
          'totalTokens': (totalTokens as Enum$SortOrder?),
        if (updatedAt != _undefined)
          'updatedAt': (updatedAt as Enum$SortOrder?),
        if (userPrompt != _undefined)
          'userPrompt': (userPrompt as Enum$SortOrder?),
        if (uuid != _undefined) 'uuid': (uuid as Enum$SortOrder?),
      }));
}

class _CopyWithStubImpl$Input$BookRevisionMinOrderByAggregateInput<TRes>
    implements CopyWith$Input$BookRevisionMinOrderByAggregateInput<TRes> {
  _CopyWithStubImpl$Input$BookRevisionMinOrderByAggregateInput(this._res);

  TRes _res;

  call({
    Enum$SortOrder? bookEditedId,
    Enum$SortOrder? bookRawId,
    Enum$SortOrder? completionTokens,
    Enum$SortOrder? createdAt,
    Enum$SortOrder? isRaw,
    Enum$SortOrder? model,
    Enum$SortOrder? promptTokens,
    Enum$SortOrder? raw,
    Enum$SortOrder? requestId,
    Enum$SortOrder? systemPrompt,
    Enum$SortOrder? totalTokens,
    Enum$SortOrder? updatedAt,
    Enum$SortOrder? userPrompt,
    Enum$SortOrder? uuid,
  }) =>
      _res;
}

class Input$BookRevisionNullableRelationFilter {
  factory Input$BookRevisionNullableRelationFilter({
    Input$BookRevisionWhereInput? $is,
    Input$BookRevisionWhereInput? isNot,
  }) =>
      Input$BookRevisionNullableRelationFilter._({
        if ($is != null) r'is': $is,
        if (isNot != null) r'isNot': isNot,
      });

  Input$BookRevisionNullableRelationFilter._(this._$data);

  factory Input$BookRevisionNullableRelationFilter.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('is')) {
      final l$$is = data['is'];
      result$data['is'] = l$$is == null
          ? null
          : Input$BookRevisionWhereInput.fromJson(
              (l$$is as Map<String, dynamic>));
    }
    if (data.containsKey('isNot')) {
      final l$isNot = data['isNot'];
      result$data['isNot'] = l$isNot == null
          ? null
          : Input$BookRevisionWhereInput.fromJson(
              (l$isNot as Map<String, dynamic>));
    }
    return Input$BookRevisionNullableRelationFilter._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$BookRevisionWhereInput? get $is =>
      (_$data['is'] as Input$BookRevisionWhereInput?);

  Input$BookRevisionWhereInput? get isNot =>
      (_$data['isNot'] as Input$BookRevisionWhereInput?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('is')) {
      final l$$is = $is;
      result$data['is'] = l$$is?.toJson();
    }
    if (_$data.containsKey('isNot')) {
      final l$isNot = isNot;
      result$data['isNot'] = l$isNot?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$BookRevisionNullableRelationFilter<
          Input$BookRevisionNullableRelationFilter>
      get copyWith => CopyWith$Input$BookRevisionNullableRelationFilter(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$BookRevisionNullableRelationFilter) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$$is = $is;
    final lOther$$is = other.$is;
    if (_$data.containsKey('is') != other._$data.containsKey('is')) {
      return false;
    }
    if (l$$is != lOther$$is) {
      return false;
    }
    final l$isNot = isNot;
    final lOther$isNot = other.isNot;
    if (_$data.containsKey('isNot') != other._$data.containsKey('isNot')) {
      return false;
    }
    if (l$isNot != lOther$isNot) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$$is = $is;
    final l$isNot = isNot;
    return Object.hashAll([
      _$data.containsKey('is') ? l$$is : const {},
      _$data.containsKey('isNot') ? l$isNot : const {},
    ]);
  }
}

abstract class CopyWith$Input$BookRevisionNullableRelationFilter<TRes> {
  factory CopyWith$Input$BookRevisionNullableRelationFilter(
    Input$BookRevisionNullableRelationFilter instance,
    TRes Function(Input$BookRevisionNullableRelationFilter) then,
  ) = _CopyWithImpl$Input$BookRevisionNullableRelationFilter;

  factory CopyWith$Input$BookRevisionNullableRelationFilter.stub(TRes res) =
      _CopyWithStubImpl$Input$BookRevisionNullableRelationFilter;

  TRes call({
    Input$BookRevisionWhereInput? $is,
    Input$BookRevisionWhereInput? isNot,
  });
  CopyWith$Input$BookRevisionWhereInput<TRes> get $is;
  CopyWith$Input$BookRevisionWhereInput<TRes> get isNot;
}

class _CopyWithImpl$Input$BookRevisionNullableRelationFilter<TRes>
    implements CopyWith$Input$BookRevisionNullableRelationFilter<TRes> {
  _CopyWithImpl$Input$BookRevisionNullableRelationFilter(
    this._instance,
    this._then,
  );

  final Input$BookRevisionNullableRelationFilter _instance;

  final TRes Function(Input$BookRevisionNullableRelationFilter) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? $is = _undefined,
    Object? isNot = _undefined,
  }) =>
      _then(Input$BookRevisionNullableRelationFilter._({
        ..._instance._$data,
        if ($is != _undefined) 'is': ($is as Input$BookRevisionWhereInput?),
        if (isNot != _undefined)
          'isNot': (isNot as Input$BookRevisionWhereInput?),
      }));

  CopyWith$Input$BookRevisionWhereInput<TRes> get $is {
    final local$$is = _instance.$is;
    return local$$is == null
        ? CopyWith$Input$BookRevisionWhereInput.stub(_then(_instance))
        : CopyWith$Input$BookRevisionWhereInput(local$$is, (e) => call($is: e));
  }

  CopyWith$Input$BookRevisionWhereInput<TRes> get isNot {
    final local$isNot = _instance.isNot;
    return local$isNot == null
        ? CopyWith$Input$BookRevisionWhereInput.stub(_then(_instance))
        : CopyWith$Input$BookRevisionWhereInput(
            local$isNot, (e) => call(isNot: e));
  }
}

class _CopyWithStubImpl$Input$BookRevisionNullableRelationFilter<TRes>
    implements CopyWith$Input$BookRevisionNullableRelationFilter<TRes> {
  _CopyWithStubImpl$Input$BookRevisionNullableRelationFilter(this._res);

  TRes _res;

  call({
    Input$BookRevisionWhereInput? $is,
    Input$BookRevisionWhereInput? isNot,
  }) =>
      _res;

  CopyWith$Input$BookRevisionWhereInput<TRes> get $is =>
      CopyWith$Input$BookRevisionWhereInput.stub(_res);

  CopyWith$Input$BookRevisionWhereInput<TRes> get isNot =>
      CopyWith$Input$BookRevisionWhereInput.stub(_res);
}

class Input$BookRevisionOrderByWithAggregationInput {
  factory Input$BookRevisionOrderByWithAggregationInput({
    Input$BookRevisionAvgOrderByAggregateInput? $_avg,
    Input$BookRevisionCountOrderByAggregateInput? $_count,
    Input$BookRevisionMaxOrderByAggregateInput? $_max,
    Input$BookRevisionMinOrderByAggregateInput? $_min,
    Input$BookRevisionSumOrderByAggregateInput? $_sum,
    Input$SortOrderInput? bookEditedId,
    Input$SortOrderInput? bookRawId,
    Input$SortOrderInput? completionTokens,
    Enum$SortOrder? content,
    Enum$SortOrder? createdAt,
    Enum$SortOrder? isRaw,
    Input$SortOrderInput? model,
    Input$SortOrderInput? promptTokens,
    Input$SortOrderInput? raw,
    Input$SortOrderInput? requestId,
    Input$SortOrderInput? systemPrompt,
    Input$SortOrderInput? totalTokens,
    Enum$SortOrder? updatedAt,
    Input$SortOrderInput? userPrompt,
    Enum$SortOrder? uuid,
  }) =>
      Input$BookRevisionOrderByWithAggregationInput._({
        if ($_avg != null) r'_avg': $_avg,
        if ($_count != null) r'_count': $_count,
        if ($_max != null) r'_max': $_max,
        if ($_min != null) r'_min': $_min,
        if ($_sum != null) r'_sum': $_sum,
        if (bookEditedId != null) r'bookEditedId': bookEditedId,
        if (bookRawId != null) r'bookRawId': bookRawId,
        if (completionTokens != null) r'completionTokens': completionTokens,
        if (content != null) r'content': content,
        if (createdAt != null) r'createdAt': createdAt,
        if (isRaw != null) r'isRaw': isRaw,
        if (model != null) r'model': model,
        if (promptTokens != null) r'promptTokens': promptTokens,
        if (raw != null) r'raw': raw,
        if (requestId != null) r'requestId': requestId,
        if (systemPrompt != null) r'systemPrompt': systemPrompt,
        if (totalTokens != null) r'totalTokens': totalTokens,
        if (updatedAt != null) r'updatedAt': updatedAt,
        if (userPrompt != null) r'userPrompt': userPrompt,
        if (uuid != null) r'uuid': uuid,
      });

  Input$BookRevisionOrderByWithAggregationInput._(this._$data);

  factory Input$BookRevisionOrderByWithAggregationInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('_avg')) {
      final l$$_avg = data['_avg'];
      result$data['_avg'] = l$$_avg == null
          ? null
          : Input$BookRevisionAvgOrderByAggregateInput.fromJson(
              (l$$_avg as Map<String, dynamic>));
    }
    if (data.containsKey('_count')) {
      final l$$_count = data['_count'];
      result$data['_count'] = l$$_count == null
          ? null
          : Input$BookRevisionCountOrderByAggregateInput.fromJson(
              (l$$_count as Map<String, dynamic>));
    }
    if (data.containsKey('_max')) {
      final l$$_max = data['_max'];
      result$data['_max'] = l$$_max == null
          ? null
          : Input$BookRevisionMaxOrderByAggregateInput.fromJson(
              (l$$_max as Map<String, dynamic>));
    }
    if (data.containsKey('_min')) {
      final l$$_min = data['_min'];
      result$data['_min'] = l$$_min == null
          ? null
          : Input$BookRevisionMinOrderByAggregateInput.fromJson(
              (l$$_min as Map<String, dynamic>));
    }
    if (data.containsKey('_sum')) {
      final l$$_sum = data['_sum'];
      result$data['_sum'] = l$$_sum == null
          ? null
          : Input$BookRevisionSumOrderByAggregateInput.fromJson(
              (l$$_sum as Map<String, dynamic>));
    }
    if (data.containsKey('bookEditedId')) {
      final l$bookEditedId = data['bookEditedId'];
      result$data['bookEditedId'] = l$bookEditedId == null
          ? null
          : Input$SortOrderInput.fromJson(
              (l$bookEditedId as Map<String, dynamic>));
    }
    if (data.containsKey('bookRawId')) {
      final l$bookRawId = data['bookRawId'];
      result$data['bookRawId'] = l$bookRawId == null
          ? null
          : Input$SortOrderInput.fromJson(
              (l$bookRawId as Map<String, dynamic>));
    }
    if (data.containsKey('completionTokens')) {
      final l$completionTokens = data['completionTokens'];
      result$data['completionTokens'] = l$completionTokens == null
          ? null
          : Input$SortOrderInput.fromJson(
              (l$completionTokens as Map<String, dynamic>));
    }
    if (data.containsKey('content')) {
      final l$content = data['content'];
      result$data['content'] = l$content == null
          ? null
          : fromJson$Enum$SortOrder((l$content as String));
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : fromJson$Enum$SortOrder((l$createdAt as String));
    }
    if (data.containsKey('isRaw')) {
      final l$isRaw = data['isRaw'];
      result$data['isRaw'] =
          l$isRaw == null ? null : fromJson$Enum$SortOrder((l$isRaw as String));
    }
    if (data.containsKey('model')) {
      final l$model = data['model'];
      result$data['model'] = l$model == null
          ? null
          : Input$SortOrderInput.fromJson((l$model as Map<String, dynamic>));
    }
    if (data.containsKey('promptTokens')) {
      final l$promptTokens = data['promptTokens'];
      result$data['promptTokens'] = l$promptTokens == null
          ? null
          : Input$SortOrderInput.fromJson(
              (l$promptTokens as Map<String, dynamic>));
    }
    if (data.containsKey('raw')) {
      final l$raw = data['raw'];
      result$data['raw'] = l$raw == null
          ? null
          : Input$SortOrderInput.fromJson((l$raw as Map<String, dynamic>));
    }
    if (data.containsKey('requestId')) {
      final l$requestId = data['requestId'];
      result$data['requestId'] = l$requestId == null
          ? null
          : Input$SortOrderInput.fromJson(
              (l$requestId as Map<String, dynamic>));
    }
    if (data.containsKey('systemPrompt')) {
      final l$systemPrompt = data['systemPrompt'];
      result$data['systemPrompt'] = l$systemPrompt == null
          ? null
          : Input$SortOrderInput.fromJson(
              (l$systemPrompt as Map<String, dynamic>));
    }
    if (data.containsKey('totalTokens')) {
      final l$totalTokens = data['totalTokens'];
      result$data['totalTokens'] = l$totalTokens == null
          ? null
          : Input$SortOrderInput.fromJson(
              (l$totalTokens as Map<String, dynamic>));
    }
    if (data.containsKey('updatedAt')) {
      final l$updatedAt = data['updatedAt'];
      result$data['updatedAt'] = l$updatedAt == null
          ? null
          : fromJson$Enum$SortOrder((l$updatedAt as String));
    }
    if (data.containsKey('userPrompt')) {
      final l$userPrompt = data['userPrompt'];
      result$data['userPrompt'] = l$userPrompt == null
          ? null
          : Input$SortOrderInput.fromJson(
              (l$userPrompt as Map<String, dynamic>));
    }
    if (data.containsKey('uuid')) {
      final l$uuid = data['uuid'];
      result$data['uuid'] =
          l$uuid == null ? null : fromJson$Enum$SortOrder((l$uuid as String));
    }
    return Input$BookRevisionOrderByWithAggregationInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$BookRevisionAvgOrderByAggregateInput? get $_avg =>
      (_$data['_avg'] as Input$BookRevisionAvgOrderByAggregateInput?);

  Input$BookRevisionCountOrderByAggregateInput? get $_count =>
      (_$data['_count'] as Input$BookRevisionCountOrderByAggregateInput?);

  Input$BookRevisionMaxOrderByAggregateInput? get $_max =>
      (_$data['_max'] as Input$BookRevisionMaxOrderByAggregateInput?);

  Input$BookRevisionMinOrderByAggregateInput? get $_min =>
      (_$data['_min'] as Input$BookRevisionMinOrderByAggregateInput?);

  Input$BookRevisionSumOrderByAggregateInput? get $_sum =>
      (_$data['_sum'] as Input$BookRevisionSumOrderByAggregateInput?);

  Input$SortOrderInput? get bookEditedId =>
      (_$data['bookEditedId'] as Input$SortOrderInput?);

  Input$SortOrderInput? get bookRawId =>
      (_$data['bookRawId'] as Input$SortOrderInput?);

  Input$SortOrderInput? get completionTokens =>
      (_$data['completionTokens'] as Input$SortOrderInput?);

  Enum$SortOrder? get content => (_$data['content'] as Enum$SortOrder?);

  Enum$SortOrder? get createdAt => (_$data['createdAt'] as Enum$SortOrder?);

  Enum$SortOrder? get isRaw => (_$data['isRaw'] as Enum$SortOrder?);

  Input$SortOrderInput? get model => (_$data['model'] as Input$SortOrderInput?);

  Input$SortOrderInput? get promptTokens =>
      (_$data['promptTokens'] as Input$SortOrderInput?);

  Input$SortOrderInput? get raw => (_$data['raw'] as Input$SortOrderInput?);

  Input$SortOrderInput? get requestId =>
      (_$data['requestId'] as Input$SortOrderInput?);

  Input$SortOrderInput? get systemPrompt =>
      (_$data['systemPrompt'] as Input$SortOrderInput?);

  Input$SortOrderInput? get totalTokens =>
      (_$data['totalTokens'] as Input$SortOrderInput?);

  Enum$SortOrder? get updatedAt => (_$data['updatedAt'] as Enum$SortOrder?);

  Input$SortOrderInput? get userPrompt =>
      (_$data['userPrompt'] as Input$SortOrderInput?);

  Enum$SortOrder? get uuid => (_$data['uuid'] as Enum$SortOrder?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('_avg')) {
      final l$$_avg = $_avg;
      result$data['_avg'] = l$$_avg?.toJson();
    }
    if (_$data.containsKey('_count')) {
      final l$$_count = $_count;
      result$data['_count'] = l$$_count?.toJson();
    }
    if (_$data.containsKey('_max')) {
      final l$$_max = $_max;
      result$data['_max'] = l$$_max?.toJson();
    }
    if (_$data.containsKey('_min')) {
      final l$$_min = $_min;
      result$data['_min'] = l$$_min?.toJson();
    }
    if (_$data.containsKey('_sum')) {
      final l$$_sum = $_sum;
      result$data['_sum'] = l$$_sum?.toJson();
    }
    if (_$data.containsKey('bookEditedId')) {
      final l$bookEditedId = bookEditedId;
      result$data['bookEditedId'] = l$bookEditedId?.toJson();
    }
    if (_$data.containsKey('bookRawId')) {
      final l$bookRawId = bookRawId;
      result$data['bookRawId'] = l$bookRawId?.toJson();
    }
    if (_$data.containsKey('completionTokens')) {
      final l$completionTokens = completionTokens;
      result$data['completionTokens'] = l$completionTokens?.toJson();
    }
    if (_$data.containsKey('content')) {
      final l$content = content;
      result$data['content'] =
          l$content == null ? null : toJson$Enum$SortOrder(l$content);
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] =
          l$createdAt == null ? null : toJson$Enum$SortOrder(l$createdAt);
    }
    if (_$data.containsKey('isRaw')) {
      final l$isRaw = isRaw;
      result$data['isRaw'] =
          l$isRaw == null ? null : toJson$Enum$SortOrder(l$isRaw);
    }
    if (_$data.containsKey('model')) {
      final l$model = model;
      result$data['model'] = l$model?.toJson();
    }
    if (_$data.containsKey('promptTokens')) {
      final l$promptTokens = promptTokens;
      result$data['promptTokens'] = l$promptTokens?.toJson();
    }
    if (_$data.containsKey('raw')) {
      final l$raw = raw;
      result$data['raw'] = l$raw?.toJson();
    }
    if (_$data.containsKey('requestId')) {
      final l$requestId = requestId;
      result$data['requestId'] = l$requestId?.toJson();
    }
    if (_$data.containsKey('systemPrompt')) {
      final l$systemPrompt = systemPrompt;
      result$data['systemPrompt'] = l$systemPrompt?.toJson();
    }
    if (_$data.containsKey('totalTokens')) {
      final l$totalTokens = totalTokens;
      result$data['totalTokens'] = l$totalTokens?.toJson();
    }
    if (_$data.containsKey('updatedAt')) {
      final l$updatedAt = updatedAt;
      result$data['updatedAt'] =
          l$updatedAt == null ? null : toJson$Enum$SortOrder(l$updatedAt);
    }
    if (_$data.containsKey('userPrompt')) {
      final l$userPrompt = userPrompt;
      result$data['userPrompt'] = l$userPrompt?.toJson();
    }
    if (_$data.containsKey('uuid')) {
      final l$uuid = uuid;
      result$data['uuid'] =
          l$uuid == null ? null : toJson$Enum$SortOrder(l$uuid);
    }
    return result$data;
  }

  CopyWith$Input$BookRevisionOrderByWithAggregationInput<
          Input$BookRevisionOrderByWithAggregationInput>
      get copyWith => CopyWith$Input$BookRevisionOrderByWithAggregationInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$BookRevisionOrderByWithAggregationInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$$_avg = $_avg;
    final lOther$$_avg = other.$_avg;
    if (_$data.containsKey('_avg') != other._$data.containsKey('_avg')) {
      return false;
    }
    if (l$$_avg != lOther$$_avg) {
      return false;
    }
    final l$$_count = $_count;
    final lOther$$_count = other.$_count;
    if (_$data.containsKey('_count') != other._$data.containsKey('_count')) {
      return false;
    }
    if (l$$_count != lOther$$_count) {
      return false;
    }
    final l$$_max = $_max;
    final lOther$$_max = other.$_max;
    if (_$data.containsKey('_max') != other._$data.containsKey('_max')) {
      return false;
    }
    if (l$$_max != lOther$$_max) {
      return false;
    }
    final l$$_min = $_min;
    final lOther$$_min = other.$_min;
    if (_$data.containsKey('_min') != other._$data.containsKey('_min')) {
      return false;
    }
    if (l$$_min != lOther$$_min) {
      return false;
    }
    final l$$_sum = $_sum;
    final lOther$$_sum = other.$_sum;
    if (_$data.containsKey('_sum') != other._$data.containsKey('_sum')) {
      return false;
    }
    if (l$$_sum != lOther$$_sum) {
      return false;
    }
    final l$bookEditedId = bookEditedId;
    final lOther$bookEditedId = other.bookEditedId;
    if (_$data.containsKey('bookEditedId') !=
        other._$data.containsKey('bookEditedId')) {
      return false;
    }
    if (l$bookEditedId != lOther$bookEditedId) {
      return false;
    }
    final l$bookRawId = bookRawId;
    final lOther$bookRawId = other.bookRawId;
    if (_$data.containsKey('bookRawId') !=
        other._$data.containsKey('bookRawId')) {
      return false;
    }
    if (l$bookRawId != lOther$bookRawId) {
      return false;
    }
    final l$completionTokens = completionTokens;
    final lOther$completionTokens = other.completionTokens;
    if (_$data.containsKey('completionTokens') !=
        other._$data.containsKey('completionTokens')) {
      return false;
    }
    if (l$completionTokens != lOther$completionTokens) {
      return false;
    }
    final l$content = content;
    final lOther$content = other.content;
    if (_$data.containsKey('content') != other._$data.containsKey('content')) {
      return false;
    }
    if (l$content != lOther$content) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$isRaw = isRaw;
    final lOther$isRaw = other.isRaw;
    if (_$data.containsKey('isRaw') != other._$data.containsKey('isRaw')) {
      return false;
    }
    if (l$isRaw != lOther$isRaw) {
      return false;
    }
    final l$model = model;
    final lOther$model = other.model;
    if (_$data.containsKey('model') != other._$data.containsKey('model')) {
      return false;
    }
    if (l$model != lOther$model) {
      return false;
    }
    final l$promptTokens = promptTokens;
    final lOther$promptTokens = other.promptTokens;
    if (_$data.containsKey('promptTokens') !=
        other._$data.containsKey('promptTokens')) {
      return false;
    }
    if (l$promptTokens != lOther$promptTokens) {
      return false;
    }
    final l$raw = raw;
    final lOther$raw = other.raw;
    if (_$data.containsKey('raw') != other._$data.containsKey('raw')) {
      return false;
    }
    if (l$raw != lOther$raw) {
      return false;
    }
    final l$requestId = requestId;
    final lOther$requestId = other.requestId;
    if (_$data.containsKey('requestId') !=
        other._$data.containsKey('requestId')) {
      return false;
    }
    if (l$requestId != lOther$requestId) {
      return false;
    }
    final l$systemPrompt = systemPrompt;
    final lOther$systemPrompt = other.systemPrompt;
    if (_$data.containsKey('systemPrompt') !=
        other._$data.containsKey('systemPrompt')) {
      return false;
    }
    if (l$systemPrompt != lOther$systemPrompt) {
      return false;
    }
    final l$totalTokens = totalTokens;
    final lOther$totalTokens = other.totalTokens;
    if (_$data.containsKey('totalTokens') !=
        other._$data.containsKey('totalTokens')) {
      return false;
    }
    if (l$totalTokens != lOther$totalTokens) {
      return false;
    }
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (_$data.containsKey('updatedAt') !=
        other._$data.containsKey('updatedAt')) {
      return false;
    }
    if (l$updatedAt != lOther$updatedAt) {
      return false;
    }
    final l$userPrompt = userPrompt;
    final lOther$userPrompt = other.userPrompt;
    if (_$data.containsKey('userPrompt') !=
        other._$data.containsKey('userPrompt')) {
      return false;
    }
    if (l$userPrompt != lOther$userPrompt) {
      return false;
    }
    final l$uuid = uuid;
    final lOther$uuid = other.uuid;
    if (_$data.containsKey('uuid') != other._$data.containsKey('uuid')) {
      return false;
    }
    if (l$uuid != lOther$uuid) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$$_avg = $_avg;
    final l$$_count = $_count;
    final l$$_max = $_max;
    final l$$_min = $_min;
    final l$$_sum = $_sum;
    final l$bookEditedId = bookEditedId;
    final l$bookRawId = bookRawId;
    final l$completionTokens = completionTokens;
    final l$content = content;
    final l$createdAt = createdAt;
    final l$isRaw = isRaw;
    final l$model = model;
    final l$promptTokens = promptTokens;
    final l$raw = raw;
    final l$requestId = requestId;
    final l$systemPrompt = systemPrompt;
    final l$totalTokens = totalTokens;
    final l$updatedAt = updatedAt;
    final l$userPrompt = userPrompt;
    final l$uuid = uuid;
    return Object.hashAll([
      _$data.containsKey('_avg') ? l$$_avg : const {},
      _$data.containsKey('_count') ? l$$_count : const {},
      _$data.containsKey('_max') ? l$$_max : const {},
      _$data.containsKey('_min') ? l$$_min : const {},
      _$data.containsKey('_sum') ? l$$_sum : const {},
      _$data.containsKey('bookEditedId') ? l$bookEditedId : const {},
      _$data.containsKey('bookRawId') ? l$bookRawId : const {},
      _$data.containsKey('completionTokens') ? l$completionTokens : const {},
      _$data.containsKey('content') ? l$content : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('isRaw') ? l$isRaw : const {},
      _$data.containsKey('model') ? l$model : const {},
      _$data.containsKey('promptTokens') ? l$promptTokens : const {},
      _$data.containsKey('raw') ? l$raw : const {},
      _$data.containsKey('requestId') ? l$requestId : const {},
      _$data.containsKey('systemPrompt') ? l$systemPrompt : const {},
      _$data.containsKey('totalTokens') ? l$totalTokens : const {},
      _$data.containsKey('updatedAt') ? l$updatedAt : const {},
      _$data.containsKey('userPrompt') ? l$userPrompt : const {},
      _$data.containsKey('uuid') ? l$uuid : const {},
    ]);
  }
}

abstract class CopyWith$Input$BookRevisionOrderByWithAggregationInput<TRes> {
  factory CopyWith$Input$BookRevisionOrderByWithAggregationInput(
    Input$BookRevisionOrderByWithAggregationInput instance,
    TRes Function(Input$BookRevisionOrderByWithAggregationInput) then,
  ) = _CopyWithImpl$Input$BookRevisionOrderByWithAggregationInput;

  factory CopyWith$Input$BookRevisionOrderByWithAggregationInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$BookRevisionOrderByWithAggregationInput;

  TRes call({
    Input$BookRevisionAvgOrderByAggregateInput? $_avg,
    Input$BookRevisionCountOrderByAggregateInput? $_count,
    Input$BookRevisionMaxOrderByAggregateInput? $_max,
    Input$BookRevisionMinOrderByAggregateInput? $_min,
    Input$BookRevisionSumOrderByAggregateInput? $_sum,
    Input$SortOrderInput? bookEditedId,
    Input$SortOrderInput? bookRawId,
    Input$SortOrderInput? completionTokens,
    Enum$SortOrder? content,
    Enum$SortOrder? createdAt,
    Enum$SortOrder? isRaw,
    Input$SortOrderInput? model,
    Input$SortOrderInput? promptTokens,
    Input$SortOrderInput? raw,
    Input$SortOrderInput? requestId,
    Input$SortOrderInput? systemPrompt,
    Input$SortOrderInput? totalTokens,
    Enum$SortOrder? updatedAt,
    Input$SortOrderInput? userPrompt,
    Enum$SortOrder? uuid,
  });
  CopyWith$Input$BookRevisionAvgOrderByAggregateInput<TRes> get $_avg;
  CopyWith$Input$BookRevisionCountOrderByAggregateInput<TRes> get $_count;
  CopyWith$Input$BookRevisionMaxOrderByAggregateInput<TRes> get $_max;
  CopyWith$Input$BookRevisionMinOrderByAggregateInput<TRes> get $_min;
  CopyWith$Input$BookRevisionSumOrderByAggregateInput<TRes> get $_sum;
  CopyWith$Input$SortOrderInput<TRes> get bookEditedId;
  CopyWith$Input$SortOrderInput<TRes> get bookRawId;
  CopyWith$Input$SortOrderInput<TRes> get completionTokens;
  CopyWith$Input$SortOrderInput<TRes> get model;
  CopyWith$Input$SortOrderInput<TRes> get promptTokens;
  CopyWith$Input$SortOrderInput<TRes> get raw;
  CopyWith$Input$SortOrderInput<TRes> get requestId;
  CopyWith$Input$SortOrderInput<TRes> get systemPrompt;
  CopyWith$Input$SortOrderInput<TRes> get totalTokens;
  CopyWith$Input$SortOrderInput<TRes> get userPrompt;
}

class _CopyWithImpl$Input$BookRevisionOrderByWithAggregationInput<TRes>
    implements CopyWith$Input$BookRevisionOrderByWithAggregationInput<TRes> {
  _CopyWithImpl$Input$BookRevisionOrderByWithAggregationInput(
    this._instance,
    this._then,
  );

  final Input$BookRevisionOrderByWithAggregationInput _instance;

  final TRes Function(Input$BookRevisionOrderByWithAggregationInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? $_avg = _undefined,
    Object? $_count = _undefined,
    Object? $_max = _undefined,
    Object? $_min = _undefined,
    Object? $_sum = _undefined,
    Object? bookEditedId = _undefined,
    Object? bookRawId = _undefined,
    Object? completionTokens = _undefined,
    Object? content = _undefined,
    Object? createdAt = _undefined,
    Object? isRaw = _undefined,
    Object? model = _undefined,
    Object? promptTokens = _undefined,
    Object? raw = _undefined,
    Object? requestId = _undefined,
    Object? systemPrompt = _undefined,
    Object? totalTokens = _undefined,
    Object? updatedAt = _undefined,
    Object? userPrompt = _undefined,
    Object? uuid = _undefined,
  }) =>
      _then(Input$BookRevisionOrderByWithAggregationInput._({
        ..._instance._$data,
        if ($_avg != _undefined)
          '_avg': ($_avg as Input$BookRevisionAvgOrderByAggregateInput?),
        if ($_count != _undefined)
          '_count': ($_count as Input$BookRevisionCountOrderByAggregateInput?),
        if ($_max != _undefined)
          '_max': ($_max as Input$BookRevisionMaxOrderByAggregateInput?),
        if ($_min != _undefined)
          '_min': ($_min as Input$BookRevisionMinOrderByAggregateInput?),
        if ($_sum != _undefined)
          '_sum': ($_sum as Input$BookRevisionSumOrderByAggregateInput?),
        if (bookEditedId != _undefined)
          'bookEditedId': (bookEditedId as Input$SortOrderInput?),
        if (bookRawId != _undefined)
          'bookRawId': (bookRawId as Input$SortOrderInput?),
        if (completionTokens != _undefined)
          'completionTokens': (completionTokens as Input$SortOrderInput?),
        if (content != _undefined) 'content': (content as Enum$SortOrder?),
        if (createdAt != _undefined)
          'createdAt': (createdAt as Enum$SortOrder?),
        if (isRaw != _undefined) 'isRaw': (isRaw as Enum$SortOrder?),
        if (model != _undefined) 'model': (model as Input$SortOrderInput?),
        if (promptTokens != _undefined)
          'promptTokens': (promptTokens as Input$SortOrderInput?),
        if (raw != _undefined) 'raw': (raw as Input$SortOrderInput?),
        if (requestId != _undefined)
          'requestId': (requestId as Input$SortOrderInput?),
        if (systemPrompt != _undefined)
          'systemPrompt': (systemPrompt as Input$SortOrderInput?),
        if (totalTokens != _undefined)
          'totalTokens': (totalTokens as Input$SortOrderInput?),
        if (updatedAt != _undefined)
          'updatedAt': (updatedAt as Enum$SortOrder?),
        if (userPrompt != _undefined)
          'userPrompt': (userPrompt as Input$SortOrderInput?),
        if (uuid != _undefined) 'uuid': (uuid as Enum$SortOrder?),
      }));

  CopyWith$Input$BookRevisionAvgOrderByAggregateInput<TRes> get $_avg {
    final local$$_avg = _instance.$_avg;
    return local$$_avg == null
        ? CopyWith$Input$BookRevisionAvgOrderByAggregateInput.stub(
            _then(_instance))
        : CopyWith$Input$BookRevisionAvgOrderByAggregateInput(
            local$$_avg, (e) => call($_avg: e));
  }

  CopyWith$Input$BookRevisionCountOrderByAggregateInput<TRes> get $_count {
    final local$$_count = _instance.$_count;
    return local$$_count == null
        ? CopyWith$Input$BookRevisionCountOrderByAggregateInput.stub(
            _then(_instance))
        : CopyWith$Input$BookRevisionCountOrderByAggregateInput(
            local$$_count, (e) => call($_count: e));
  }

  CopyWith$Input$BookRevisionMaxOrderByAggregateInput<TRes> get $_max {
    final local$$_max = _instance.$_max;
    return local$$_max == null
        ? CopyWith$Input$BookRevisionMaxOrderByAggregateInput.stub(
            _then(_instance))
        : CopyWith$Input$BookRevisionMaxOrderByAggregateInput(
            local$$_max, (e) => call($_max: e));
  }

  CopyWith$Input$BookRevisionMinOrderByAggregateInput<TRes> get $_min {
    final local$$_min = _instance.$_min;
    return local$$_min == null
        ? CopyWith$Input$BookRevisionMinOrderByAggregateInput.stub(
            _then(_instance))
        : CopyWith$Input$BookRevisionMinOrderByAggregateInput(
            local$$_min, (e) => call($_min: e));
  }

  CopyWith$Input$BookRevisionSumOrderByAggregateInput<TRes> get $_sum {
    final local$$_sum = _instance.$_sum;
    return local$$_sum == null
        ? CopyWith$Input$BookRevisionSumOrderByAggregateInput.stub(
            _then(_instance))
        : CopyWith$Input$BookRevisionSumOrderByAggregateInput(
            local$$_sum, (e) => call($_sum: e));
  }

  CopyWith$Input$SortOrderInput<TRes> get bookEditedId {
    final local$bookEditedId = _instance.bookEditedId;
    return local$bookEditedId == null
        ? CopyWith$Input$SortOrderInput.stub(_then(_instance))
        : CopyWith$Input$SortOrderInput(
            local$bookEditedId, (e) => call(bookEditedId: e));
  }

  CopyWith$Input$SortOrderInput<TRes> get bookRawId {
    final local$bookRawId = _instance.bookRawId;
    return local$bookRawId == null
        ? CopyWith$Input$SortOrderInput.stub(_then(_instance))
        : CopyWith$Input$SortOrderInput(
            local$bookRawId, (e) => call(bookRawId: e));
  }

  CopyWith$Input$SortOrderInput<TRes> get completionTokens {
    final local$completionTokens = _instance.completionTokens;
    return local$completionTokens == null
        ? CopyWith$Input$SortOrderInput.stub(_then(_instance))
        : CopyWith$Input$SortOrderInput(
            local$completionTokens, (e) => call(completionTokens: e));
  }

  CopyWith$Input$SortOrderInput<TRes> get model {
    final local$model = _instance.model;
    return local$model == null
        ? CopyWith$Input$SortOrderInput.stub(_then(_instance))
        : CopyWith$Input$SortOrderInput(local$model, (e) => call(model: e));
  }

  CopyWith$Input$SortOrderInput<TRes> get promptTokens {
    final local$promptTokens = _instance.promptTokens;
    return local$promptTokens == null
        ? CopyWith$Input$SortOrderInput.stub(_then(_instance))
        : CopyWith$Input$SortOrderInput(
            local$promptTokens, (e) => call(promptTokens: e));
  }

  CopyWith$Input$SortOrderInput<TRes> get raw {
    final local$raw = _instance.raw;
    return local$raw == null
        ? CopyWith$Input$SortOrderInput.stub(_then(_instance))
        : CopyWith$Input$SortOrderInput(local$raw, (e) => call(raw: e));
  }

  CopyWith$Input$SortOrderInput<TRes> get requestId {
    final local$requestId = _instance.requestId;
    return local$requestId == null
        ? CopyWith$Input$SortOrderInput.stub(_then(_instance))
        : CopyWith$Input$SortOrderInput(
            local$requestId, (e) => call(requestId: e));
  }

  CopyWith$Input$SortOrderInput<TRes> get systemPrompt {
    final local$systemPrompt = _instance.systemPrompt;
    return local$systemPrompt == null
        ? CopyWith$Input$SortOrderInput.stub(_then(_instance))
        : CopyWith$Input$SortOrderInput(
            local$systemPrompt, (e) => call(systemPrompt: e));
  }

  CopyWith$Input$SortOrderInput<TRes> get totalTokens {
    final local$totalTokens = _instance.totalTokens;
    return local$totalTokens == null
        ? CopyWith$Input$SortOrderInput.stub(_then(_instance))
        : CopyWith$Input$SortOrderInput(
            local$totalTokens, (e) => call(totalTokens: e));
  }

  CopyWith$Input$SortOrderInput<TRes> get userPrompt {
    final local$userPrompt = _instance.userPrompt;
    return local$userPrompt == null
        ? CopyWith$Input$SortOrderInput.stub(_then(_instance))
        : CopyWith$Input$SortOrderInput(
            local$userPrompt, (e) => call(userPrompt: e));
  }
}

class _CopyWithStubImpl$Input$BookRevisionOrderByWithAggregationInput<TRes>
    implements CopyWith$Input$BookRevisionOrderByWithAggregationInput<TRes> {
  _CopyWithStubImpl$Input$BookRevisionOrderByWithAggregationInput(this._res);

  TRes _res;

  call({
    Input$BookRevisionAvgOrderByAggregateInput? $_avg,
    Input$BookRevisionCountOrderByAggregateInput? $_count,
    Input$BookRevisionMaxOrderByAggregateInput? $_max,
    Input$BookRevisionMinOrderByAggregateInput? $_min,
    Input$BookRevisionSumOrderByAggregateInput? $_sum,
    Input$SortOrderInput? bookEditedId,
    Input$SortOrderInput? bookRawId,
    Input$SortOrderInput? completionTokens,
    Enum$SortOrder? content,
    Enum$SortOrder? createdAt,
    Enum$SortOrder? isRaw,
    Input$SortOrderInput? model,
    Input$SortOrderInput? promptTokens,
    Input$SortOrderInput? raw,
    Input$SortOrderInput? requestId,
    Input$SortOrderInput? systemPrompt,
    Input$SortOrderInput? totalTokens,
    Enum$SortOrder? updatedAt,
    Input$SortOrderInput? userPrompt,
    Enum$SortOrder? uuid,
  }) =>
      _res;

  CopyWith$Input$BookRevisionAvgOrderByAggregateInput<TRes> get $_avg =>
      CopyWith$Input$BookRevisionAvgOrderByAggregateInput.stub(_res);

  CopyWith$Input$BookRevisionCountOrderByAggregateInput<TRes> get $_count =>
      CopyWith$Input$BookRevisionCountOrderByAggregateInput.stub(_res);

  CopyWith$Input$BookRevisionMaxOrderByAggregateInput<TRes> get $_max =>
      CopyWith$Input$BookRevisionMaxOrderByAggregateInput.stub(_res);

  CopyWith$Input$BookRevisionMinOrderByAggregateInput<TRes> get $_min =>
      CopyWith$Input$BookRevisionMinOrderByAggregateInput.stub(_res);

  CopyWith$Input$BookRevisionSumOrderByAggregateInput<TRes> get $_sum =>
      CopyWith$Input$BookRevisionSumOrderByAggregateInput.stub(_res);

  CopyWith$Input$SortOrderInput<TRes> get bookEditedId =>
      CopyWith$Input$SortOrderInput.stub(_res);

  CopyWith$Input$SortOrderInput<TRes> get bookRawId =>
      CopyWith$Input$SortOrderInput.stub(_res);

  CopyWith$Input$SortOrderInput<TRes> get completionTokens =>
      CopyWith$Input$SortOrderInput.stub(_res);

  CopyWith$Input$SortOrderInput<TRes> get model =>
      CopyWith$Input$SortOrderInput.stub(_res);

  CopyWith$Input$SortOrderInput<TRes> get promptTokens =>
      CopyWith$Input$SortOrderInput.stub(_res);

  CopyWith$Input$SortOrderInput<TRes> get raw =>
      CopyWith$Input$SortOrderInput.stub(_res);

  CopyWith$Input$SortOrderInput<TRes> get requestId =>
      CopyWith$Input$SortOrderInput.stub(_res);

  CopyWith$Input$SortOrderInput<TRes> get systemPrompt =>
      CopyWith$Input$SortOrderInput.stub(_res);

  CopyWith$Input$SortOrderInput<TRes> get totalTokens =>
      CopyWith$Input$SortOrderInput.stub(_res);

  CopyWith$Input$SortOrderInput<TRes> get userPrompt =>
      CopyWith$Input$SortOrderInput.stub(_res);
}

class Input$BookRevisionOrderByWithRelationInput {
  factory Input$BookRevisionOrderByWithRelationInput({
    Input$BookOrderByWithRelationInput? bookEdited,
    Input$SortOrderInput? bookEditedId,
    Input$BookOrderByWithRelationInput? bookRaw,
    Input$SortOrderInput? bookRawId,
    Input$SortOrderInput? completionTokens,
    Enum$SortOrder? content,
    Enum$SortOrder? createdAt,
    Enum$SortOrder? isRaw,
    Input$SortOrderInput? model,
    Input$SortOrderInput? promptTokens,
    Input$SortOrderInput? raw,
    Input$SortOrderInput? requestId,
    Input$SortOrderInput? systemPrompt,
    Input$SortOrderInput? totalTokens,
    Enum$SortOrder? updatedAt,
    Input$SortOrderInput? userPrompt,
    Enum$SortOrder? uuid,
  }) =>
      Input$BookRevisionOrderByWithRelationInput._({
        if (bookEdited != null) r'bookEdited': bookEdited,
        if (bookEditedId != null) r'bookEditedId': bookEditedId,
        if (bookRaw != null) r'bookRaw': bookRaw,
        if (bookRawId != null) r'bookRawId': bookRawId,
        if (completionTokens != null) r'completionTokens': completionTokens,
        if (content != null) r'content': content,
        if (createdAt != null) r'createdAt': createdAt,
        if (isRaw != null) r'isRaw': isRaw,
        if (model != null) r'model': model,
        if (promptTokens != null) r'promptTokens': promptTokens,
        if (raw != null) r'raw': raw,
        if (requestId != null) r'requestId': requestId,
        if (systemPrompt != null) r'systemPrompt': systemPrompt,
        if (totalTokens != null) r'totalTokens': totalTokens,
        if (updatedAt != null) r'updatedAt': updatedAt,
        if (userPrompt != null) r'userPrompt': userPrompt,
        if (uuid != null) r'uuid': uuid,
      });

  Input$BookRevisionOrderByWithRelationInput._(this._$data);

  factory Input$BookRevisionOrderByWithRelationInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('bookEdited')) {
      final l$bookEdited = data['bookEdited'];
      result$data['bookEdited'] = l$bookEdited == null
          ? null
          : Input$BookOrderByWithRelationInput.fromJson(
              (l$bookEdited as Map<String, dynamic>));
    }
    if (data.containsKey('bookEditedId')) {
      final l$bookEditedId = data['bookEditedId'];
      result$data['bookEditedId'] = l$bookEditedId == null
          ? null
          : Input$SortOrderInput.fromJson(
              (l$bookEditedId as Map<String, dynamic>));
    }
    if (data.containsKey('bookRaw')) {
      final l$bookRaw = data['bookRaw'];
      result$data['bookRaw'] = l$bookRaw == null
          ? null
          : Input$BookOrderByWithRelationInput.fromJson(
              (l$bookRaw as Map<String, dynamic>));
    }
    if (data.containsKey('bookRawId')) {
      final l$bookRawId = data['bookRawId'];
      result$data['bookRawId'] = l$bookRawId == null
          ? null
          : Input$SortOrderInput.fromJson(
              (l$bookRawId as Map<String, dynamic>));
    }
    if (data.containsKey('completionTokens')) {
      final l$completionTokens = data['completionTokens'];
      result$data['completionTokens'] = l$completionTokens == null
          ? null
          : Input$SortOrderInput.fromJson(
              (l$completionTokens as Map<String, dynamic>));
    }
    if (data.containsKey('content')) {
      final l$content = data['content'];
      result$data['content'] = l$content == null
          ? null
          : fromJson$Enum$SortOrder((l$content as String));
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : fromJson$Enum$SortOrder((l$createdAt as String));
    }
    if (data.containsKey('isRaw')) {
      final l$isRaw = data['isRaw'];
      result$data['isRaw'] =
          l$isRaw == null ? null : fromJson$Enum$SortOrder((l$isRaw as String));
    }
    if (data.containsKey('model')) {
      final l$model = data['model'];
      result$data['model'] = l$model == null
          ? null
          : Input$SortOrderInput.fromJson((l$model as Map<String, dynamic>));
    }
    if (data.containsKey('promptTokens')) {
      final l$promptTokens = data['promptTokens'];
      result$data['promptTokens'] = l$promptTokens == null
          ? null
          : Input$SortOrderInput.fromJson(
              (l$promptTokens as Map<String, dynamic>));
    }
    if (data.containsKey('raw')) {
      final l$raw = data['raw'];
      result$data['raw'] = l$raw == null
          ? null
          : Input$SortOrderInput.fromJson((l$raw as Map<String, dynamic>));
    }
    if (data.containsKey('requestId')) {
      final l$requestId = data['requestId'];
      result$data['requestId'] = l$requestId == null
          ? null
          : Input$SortOrderInput.fromJson(
              (l$requestId as Map<String, dynamic>));
    }
    if (data.containsKey('systemPrompt')) {
      final l$systemPrompt = data['systemPrompt'];
      result$data['systemPrompt'] = l$systemPrompt == null
          ? null
          : Input$SortOrderInput.fromJson(
              (l$systemPrompt as Map<String, dynamic>));
    }
    if (data.containsKey('totalTokens')) {
      final l$totalTokens = data['totalTokens'];
      result$data['totalTokens'] = l$totalTokens == null
          ? null
          : Input$SortOrderInput.fromJson(
              (l$totalTokens as Map<String, dynamic>));
    }
    if (data.containsKey('updatedAt')) {
      final l$updatedAt = data['updatedAt'];
      result$data['updatedAt'] = l$updatedAt == null
          ? null
          : fromJson$Enum$SortOrder((l$updatedAt as String));
    }
    if (data.containsKey('userPrompt')) {
      final l$userPrompt = data['userPrompt'];
      result$data['userPrompt'] = l$userPrompt == null
          ? null
          : Input$SortOrderInput.fromJson(
              (l$userPrompt as Map<String, dynamic>));
    }
    if (data.containsKey('uuid')) {
      final l$uuid = data['uuid'];
      result$data['uuid'] =
          l$uuid == null ? null : fromJson$Enum$SortOrder((l$uuid as String));
    }
    return Input$BookRevisionOrderByWithRelationInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$BookOrderByWithRelationInput? get bookEdited =>
      (_$data['bookEdited'] as Input$BookOrderByWithRelationInput?);

  Input$SortOrderInput? get bookEditedId =>
      (_$data['bookEditedId'] as Input$SortOrderInput?);

  Input$BookOrderByWithRelationInput? get bookRaw =>
      (_$data['bookRaw'] as Input$BookOrderByWithRelationInput?);

  Input$SortOrderInput? get bookRawId =>
      (_$data['bookRawId'] as Input$SortOrderInput?);

  Input$SortOrderInput? get completionTokens =>
      (_$data['completionTokens'] as Input$SortOrderInput?);

  Enum$SortOrder? get content => (_$data['content'] as Enum$SortOrder?);

  Enum$SortOrder? get createdAt => (_$data['createdAt'] as Enum$SortOrder?);

  Enum$SortOrder? get isRaw => (_$data['isRaw'] as Enum$SortOrder?);

  Input$SortOrderInput? get model => (_$data['model'] as Input$SortOrderInput?);

  Input$SortOrderInput? get promptTokens =>
      (_$data['promptTokens'] as Input$SortOrderInput?);

  Input$SortOrderInput? get raw => (_$data['raw'] as Input$SortOrderInput?);

  Input$SortOrderInput? get requestId =>
      (_$data['requestId'] as Input$SortOrderInput?);

  Input$SortOrderInput? get systemPrompt =>
      (_$data['systemPrompt'] as Input$SortOrderInput?);

  Input$SortOrderInput? get totalTokens =>
      (_$data['totalTokens'] as Input$SortOrderInput?);

  Enum$SortOrder? get updatedAt => (_$data['updatedAt'] as Enum$SortOrder?);

  Input$SortOrderInput? get userPrompt =>
      (_$data['userPrompt'] as Input$SortOrderInput?);

  Enum$SortOrder? get uuid => (_$data['uuid'] as Enum$SortOrder?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('bookEdited')) {
      final l$bookEdited = bookEdited;
      result$data['bookEdited'] = l$bookEdited?.toJson();
    }
    if (_$data.containsKey('bookEditedId')) {
      final l$bookEditedId = bookEditedId;
      result$data['bookEditedId'] = l$bookEditedId?.toJson();
    }
    if (_$data.containsKey('bookRaw')) {
      final l$bookRaw = bookRaw;
      result$data['bookRaw'] = l$bookRaw?.toJson();
    }
    if (_$data.containsKey('bookRawId')) {
      final l$bookRawId = bookRawId;
      result$data['bookRawId'] = l$bookRawId?.toJson();
    }
    if (_$data.containsKey('completionTokens')) {
      final l$completionTokens = completionTokens;
      result$data['completionTokens'] = l$completionTokens?.toJson();
    }
    if (_$data.containsKey('content')) {
      final l$content = content;
      result$data['content'] =
          l$content == null ? null : toJson$Enum$SortOrder(l$content);
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] =
          l$createdAt == null ? null : toJson$Enum$SortOrder(l$createdAt);
    }
    if (_$data.containsKey('isRaw')) {
      final l$isRaw = isRaw;
      result$data['isRaw'] =
          l$isRaw == null ? null : toJson$Enum$SortOrder(l$isRaw);
    }
    if (_$data.containsKey('model')) {
      final l$model = model;
      result$data['model'] = l$model?.toJson();
    }
    if (_$data.containsKey('promptTokens')) {
      final l$promptTokens = promptTokens;
      result$data['promptTokens'] = l$promptTokens?.toJson();
    }
    if (_$data.containsKey('raw')) {
      final l$raw = raw;
      result$data['raw'] = l$raw?.toJson();
    }
    if (_$data.containsKey('requestId')) {
      final l$requestId = requestId;
      result$data['requestId'] = l$requestId?.toJson();
    }
    if (_$data.containsKey('systemPrompt')) {
      final l$systemPrompt = systemPrompt;
      result$data['systemPrompt'] = l$systemPrompt?.toJson();
    }
    if (_$data.containsKey('totalTokens')) {
      final l$totalTokens = totalTokens;
      result$data['totalTokens'] = l$totalTokens?.toJson();
    }
    if (_$data.containsKey('updatedAt')) {
      final l$updatedAt = updatedAt;
      result$data['updatedAt'] =
          l$updatedAt == null ? null : toJson$Enum$SortOrder(l$updatedAt);
    }
    if (_$data.containsKey('userPrompt')) {
      final l$userPrompt = userPrompt;
      result$data['userPrompt'] = l$userPrompt?.toJson();
    }
    if (_$data.containsKey('uuid')) {
      final l$uuid = uuid;
      result$data['uuid'] =
          l$uuid == null ? null : toJson$Enum$SortOrder(l$uuid);
    }
    return result$data;
  }

  CopyWith$Input$BookRevisionOrderByWithRelationInput<
          Input$BookRevisionOrderByWithRelationInput>
      get copyWith => CopyWith$Input$BookRevisionOrderByWithRelationInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$BookRevisionOrderByWithRelationInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$bookEdited = bookEdited;
    final lOther$bookEdited = other.bookEdited;
    if (_$data.containsKey('bookEdited') !=
        other._$data.containsKey('bookEdited')) {
      return false;
    }
    if (l$bookEdited != lOther$bookEdited) {
      return false;
    }
    final l$bookEditedId = bookEditedId;
    final lOther$bookEditedId = other.bookEditedId;
    if (_$data.containsKey('bookEditedId') !=
        other._$data.containsKey('bookEditedId')) {
      return false;
    }
    if (l$bookEditedId != lOther$bookEditedId) {
      return false;
    }
    final l$bookRaw = bookRaw;
    final lOther$bookRaw = other.bookRaw;
    if (_$data.containsKey('bookRaw') != other._$data.containsKey('bookRaw')) {
      return false;
    }
    if (l$bookRaw != lOther$bookRaw) {
      return false;
    }
    final l$bookRawId = bookRawId;
    final lOther$bookRawId = other.bookRawId;
    if (_$data.containsKey('bookRawId') !=
        other._$data.containsKey('bookRawId')) {
      return false;
    }
    if (l$bookRawId != lOther$bookRawId) {
      return false;
    }
    final l$completionTokens = completionTokens;
    final lOther$completionTokens = other.completionTokens;
    if (_$data.containsKey('completionTokens') !=
        other._$data.containsKey('completionTokens')) {
      return false;
    }
    if (l$completionTokens != lOther$completionTokens) {
      return false;
    }
    final l$content = content;
    final lOther$content = other.content;
    if (_$data.containsKey('content') != other._$data.containsKey('content')) {
      return false;
    }
    if (l$content != lOther$content) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$isRaw = isRaw;
    final lOther$isRaw = other.isRaw;
    if (_$data.containsKey('isRaw') != other._$data.containsKey('isRaw')) {
      return false;
    }
    if (l$isRaw != lOther$isRaw) {
      return false;
    }
    final l$model = model;
    final lOther$model = other.model;
    if (_$data.containsKey('model') != other._$data.containsKey('model')) {
      return false;
    }
    if (l$model != lOther$model) {
      return false;
    }
    final l$promptTokens = promptTokens;
    final lOther$promptTokens = other.promptTokens;
    if (_$data.containsKey('promptTokens') !=
        other._$data.containsKey('promptTokens')) {
      return false;
    }
    if (l$promptTokens != lOther$promptTokens) {
      return false;
    }
    final l$raw = raw;
    final lOther$raw = other.raw;
    if (_$data.containsKey('raw') != other._$data.containsKey('raw')) {
      return false;
    }
    if (l$raw != lOther$raw) {
      return false;
    }
    final l$requestId = requestId;
    final lOther$requestId = other.requestId;
    if (_$data.containsKey('requestId') !=
        other._$data.containsKey('requestId')) {
      return false;
    }
    if (l$requestId != lOther$requestId) {
      return false;
    }
    final l$systemPrompt = systemPrompt;
    final lOther$systemPrompt = other.systemPrompt;
    if (_$data.containsKey('systemPrompt') !=
        other._$data.containsKey('systemPrompt')) {
      return false;
    }
    if (l$systemPrompt != lOther$systemPrompt) {
      return false;
    }
    final l$totalTokens = totalTokens;
    final lOther$totalTokens = other.totalTokens;
    if (_$data.containsKey('totalTokens') !=
        other._$data.containsKey('totalTokens')) {
      return false;
    }
    if (l$totalTokens != lOther$totalTokens) {
      return false;
    }
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (_$data.containsKey('updatedAt') !=
        other._$data.containsKey('updatedAt')) {
      return false;
    }
    if (l$updatedAt != lOther$updatedAt) {
      return false;
    }
    final l$userPrompt = userPrompt;
    final lOther$userPrompt = other.userPrompt;
    if (_$data.containsKey('userPrompt') !=
        other._$data.containsKey('userPrompt')) {
      return false;
    }
    if (l$userPrompt != lOther$userPrompt) {
      return false;
    }
    final l$uuid = uuid;
    final lOther$uuid = other.uuid;
    if (_$data.containsKey('uuid') != other._$data.containsKey('uuid')) {
      return false;
    }
    if (l$uuid != lOther$uuid) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$bookEdited = bookEdited;
    final l$bookEditedId = bookEditedId;
    final l$bookRaw = bookRaw;
    final l$bookRawId = bookRawId;
    final l$completionTokens = completionTokens;
    final l$content = content;
    final l$createdAt = createdAt;
    final l$isRaw = isRaw;
    final l$model = model;
    final l$promptTokens = promptTokens;
    final l$raw = raw;
    final l$requestId = requestId;
    final l$systemPrompt = systemPrompt;
    final l$totalTokens = totalTokens;
    final l$updatedAt = updatedAt;
    final l$userPrompt = userPrompt;
    final l$uuid = uuid;
    return Object.hashAll([
      _$data.containsKey('bookEdited') ? l$bookEdited : const {},
      _$data.containsKey('bookEditedId') ? l$bookEditedId : const {},
      _$data.containsKey('bookRaw') ? l$bookRaw : const {},
      _$data.containsKey('bookRawId') ? l$bookRawId : const {},
      _$data.containsKey('completionTokens') ? l$completionTokens : const {},
      _$data.containsKey('content') ? l$content : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('isRaw') ? l$isRaw : const {},
      _$data.containsKey('model') ? l$model : const {},
      _$data.containsKey('promptTokens') ? l$promptTokens : const {},
      _$data.containsKey('raw') ? l$raw : const {},
      _$data.containsKey('requestId') ? l$requestId : const {},
      _$data.containsKey('systemPrompt') ? l$systemPrompt : const {},
      _$data.containsKey('totalTokens') ? l$totalTokens : const {},
      _$data.containsKey('updatedAt') ? l$updatedAt : const {},
      _$data.containsKey('userPrompt') ? l$userPrompt : const {},
      _$data.containsKey('uuid') ? l$uuid : const {},
    ]);
  }
}

abstract class CopyWith$Input$BookRevisionOrderByWithRelationInput<TRes> {
  factory CopyWith$Input$BookRevisionOrderByWithRelationInput(
    Input$BookRevisionOrderByWithRelationInput instance,
    TRes Function(Input$BookRevisionOrderByWithRelationInput) then,
  ) = _CopyWithImpl$Input$BookRevisionOrderByWithRelationInput;

  factory CopyWith$Input$BookRevisionOrderByWithRelationInput.stub(TRes res) =
      _CopyWithStubImpl$Input$BookRevisionOrderByWithRelationInput;

  TRes call({
    Input$BookOrderByWithRelationInput? bookEdited,
    Input$SortOrderInput? bookEditedId,
    Input$BookOrderByWithRelationInput? bookRaw,
    Input$SortOrderInput? bookRawId,
    Input$SortOrderInput? completionTokens,
    Enum$SortOrder? content,
    Enum$SortOrder? createdAt,
    Enum$SortOrder? isRaw,
    Input$SortOrderInput? model,
    Input$SortOrderInput? promptTokens,
    Input$SortOrderInput? raw,
    Input$SortOrderInput? requestId,
    Input$SortOrderInput? systemPrompt,
    Input$SortOrderInput? totalTokens,
    Enum$SortOrder? updatedAt,
    Input$SortOrderInput? userPrompt,
    Enum$SortOrder? uuid,
  });
  CopyWith$Input$BookOrderByWithRelationInput<TRes> get bookEdited;
  CopyWith$Input$SortOrderInput<TRes> get bookEditedId;
  CopyWith$Input$BookOrderByWithRelationInput<TRes> get bookRaw;
  CopyWith$Input$SortOrderInput<TRes> get bookRawId;
  CopyWith$Input$SortOrderInput<TRes> get completionTokens;
  CopyWith$Input$SortOrderInput<TRes> get model;
  CopyWith$Input$SortOrderInput<TRes> get promptTokens;
  CopyWith$Input$SortOrderInput<TRes> get raw;
  CopyWith$Input$SortOrderInput<TRes> get requestId;
  CopyWith$Input$SortOrderInput<TRes> get systemPrompt;
  CopyWith$Input$SortOrderInput<TRes> get totalTokens;
  CopyWith$Input$SortOrderInput<TRes> get userPrompt;
}

class _CopyWithImpl$Input$BookRevisionOrderByWithRelationInput<TRes>
    implements CopyWith$Input$BookRevisionOrderByWithRelationInput<TRes> {
  _CopyWithImpl$Input$BookRevisionOrderByWithRelationInput(
    this._instance,
    this._then,
  );

  final Input$BookRevisionOrderByWithRelationInput _instance;

  final TRes Function(Input$BookRevisionOrderByWithRelationInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? bookEdited = _undefined,
    Object? bookEditedId = _undefined,
    Object? bookRaw = _undefined,
    Object? bookRawId = _undefined,
    Object? completionTokens = _undefined,
    Object? content = _undefined,
    Object? createdAt = _undefined,
    Object? isRaw = _undefined,
    Object? model = _undefined,
    Object? promptTokens = _undefined,
    Object? raw = _undefined,
    Object? requestId = _undefined,
    Object? systemPrompt = _undefined,
    Object? totalTokens = _undefined,
    Object? updatedAt = _undefined,
    Object? userPrompt = _undefined,
    Object? uuid = _undefined,
  }) =>
      _then(Input$BookRevisionOrderByWithRelationInput._({
        ..._instance._$data,
        if (bookEdited != _undefined)
          'bookEdited': (bookEdited as Input$BookOrderByWithRelationInput?),
        if (bookEditedId != _undefined)
          'bookEditedId': (bookEditedId as Input$SortOrderInput?),
        if (bookRaw != _undefined)
          'bookRaw': (bookRaw as Input$BookOrderByWithRelationInput?),
        if (bookRawId != _undefined)
          'bookRawId': (bookRawId as Input$SortOrderInput?),
        if (completionTokens != _undefined)
          'completionTokens': (completionTokens as Input$SortOrderInput?),
        if (content != _undefined) 'content': (content as Enum$SortOrder?),
        if (createdAt != _undefined)
          'createdAt': (createdAt as Enum$SortOrder?),
        if (isRaw != _undefined) 'isRaw': (isRaw as Enum$SortOrder?),
        if (model != _undefined) 'model': (model as Input$SortOrderInput?),
        if (promptTokens != _undefined)
          'promptTokens': (promptTokens as Input$SortOrderInput?),
        if (raw != _undefined) 'raw': (raw as Input$SortOrderInput?),
        if (requestId != _undefined)
          'requestId': (requestId as Input$SortOrderInput?),
        if (systemPrompt != _undefined)
          'systemPrompt': (systemPrompt as Input$SortOrderInput?),
        if (totalTokens != _undefined)
          'totalTokens': (totalTokens as Input$SortOrderInput?),
        if (updatedAt != _undefined)
          'updatedAt': (updatedAt as Enum$SortOrder?),
        if (userPrompt != _undefined)
          'userPrompt': (userPrompt as Input$SortOrderInput?),
        if (uuid != _undefined) 'uuid': (uuid as Enum$SortOrder?),
      }));

  CopyWith$Input$BookOrderByWithRelationInput<TRes> get bookEdited {
    final local$bookEdited = _instance.bookEdited;
    return local$bookEdited == null
        ? CopyWith$Input$BookOrderByWithRelationInput.stub(_then(_instance))
        : CopyWith$Input$BookOrderByWithRelationInput(
            local$bookEdited, (e) => call(bookEdited: e));
  }

  CopyWith$Input$SortOrderInput<TRes> get bookEditedId {
    final local$bookEditedId = _instance.bookEditedId;
    return local$bookEditedId == null
        ? CopyWith$Input$SortOrderInput.stub(_then(_instance))
        : CopyWith$Input$SortOrderInput(
            local$bookEditedId, (e) => call(bookEditedId: e));
  }

  CopyWith$Input$BookOrderByWithRelationInput<TRes> get bookRaw {
    final local$bookRaw = _instance.bookRaw;
    return local$bookRaw == null
        ? CopyWith$Input$BookOrderByWithRelationInput.stub(_then(_instance))
        : CopyWith$Input$BookOrderByWithRelationInput(
            local$bookRaw, (e) => call(bookRaw: e));
  }

  CopyWith$Input$SortOrderInput<TRes> get bookRawId {
    final local$bookRawId = _instance.bookRawId;
    return local$bookRawId == null
        ? CopyWith$Input$SortOrderInput.stub(_then(_instance))
        : CopyWith$Input$SortOrderInput(
            local$bookRawId, (e) => call(bookRawId: e));
  }

  CopyWith$Input$SortOrderInput<TRes> get completionTokens {
    final local$completionTokens = _instance.completionTokens;
    return local$completionTokens == null
        ? CopyWith$Input$SortOrderInput.stub(_then(_instance))
        : CopyWith$Input$SortOrderInput(
            local$completionTokens, (e) => call(completionTokens: e));
  }

  CopyWith$Input$SortOrderInput<TRes> get model {
    final local$model = _instance.model;
    return local$model == null
        ? CopyWith$Input$SortOrderInput.stub(_then(_instance))
        : CopyWith$Input$SortOrderInput(local$model, (e) => call(model: e));
  }

  CopyWith$Input$SortOrderInput<TRes> get promptTokens {
    final local$promptTokens = _instance.promptTokens;
    return local$promptTokens == null
        ? CopyWith$Input$SortOrderInput.stub(_then(_instance))
        : CopyWith$Input$SortOrderInput(
            local$promptTokens, (e) => call(promptTokens: e));
  }

  CopyWith$Input$SortOrderInput<TRes> get raw {
    final local$raw = _instance.raw;
    return local$raw == null
        ? CopyWith$Input$SortOrderInput.stub(_then(_instance))
        : CopyWith$Input$SortOrderInput(local$raw, (e) => call(raw: e));
  }

  CopyWith$Input$SortOrderInput<TRes> get requestId {
    final local$requestId = _instance.requestId;
    return local$requestId == null
        ? CopyWith$Input$SortOrderInput.stub(_then(_instance))
        : CopyWith$Input$SortOrderInput(
            local$requestId, (e) => call(requestId: e));
  }

  CopyWith$Input$SortOrderInput<TRes> get systemPrompt {
    final local$systemPrompt = _instance.systemPrompt;
    return local$systemPrompt == null
        ? CopyWith$Input$SortOrderInput.stub(_then(_instance))
        : CopyWith$Input$SortOrderInput(
            local$systemPrompt, (e) => call(systemPrompt: e));
  }

  CopyWith$Input$SortOrderInput<TRes> get totalTokens {
    final local$totalTokens = _instance.totalTokens;
    return local$totalTokens == null
        ? CopyWith$Input$SortOrderInput.stub(_then(_instance))
        : CopyWith$Input$SortOrderInput(
            local$totalTokens, (e) => call(totalTokens: e));
  }

  CopyWith$Input$SortOrderInput<TRes> get userPrompt {
    final local$userPrompt = _instance.userPrompt;
    return local$userPrompt == null
        ? CopyWith$Input$SortOrderInput.stub(_then(_instance))
        : CopyWith$Input$SortOrderInput(
            local$userPrompt, (e) => call(userPrompt: e));
  }
}

class _CopyWithStubImpl$Input$BookRevisionOrderByWithRelationInput<TRes>
    implements CopyWith$Input$BookRevisionOrderByWithRelationInput<TRes> {
  _CopyWithStubImpl$Input$BookRevisionOrderByWithRelationInput(this._res);

  TRes _res;

  call({
    Input$BookOrderByWithRelationInput? bookEdited,
    Input$SortOrderInput? bookEditedId,
    Input$BookOrderByWithRelationInput? bookRaw,
    Input$SortOrderInput? bookRawId,
    Input$SortOrderInput? completionTokens,
    Enum$SortOrder? content,
    Enum$SortOrder? createdAt,
    Enum$SortOrder? isRaw,
    Input$SortOrderInput? model,
    Input$SortOrderInput? promptTokens,
    Input$SortOrderInput? raw,
    Input$SortOrderInput? requestId,
    Input$SortOrderInput? systemPrompt,
    Input$SortOrderInput? totalTokens,
    Enum$SortOrder? updatedAt,
    Input$SortOrderInput? userPrompt,
    Enum$SortOrder? uuid,
  }) =>
      _res;

  CopyWith$Input$BookOrderByWithRelationInput<TRes> get bookEdited =>
      CopyWith$Input$BookOrderByWithRelationInput.stub(_res);

  CopyWith$Input$SortOrderInput<TRes> get bookEditedId =>
      CopyWith$Input$SortOrderInput.stub(_res);

  CopyWith$Input$BookOrderByWithRelationInput<TRes> get bookRaw =>
      CopyWith$Input$BookOrderByWithRelationInput.stub(_res);

  CopyWith$Input$SortOrderInput<TRes> get bookRawId =>
      CopyWith$Input$SortOrderInput.stub(_res);

  CopyWith$Input$SortOrderInput<TRes> get completionTokens =>
      CopyWith$Input$SortOrderInput.stub(_res);

  CopyWith$Input$SortOrderInput<TRes> get model =>
      CopyWith$Input$SortOrderInput.stub(_res);

  CopyWith$Input$SortOrderInput<TRes> get promptTokens =>
      CopyWith$Input$SortOrderInput.stub(_res);

  CopyWith$Input$SortOrderInput<TRes> get raw =>
      CopyWith$Input$SortOrderInput.stub(_res);

  CopyWith$Input$SortOrderInput<TRes> get requestId =>
      CopyWith$Input$SortOrderInput.stub(_res);

  CopyWith$Input$SortOrderInput<TRes> get systemPrompt =>
      CopyWith$Input$SortOrderInput.stub(_res);

  CopyWith$Input$SortOrderInput<TRes> get totalTokens =>
      CopyWith$Input$SortOrderInput.stub(_res);

  CopyWith$Input$SortOrderInput<TRes> get userPrompt =>
      CopyWith$Input$SortOrderInput.stub(_res);
}

class Input$BookRevisionScalarWhereWithAggregatesInput {
  factory Input$BookRevisionScalarWhereWithAggregatesInput({
    List<Input$BookRevisionScalarWhereWithAggregatesInput>? AND,
    List<Input$BookRevisionScalarWhereWithAggregatesInput>? NOT,
    List<Input$BookRevisionScalarWhereWithAggregatesInput>? OR,
    Input$UuidNullableWithAggregatesFilter? bookEditedId,
    Input$UuidNullableWithAggregatesFilter? bookRawId,
    Input$IntNullableWithAggregatesFilter? completionTokens,
    Input$StringNullableListFilter? content,
    Input$DateTimeWithAggregatesFilter? createdAt,
    Input$BoolWithAggregatesFilter? isRaw,
    Input$StringNullableWithAggregatesFilter? model,
    Input$IntNullableWithAggregatesFilter? promptTokens,
    Input$StringNullableWithAggregatesFilter? raw,
    Input$StringNullableWithAggregatesFilter? requestId,
    Input$StringNullableWithAggregatesFilter? systemPrompt,
    Input$IntNullableWithAggregatesFilter? totalTokens,
    Input$DateTimeWithAggregatesFilter? updatedAt,
    Input$StringNullableWithAggregatesFilter? userPrompt,
    Input$UuidWithAggregatesFilter? uuid,
  }) =>
      Input$BookRevisionScalarWhereWithAggregatesInput._({
        if (AND != null) r'AND': AND,
        if (NOT != null) r'NOT': NOT,
        if (OR != null) r'OR': OR,
        if (bookEditedId != null) r'bookEditedId': bookEditedId,
        if (bookRawId != null) r'bookRawId': bookRawId,
        if (completionTokens != null) r'completionTokens': completionTokens,
        if (content != null) r'content': content,
        if (createdAt != null) r'createdAt': createdAt,
        if (isRaw != null) r'isRaw': isRaw,
        if (model != null) r'model': model,
        if (promptTokens != null) r'promptTokens': promptTokens,
        if (raw != null) r'raw': raw,
        if (requestId != null) r'requestId': requestId,
        if (systemPrompt != null) r'systemPrompt': systemPrompt,
        if (totalTokens != null) r'totalTokens': totalTokens,
        if (updatedAt != null) r'updatedAt': updatedAt,
        if (userPrompt != null) r'userPrompt': userPrompt,
        if (uuid != null) r'uuid': uuid,
      });

  Input$BookRevisionScalarWhereWithAggregatesInput._(this._$data);

  factory Input$BookRevisionScalarWhereWithAggregatesInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('AND')) {
      final l$AND = data['AND'];
      result$data['AND'] = (l$AND as List<dynamic>?)
          ?.map((e) =>
              Input$BookRevisionScalarWhereWithAggregatesInput.fromJson(
                  (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('NOT')) {
      final l$NOT = data['NOT'];
      result$data['NOT'] = (l$NOT as List<dynamic>?)
          ?.map((e) =>
              Input$BookRevisionScalarWhereWithAggregatesInput.fromJson(
                  (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('OR')) {
      final l$OR = data['OR'];
      result$data['OR'] = (l$OR as List<dynamic>?)
          ?.map((e) =>
              Input$BookRevisionScalarWhereWithAggregatesInput.fromJson(
                  (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('bookEditedId')) {
      final l$bookEditedId = data['bookEditedId'];
      result$data['bookEditedId'] = l$bookEditedId == null
          ? null
          : Input$UuidNullableWithAggregatesFilter.fromJson(
              (l$bookEditedId as Map<String, dynamic>));
    }
    if (data.containsKey('bookRawId')) {
      final l$bookRawId = data['bookRawId'];
      result$data['bookRawId'] = l$bookRawId == null
          ? null
          : Input$UuidNullableWithAggregatesFilter.fromJson(
              (l$bookRawId as Map<String, dynamic>));
    }
    if (data.containsKey('completionTokens')) {
      final l$completionTokens = data['completionTokens'];
      result$data['completionTokens'] = l$completionTokens == null
          ? null
          : Input$IntNullableWithAggregatesFilter.fromJson(
              (l$completionTokens as Map<String, dynamic>));
    }
    if (data.containsKey('content')) {
      final l$content = data['content'];
      result$data['content'] = l$content == null
          ? null
          : Input$StringNullableListFilter.fromJson(
              (l$content as Map<String, dynamic>));
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : Input$DateTimeWithAggregatesFilter.fromJson(
              (l$createdAt as Map<String, dynamic>));
    }
    if (data.containsKey('isRaw')) {
      final l$isRaw = data['isRaw'];
      result$data['isRaw'] = l$isRaw == null
          ? null
          : Input$BoolWithAggregatesFilter.fromJson(
              (l$isRaw as Map<String, dynamic>));
    }
    if (data.containsKey('model')) {
      final l$model = data['model'];
      result$data['model'] = l$model == null
          ? null
          : Input$StringNullableWithAggregatesFilter.fromJson(
              (l$model as Map<String, dynamic>));
    }
    if (data.containsKey('promptTokens')) {
      final l$promptTokens = data['promptTokens'];
      result$data['promptTokens'] = l$promptTokens == null
          ? null
          : Input$IntNullableWithAggregatesFilter.fromJson(
              (l$promptTokens as Map<String, dynamic>));
    }
    if (data.containsKey('raw')) {
      final l$raw = data['raw'];
      result$data['raw'] = l$raw == null
          ? null
          : Input$StringNullableWithAggregatesFilter.fromJson(
              (l$raw as Map<String, dynamic>));
    }
    if (data.containsKey('requestId')) {
      final l$requestId = data['requestId'];
      result$data['requestId'] = l$requestId == null
          ? null
          : Input$StringNullableWithAggregatesFilter.fromJson(
              (l$requestId as Map<String, dynamic>));
    }
    if (data.containsKey('systemPrompt')) {
      final l$systemPrompt = data['systemPrompt'];
      result$data['systemPrompt'] = l$systemPrompt == null
          ? null
          : Input$StringNullableWithAggregatesFilter.fromJson(
              (l$systemPrompt as Map<String, dynamic>));
    }
    if (data.containsKey('totalTokens')) {
      final l$totalTokens = data['totalTokens'];
      result$data['totalTokens'] = l$totalTokens == null
          ? null
          : Input$IntNullableWithAggregatesFilter.fromJson(
              (l$totalTokens as Map<String, dynamic>));
    }
    if (data.containsKey('updatedAt')) {
      final l$updatedAt = data['updatedAt'];
      result$data['updatedAt'] = l$updatedAt == null
          ? null
          : Input$DateTimeWithAggregatesFilter.fromJson(
              (l$updatedAt as Map<String, dynamic>));
    }
    if (data.containsKey('userPrompt')) {
      final l$userPrompt = data['userPrompt'];
      result$data['userPrompt'] = l$userPrompt == null
          ? null
          : Input$StringNullableWithAggregatesFilter.fromJson(
              (l$userPrompt as Map<String, dynamic>));
    }
    if (data.containsKey('uuid')) {
      final l$uuid = data['uuid'];
      result$data['uuid'] = l$uuid == null
          ? null
          : Input$UuidWithAggregatesFilter.fromJson(
              (l$uuid as Map<String, dynamic>));
    }
    return Input$BookRevisionScalarWhereWithAggregatesInput._(result$data);
  }

  Map<String, dynamic> _$data;

  List<Input$BookRevisionScalarWhereWithAggregatesInput>? get AND =>
      (_$data['AND']
          as List<Input$BookRevisionScalarWhereWithAggregatesInput>?);

  List<Input$BookRevisionScalarWhereWithAggregatesInput>? get NOT =>
      (_$data['NOT']
          as List<Input$BookRevisionScalarWhereWithAggregatesInput>?);

  List<Input$BookRevisionScalarWhereWithAggregatesInput>? get OR =>
      (_$data['OR'] as List<Input$BookRevisionScalarWhereWithAggregatesInput>?);

  Input$UuidNullableWithAggregatesFilter? get bookEditedId =>
      (_$data['bookEditedId'] as Input$UuidNullableWithAggregatesFilter?);

  Input$UuidNullableWithAggregatesFilter? get bookRawId =>
      (_$data['bookRawId'] as Input$UuidNullableWithAggregatesFilter?);

  Input$IntNullableWithAggregatesFilter? get completionTokens =>
      (_$data['completionTokens'] as Input$IntNullableWithAggregatesFilter?);

  Input$StringNullableListFilter? get content =>
      (_$data['content'] as Input$StringNullableListFilter?);

  Input$DateTimeWithAggregatesFilter? get createdAt =>
      (_$data['createdAt'] as Input$DateTimeWithAggregatesFilter?);

  Input$BoolWithAggregatesFilter? get isRaw =>
      (_$data['isRaw'] as Input$BoolWithAggregatesFilter?);

  Input$StringNullableWithAggregatesFilter? get model =>
      (_$data['model'] as Input$StringNullableWithAggregatesFilter?);

  Input$IntNullableWithAggregatesFilter? get promptTokens =>
      (_$data['promptTokens'] as Input$IntNullableWithAggregatesFilter?);

  Input$StringNullableWithAggregatesFilter? get raw =>
      (_$data['raw'] as Input$StringNullableWithAggregatesFilter?);

  Input$StringNullableWithAggregatesFilter? get requestId =>
      (_$data['requestId'] as Input$StringNullableWithAggregatesFilter?);

  Input$StringNullableWithAggregatesFilter? get systemPrompt =>
      (_$data['systemPrompt'] as Input$StringNullableWithAggregatesFilter?);

  Input$IntNullableWithAggregatesFilter? get totalTokens =>
      (_$data['totalTokens'] as Input$IntNullableWithAggregatesFilter?);

  Input$DateTimeWithAggregatesFilter? get updatedAt =>
      (_$data['updatedAt'] as Input$DateTimeWithAggregatesFilter?);

  Input$StringNullableWithAggregatesFilter? get userPrompt =>
      (_$data['userPrompt'] as Input$StringNullableWithAggregatesFilter?);

  Input$UuidWithAggregatesFilter? get uuid =>
      (_$data['uuid'] as Input$UuidWithAggregatesFilter?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('AND')) {
      final l$AND = AND;
      result$data['AND'] = l$AND?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('NOT')) {
      final l$NOT = NOT;
      result$data['NOT'] = l$NOT?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('OR')) {
      final l$OR = OR;
      result$data['OR'] = l$OR?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('bookEditedId')) {
      final l$bookEditedId = bookEditedId;
      result$data['bookEditedId'] = l$bookEditedId?.toJson();
    }
    if (_$data.containsKey('bookRawId')) {
      final l$bookRawId = bookRawId;
      result$data['bookRawId'] = l$bookRawId?.toJson();
    }
    if (_$data.containsKey('completionTokens')) {
      final l$completionTokens = completionTokens;
      result$data['completionTokens'] = l$completionTokens?.toJson();
    }
    if (_$data.containsKey('content')) {
      final l$content = content;
      result$data['content'] = l$content?.toJson();
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toJson();
    }
    if (_$data.containsKey('isRaw')) {
      final l$isRaw = isRaw;
      result$data['isRaw'] = l$isRaw?.toJson();
    }
    if (_$data.containsKey('model')) {
      final l$model = model;
      result$data['model'] = l$model?.toJson();
    }
    if (_$data.containsKey('promptTokens')) {
      final l$promptTokens = promptTokens;
      result$data['promptTokens'] = l$promptTokens?.toJson();
    }
    if (_$data.containsKey('raw')) {
      final l$raw = raw;
      result$data['raw'] = l$raw?.toJson();
    }
    if (_$data.containsKey('requestId')) {
      final l$requestId = requestId;
      result$data['requestId'] = l$requestId?.toJson();
    }
    if (_$data.containsKey('systemPrompt')) {
      final l$systemPrompt = systemPrompt;
      result$data['systemPrompt'] = l$systemPrompt?.toJson();
    }
    if (_$data.containsKey('totalTokens')) {
      final l$totalTokens = totalTokens;
      result$data['totalTokens'] = l$totalTokens?.toJson();
    }
    if (_$data.containsKey('updatedAt')) {
      final l$updatedAt = updatedAt;
      result$data['updatedAt'] = l$updatedAt?.toJson();
    }
    if (_$data.containsKey('userPrompt')) {
      final l$userPrompt = userPrompt;
      result$data['userPrompt'] = l$userPrompt?.toJson();
    }
    if (_$data.containsKey('uuid')) {
      final l$uuid = uuid;
      result$data['uuid'] = l$uuid?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$BookRevisionScalarWhereWithAggregatesInput<
          Input$BookRevisionScalarWhereWithAggregatesInput>
      get copyWith => CopyWith$Input$BookRevisionScalarWhereWithAggregatesInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$BookRevisionScalarWhereWithAggregatesInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$AND = AND;
    final lOther$AND = other.AND;
    if (_$data.containsKey('AND') != other._$data.containsKey('AND')) {
      return false;
    }
    if (l$AND != null && lOther$AND != null) {
      if (l$AND.length != lOther$AND.length) {
        return false;
      }
      for (int i = 0; i < l$AND.length; i++) {
        final l$AND$entry = l$AND[i];
        final lOther$AND$entry = lOther$AND[i];
        if (l$AND$entry != lOther$AND$entry) {
          return false;
        }
      }
    } else if (l$AND != lOther$AND) {
      return false;
    }
    final l$NOT = NOT;
    final lOther$NOT = other.NOT;
    if (_$data.containsKey('NOT') != other._$data.containsKey('NOT')) {
      return false;
    }
    if (l$NOT != null && lOther$NOT != null) {
      if (l$NOT.length != lOther$NOT.length) {
        return false;
      }
      for (int i = 0; i < l$NOT.length; i++) {
        final l$NOT$entry = l$NOT[i];
        final lOther$NOT$entry = lOther$NOT[i];
        if (l$NOT$entry != lOther$NOT$entry) {
          return false;
        }
      }
    } else if (l$NOT != lOther$NOT) {
      return false;
    }
    final l$OR = OR;
    final lOther$OR = other.OR;
    if (_$data.containsKey('OR') != other._$data.containsKey('OR')) {
      return false;
    }
    if (l$OR != null && lOther$OR != null) {
      if (l$OR.length != lOther$OR.length) {
        return false;
      }
      for (int i = 0; i < l$OR.length; i++) {
        final l$OR$entry = l$OR[i];
        final lOther$OR$entry = lOther$OR[i];
        if (l$OR$entry != lOther$OR$entry) {
          return false;
        }
      }
    } else if (l$OR != lOther$OR) {
      return false;
    }
    final l$bookEditedId = bookEditedId;
    final lOther$bookEditedId = other.bookEditedId;
    if (_$data.containsKey('bookEditedId') !=
        other._$data.containsKey('bookEditedId')) {
      return false;
    }
    if (l$bookEditedId != lOther$bookEditedId) {
      return false;
    }
    final l$bookRawId = bookRawId;
    final lOther$bookRawId = other.bookRawId;
    if (_$data.containsKey('bookRawId') !=
        other._$data.containsKey('bookRawId')) {
      return false;
    }
    if (l$bookRawId != lOther$bookRawId) {
      return false;
    }
    final l$completionTokens = completionTokens;
    final lOther$completionTokens = other.completionTokens;
    if (_$data.containsKey('completionTokens') !=
        other._$data.containsKey('completionTokens')) {
      return false;
    }
    if (l$completionTokens != lOther$completionTokens) {
      return false;
    }
    final l$content = content;
    final lOther$content = other.content;
    if (_$data.containsKey('content') != other._$data.containsKey('content')) {
      return false;
    }
    if (l$content != lOther$content) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$isRaw = isRaw;
    final lOther$isRaw = other.isRaw;
    if (_$data.containsKey('isRaw') != other._$data.containsKey('isRaw')) {
      return false;
    }
    if (l$isRaw != lOther$isRaw) {
      return false;
    }
    final l$model = model;
    final lOther$model = other.model;
    if (_$data.containsKey('model') != other._$data.containsKey('model')) {
      return false;
    }
    if (l$model != lOther$model) {
      return false;
    }
    final l$promptTokens = promptTokens;
    final lOther$promptTokens = other.promptTokens;
    if (_$data.containsKey('promptTokens') !=
        other._$data.containsKey('promptTokens')) {
      return false;
    }
    if (l$promptTokens != lOther$promptTokens) {
      return false;
    }
    final l$raw = raw;
    final lOther$raw = other.raw;
    if (_$data.containsKey('raw') != other._$data.containsKey('raw')) {
      return false;
    }
    if (l$raw != lOther$raw) {
      return false;
    }
    final l$requestId = requestId;
    final lOther$requestId = other.requestId;
    if (_$data.containsKey('requestId') !=
        other._$data.containsKey('requestId')) {
      return false;
    }
    if (l$requestId != lOther$requestId) {
      return false;
    }
    final l$systemPrompt = systemPrompt;
    final lOther$systemPrompt = other.systemPrompt;
    if (_$data.containsKey('systemPrompt') !=
        other._$data.containsKey('systemPrompt')) {
      return false;
    }
    if (l$systemPrompt != lOther$systemPrompt) {
      return false;
    }
    final l$totalTokens = totalTokens;
    final lOther$totalTokens = other.totalTokens;
    if (_$data.containsKey('totalTokens') !=
        other._$data.containsKey('totalTokens')) {
      return false;
    }
    if (l$totalTokens != lOther$totalTokens) {
      return false;
    }
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (_$data.containsKey('updatedAt') !=
        other._$data.containsKey('updatedAt')) {
      return false;
    }
    if (l$updatedAt != lOther$updatedAt) {
      return false;
    }
    final l$userPrompt = userPrompt;
    final lOther$userPrompt = other.userPrompt;
    if (_$data.containsKey('userPrompt') !=
        other._$data.containsKey('userPrompt')) {
      return false;
    }
    if (l$userPrompt != lOther$userPrompt) {
      return false;
    }
    final l$uuid = uuid;
    final lOther$uuid = other.uuid;
    if (_$data.containsKey('uuid') != other._$data.containsKey('uuid')) {
      return false;
    }
    if (l$uuid != lOther$uuid) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$AND = AND;
    final l$NOT = NOT;
    final l$OR = OR;
    final l$bookEditedId = bookEditedId;
    final l$bookRawId = bookRawId;
    final l$completionTokens = completionTokens;
    final l$content = content;
    final l$createdAt = createdAt;
    final l$isRaw = isRaw;
    final l$model = model;
    final l$promptTokens = promptTokens;
    final l$raw = raw;
    final l$requestId = requestId;
    final l$systemPrompt = systemPrompt;
    final l$totalTokens = totalTokens;
    final l$updatedAt = updatedAt;
    final l$userPrompt = userPrompt;
    final l$uuid = uuid;
    return Object.hashAll([
      _$data.containsKey('AND')
          ? l$AND == null
              ? null
              : Object.hashAll(l$AND.map((v) => v))
          : const {},
      _$data.containsKey('NOT')
          ? l$NOT == null
              ? null
              : Object.hashAll(l$NOT.map((v) => v))
          : const {},
      _$data.containsKey('OR')
          ? l$OR == null
              ? null
              : Object.hashAll(l$OR.map((v) => v))
          : const {},
      _$data.containsKey('bookEditedId') ? l$bookEditedId : const {},
      _$data.containsKey('bookRawId') ? l$bookRawId : const {},
      _$data.containsKey('completionTokens') ? l$completionTokens : const {},
      _$data.containsKey('content') ? l$content : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('isRaw') ? l$isRaw : const {},
      _$data.containsKey('model') ? l$model : const {},
      _$data.containsKey('promptTokens') ? l$promptTokens : const {},
      _$data.containsKey('raw') ? l$raw : const {},
      _$data.containsKey('requestId') ? l$requestId : const {},
      _$data.containsKey('systemPrompt') ? l$systemPrompt : const {},
      _$data.containsKey('totalTokens') ? l$totalTokens : const {},
      _$data.containsKey('updatedAt') ? l$updatedAt : const {},
      _$data.containsKey('userPrompt') ? l$userPrompt : const {},
      _$data.containsKey('uuid') ? l$uuid : const {},
    ]);
  }
}

abstract class CopyWith$Input$BookRevisionScalarWhereWithAggregatesInput<TRes> {
  factory CopyWith$Input$BookRevisionScalarWhereWithAggregatesInput(
    Input$BookRevisionScalarWhereWithAggregatesInput instance,
    TRes Function(Input$BookRevisionScalarWhereWithAggregatesInput) then,
  ) = _CopyWithImpl$Input$BookRevisionScalarWhereWithAggregatesInput;

  factory CopyWith$Input$BookRevisionScalarWhereWithAggregatesInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$BookRevisionScalarWhereWithAggregatesInput;

  TRes call({
    List<Input$BookRevisionScalarWhereWithAggregatesInput>? AND,
    List<Input$BookRevisionScalarWhereWithAggregatesInput>? NOT,
    List<Input$BookRevisionScalarWhereWithAggregatesInput>? OR,
    Input$UuidNullableWithAggregatesFilter? bookEditedId,
    Input$UuidNullableWithAggregatesFilter? bookRawId,
    Input$IntNullableWithAggregatesFilter? completionTokens,
    Input$StringNullableListFilter? content,
    Input$DateTimeWithAggregatesFilter? createdAt,
    Input$BoolWithAggregatesFilter? isRaw,
    Input$StringNullableWithAggregatesFilter? model,
    Input$IntNullableWithAggregatesFilter? promptTokens,
    Input$StringNullableWithAggregatesFilter? raw,
    Input$StringNullableWithAggregatesFilter? requestId,
    Input$StringNullableWithAggregatesFilter? systemPrompt,
    Input$IntNullableWithAggregatesFilter? totalTokens,
    Input$DateTimeWithAggregatesFilter? updatedAt,
    Input$StringNullableWithAggregatesFilter? userPrompt,
    Input$UuidWithAggregatesFilter? uuid,
  });
  TRes AND(
      Iterable<Input$BookRevisionScalarWhereWithAggregatesInput>? Function(
              Iterable<
                  CopyWith$Input$BookRevisionScalarWhereWithAggregatesInput<
                      Input$BookRevisionScalarWhereWithAggregatesInput>>?)
          _fn);
  TRes NOT(
      Iterable<Input$BookRevisionScalarWhereWithAggregatesInput>? Function(
              Iterable<
                  CopyWith$Input$BookRevisionScalarWhereWithAggregatesInput<
                      Input$BookRevisionScalarWhereWithAggregatesInput>>?)
          _fn);
  TRes OR(
      Iterable<Input$BookRevisionScalarWhereWithAggregatesInput>? Function(
              Iterable<
                  CopyWith$Input$BookRevisionScalarWhereWithAggregatesInput<
                      Input$BookRevisionScalarWhereWithAggregatesInput>>?)
          _fn);
  CopyWith$Input$UuidNullableWithAggregatesFilter<TRes> get bookEditedId;
  CopyWith$Input$UuidNullableWithAggregatesFilter<TRes> get bookRawId;
  CopyWith$Input$IntNullableWithAggregatesFilter<TRes> get completionTokens;
  CopyWith$Input$StringNullableListFilter<TRes> get content;
  CopyWith$Input$DateTimeWithAggregatesFilter<TRes> get createdAt;
  CopyWith$Input$BoolWithAggregatesFilter<TRes> get isRaw;
  CopyWith$Input$StringNullableWithAggregatesFilter<TRes> get model;
  CopyWith$Input$IntNullableWithAggregatesFilter<TRes> get promptTokens;
  CopyWith$Input$StringNullableWithAggregatesFilter<TRes> get raw;
  CopyWith$Input$StringNullableWithAggregatesFilter<TRes> get requestId;
  CopyWith$Input$StringNullableWithAggregatesFilter<TRes> get systemPrompt;
  CopyWith$Input$IntNullableWithAggregatesFilter<TRes> get totalTokens;
  CopyWith$Input$DateTimeWithAggregatesFilter<TRes> get updatedAt;
  CopyWith$Input$StringNullableWithAggregatesFilter<TRes> get userPrompt;
  CopyWith$Input$UuidWithAggregatesFilter<TRes> get uuid;
}

class _CopyWithImpl$Input$BookRevisionScalarWhereWithAggregatesInput<TRes>
    implements CopyWith$Input$BookRevisionScalarWhereWithAggregatesInput<TRes> {
  _CopyWithImpl$Input$BookRevisionScalarWhereWithAggregatesInput(
    this._instance,
    this._then,
  );

  final Input$BookRevisionScalarWhereWithAggregatesInput _instance;

  final TRes Function(Input$BookRevisionScalarWhereWithAggregatesInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? AND = _undefined,
    Object? NOT = _undefined,
    Object? OR = _undefined,
    Object? bookEditedId = _undefined,
    Object? bookRawId = _undefined,
    Object? completionTokens = _undefined,
    Object? content = _undefined,
    Object? createdAt = _undefined,
    Object? isRaw = _undefined,
    Object? model = _undefined,
    Object? promptTokens = _undefined,
    Object? raw = _undefined,
    Object? requestId = _undefined,
    Object? systemPrompt = _undefined,
    Object? totalTokens = _undefined,
    Object? updatedAt = _undefined,
    Object? userPrompt = _undefined,
    Object? uuid = _undefined,
  }) =>
      _then(Input$BookRevisionScalarWhereWithAggregatesInput._({
        ..._instance._$data,
        if (AND != _undefined)
          'AND':
              (AND as List<Input$BookRevisionScalarWhereWithAggregatesInput>?),
        if (NOT != _undefined)
          'NOT':
              (NOT as List<Input$BookRevisionScalarWhereWithAggregatesInput>?),
        if (OR != _undefined)
          'OR': (OR as List<Input$BookRevisionScalarWhereWithAggregatesInput>?),
        if (bookEditedId != _undefined)
          'bookEditedId':
              (bookEditedId as Input$UuidNullableWithAggregatesFilter?),
        if (bookRawId != _undefined)
          'bookRawId': (bookRawId as Input$UuidNullableWithAggregatesFilter?),
        if (completionTokens != _undefined)
          'completionTokens':
              (completionTokens as Input$IntNullableWithAggregatesFilter?),
        if (content != _undefined)
          'content': (content as Input$StringNullableListFilter?),
        if (createdAt != _undefined)
          'createdAt': (createdAt as Input$DateTimeWithAggregatesFilter?),
        if (isRaw != _undefined)
          'isRaw': (isRaw as Input$BoolWithAggregatesFilter?),
        if (model != _undefined)
          'model': (model as Input$StringNullableWithAggregatesFilter?),
        if (promptTokens != _undefined)
          'promptTokens':
              (promptTokens as Input$IntNullableWithAggregatesFilter?),
        if (raw != _undefined)
          'raw': (raw as Input$StringNullableWithAggregatesFilter?),
        if (requestId != _undefined)
          'requestId': (requestId as Input$StringNullableWithAggregatesFilter?),
        if (systemPrompt != _undefined)
          'systemPrompt':
              (systemPrompt as Input$StringNullableWithAggregatesFilter?),
        if (totalTokens != _undefined)
          'totalTokens':
              (totalTokens as Input$IntNullableWithAggregatesFilter?),
        if (updatedAt != _undefined)
          'updatedAt': (updatedAt as Input$DateTimeWithAggregatesFilter?),
        if (userPrompt != _undefined)
          'userPrompt':
              (userPrompt as Input$StringNullableWithAggregatesFilter?),
        if (uuid != _undefined)
          'uuid': (uuid as Input$UuidWithAggregatesFilter?),
      }));

  TRes AND(
          Iterable<Input$BookRevisionScalarWhereWithAggregatesInput>? Function(
                  Iterable<
                      CopyWith$Input$BookRevisionScalarWhereWithAggregatesInput<
                          Input$BookRevisionScalarWhereWithAggregatesInput>>?)
              _fn) =>
      call(
          AND: _fn(_instance.AND?.map(
              (e) => CopyWith$Input$BookRevisionScalarWhereWithAggregatesInput(
                    e,
                    (i) => i,
                  )))?.toList());

  TRes NOT(
          Iterable<Input$BookRevisionScalarWhereWithAggregatesInput>? Function(
                  Iterable<
                      CopyWith$Input$BookRevisionScalarWhereWithAggregatesInput<
                          Input$BookRevisionScalarWhereWithAggregatesInput>>?)
              _fn) =>
      call(
          NOT: _fn(_instance.NOT?.map(
              (e) => CopyWith$Input$BookRevisionScalarWhereWithAggregatesInput(
                    e,
                    (i) => i,
                  )))?.toList());

  TRes OR(
          Iterable<Input$BookRevisionScalarWhereWithAggregatesInput>? Function(
                  Iterable<
                      CopyWith$Input$BookRevisionScalarWhereWithAggregatesInput<
                          Input$BookRevisionScalarWhereWithAggregatesInput>>?)
              _fn) =>
      call(
          OR: _fn(_instance.OR?.map(
              (e) => CopyWith$Input$BookRevisionScalarWhereWithAggregatesInput(
                    e,
                    (i) => i,
                  )))?.toList());

  CopyWith$Input$UuidNullableWithAggregatesFilter<TRes> get bookEditedId {
    final local$bookEditedId = _instance.bookEditedId;
    return local$bookEditedId == null
        ? CopyWith$Input$UuidNullableWithAggregatesFilter.stub(_then(_instance))
        : CopyWith$Input$UuidNullableWithAggregatesFilter(
            local$bookEditedId, (e) => call(bookEditedId: e));
  }

  CopyWith$Input$UuidNullableWithAggregatesFilter<TRes> get bookRawId {
    final local$bookRawId = _instance.bookRawId;
    return local$bookRawId == null
        ? CopyWith$Input$UuidNullableWithAggregatesFilter.stub(_then(_instance))
        : CopyWith$Input$UuidNullableWithAggregatesFilter(
            local$bookRawId, (e) => call(bookRawId: e));
  }

  CopyWith$Input$IntNullableWithAggregatesFilter<TRes> get completionTokens {
    final local$completionTokens = _instance.completionTokens;
    return local$completionTokens == null
        ? CopyWith$Input$IntNullableWithAggregatesFilter.stub(_then(_instance))
        : CopyWith$Input$IntNullableWithAggregatesFilter(
            local$completionTokens, (e) => call(completionTokens: e));
  }

  CopyWith$Input$StringNullableListFilter<TRes> get content {
    final local$content = _instance.content;
    return local$content == null
        ? CopyWith$Input$StringNullableListFilter.stub(_then(_instance))
        : CopyWith$Input$StringNullableListFilter(
            local$content, (e) => call(content: e));
  }

  CopyWith$Input$DateTimeWithAggregatesFilter<TRes> get createdAt {
    final local$createdAt = _instance.createdAt;
    return local$createdAt == null
        ? CopyWith$Input$DateTimeWithAggregatesFilter.stub(_then(_instance))
        : CopyWith$Input$DateTimeWithAggregatesFilter(
            local$createdAt, (e) => call(createdAt: e));
  }

  CopyWith$Input$BoolWithAggregatesFilter<TRes> get isRaw {
    final local$isRaw = _instance.isRaw;
    return local$isRaw == null
        ? CopyWith$Input$BoolWithAggregatesFilter.stub(_then(_instance))
        : CopyWith$Input$BoolWithAggregatesFilter(
            local$isRaw, (e) => call(isRaw: e));
  }

  CopyWith$Input$StringNullableWithAggregatesFilter<TRes> get model {
    final local$model = _instance.model;
    return local$model == null
        ? CopyWith$Input$StringNullableWithAggregatesFilter.stub(
            _then(_instance))
        : CopyWith$Input$StringNullableWithAggregatesFilter(
            local$model, (e) => call(model: e));
  }

  CopyWith$Input$IntNullableWithAggregatesFilter<TRes> get promptTokens {
    final local$promptTokens = _instance.promptTokens;
    return local$promptTokens == null
        ? CopyWith$Input$IntNullableWithAggregatesFilter.stub(_then(_instance))
        : CopyWith$Input$IntNullableWithAggregatesFilter(
            local$promptTokens, (e) => call(promptTokens: e));
  }

  CopyWith$Input$StringNullableWithAggregatesFilter<TRes> get raw {
    final local$raw = _instance.raw;
    return local$raw == null
        ? CopyWith$Input$StringNullableWithAggregatesFilter.stub(
            _then(_instance))
        : CopyWith$Input$StringNullableWithAggregatesFilter(
            local$raw, (e) => call(raw: e));
  }

  CopyWith$Input$StringNullableWithAggregatesFilter<TRes> get requestId {
    final local$requestId = _instance.requestId;
    return local$requestId == null
        ? CopyWith$Input$StringNullableWithAggregatesFilter.stub(
            _then(_instance))
        : CopyWith$Input$StringNullableWithAggregatesFilter(
            local$requestId, (e) => call(requestId: e));
  }

  CopyWith$Input$StringNullableWithAggregatesFilter<TRes> get systemPrompt {
    final local$systemPrompt = _instance.systemPrompt;
    return local$systemPrompt == null
        ? CopyWith$Input$StringNullableWithAggregatesFilter.stub(
            _then(_instance))
        : CopyWith$Input$StringNullableWithAggregatesFilter(
            local$systemPrompt, (e) => call(systemPrompt: e));
  }

  CopyWith$Input$IntNullableWithAggregatesFilter<TRes> get totalTokens {
    final local$totalTokens = _instance.totalTokens;
    return local$totalTokens == null
        ? CopyWith$Input$IntNullableWithAggregatesFilter.stub(_then(_instance))
        : CopyWith$Input$IntNullableWithAggregatesFilter(
            local$totalTokens, (e) => call(totalTokens: e));
  }

  CopyWith$Input$DateTimeWithAggregatesFilter<TRes> get updatedAt {
    final local$updatedAt = _instance.updatedAt;
    return local$updatedAt == null
        ? CopyWith$Input$DateTimeWithAggregatesFilter.stub(_then(_instance))
        : CopyWith$Input$DateTimeWithAggregatesFilter(
            local$updatedAt, (e) => call(updatedAt: e));
  }

  CopyWith$Input$StringNullableWithAggregatesFilter<TRes> get userPrompt {
    final local$userPrompt = _instance.userPrompt;
    return local$userPrompt == null
        ? CopyWith$Input$StringNullableWithAggregatesFilter.stub(
            _then(_instance))
        : CopyWith$Input$StringNullableWithAggregatesFilter(
            local$userPrompt, (e) => call(userPrompt: e));
  }

  CopyWith$Input$UuidWithAggregatesFilter<TRes> get uuid {
    final local$uuid = _instance.uuid;
    return local$uuid == null
        ? CopyWith$Input$UuidWithAggregatesFilter.stub(_then(_instance))
        : CopyWith$Input$UuidWithAggregatesFilter(
            local$uuid, (e) => call(uuid: e));
  }
}

class _CopyWithStubImpl$Input$BookRevisionScalarWhereWithAggregatesInput<TRes>
    implements CopyWith$Input$BookRevisionScalarWhereWithAggregatesInput<TRes> {
  _CopyWithStubImpl$Input$BookRevisionScalarWhereWithAggregatesInput(this._res);

  TRes _res;

  call({
    List<Input$BookRevisionScalarWhereWithAggregatesInput>? AND,
    List<Input$BookRevisionScalarWhereWithAggregatesInput>? NOT,
    List<Input$BookRevisionScalarWhereWithAggregatesInput>? OR,
    Input$UuidNullableWithAggregatesFilter? bookEditedId,
    Input$UuidNullableWithAggregatesFilter? bookRawId,
    Input$IntNullableWithAggregatesFilter? completionTokens,
    Input$StringNullableListFilter? content,
    Input$DateTimeWithAggregatesFilter? createdAt,
    Input$BoolWithAggregatesFilter? isRaw,
    Input$StringNullableWithAggregatesFilter? model,
    Input$IntNullableWithAggregatesFilter? promptTokens,
    Input$StringNullableWithAggregatesFilter? raw,
    Input$StringNullableWithAggregatesFilter? requestId,
    Input$StringNullableWithAggregatesFilter? systemPrompt,
    Input$IntNullableWithAggregatesFilter? totalTokens,
    Input$DateTimeWithAggregatesFilter? updatedAt,
    Input$StringNullableWithAggregatesFilter? userPrompt,
    Input$UuidWithAggregatesFilter? uuid,
  }) =>
      _res;

  AND(_fn) => _res;

  NOT(_fn) => _res;

  OR(_fn) => _res;

  CopyWith$Input$UuidNullableWithAggregatesFilter<TRes> get bookEditedId =>
      CopyWith$Input$UuidNullableWithAggregatesFilter.stub(_res);

  CopyWith$Input$UuidNullableWithAggregatesFilter<TRes> get bookRawId =>
      CopyWith$Input$UuidNullableWithAggregatesFilter.stub(_res);

  CopyWith$Input$IntNullableWithAggregatesFilter<TRes> get completionTokens =>
      CopyWith$Input$IntNullableWithAggregatesFilter.stub(_res);

  CopyWith$Input$StringNullableListFilter<TRes> get content =>
      CopyWith$Input$StringNullableListFilter.stub(_res);

  CopyWith$Input$DateTimeWithAggregatesFilter<TRes> get createdAt =>
      CopyWith$Input$DateTimeWithAggregatesFilter.stub(_res);

  CopyWith$Input$BoolWithAggregatesFilter<TRes> get isRaw =>
      CopyWith$Input$BoolWithAggregatesFilter.stub(_res);

  CopyWith$Input$StringNullableWithAggregatesFilter<TRes> get model =>
      CopyWith$Input$StringNullableWithAggregatesFilter.stub(_res);

  CopyWith$Input$IntNullableWithAggregatesFilter<TRes> get promptTokens =>
      CopyWith$Input$IntNullableWithAggregatesFilter.stub(_res);

  CopyWith$Input$StringNullableWithAggregatesFilter<TRes> get raw =>
      CopyWith$Input$StringNullableWithAggregatesFilter.stub(_res);

  CopyWith$Input$StringNullableWithAggregatesFilter<TRes> get requestId =>
      CopyWith$Input$StringNullableWithAggregatesFilter.stub(_res);

  CopyWith$Input$StringNullableWithAggregatesFilter<TRes> get systemPrompt =>
      CopyWith$Input$StringNullableWithAggregatesFilter.stub(_res);

  CopyWith$Input$IntNullableWithAggregatesFilter<TRes> get totalTokens =>
      CopyWith$Input$IntNullableWithAggregatesFilter.stub(_res);

  CopyWith$Input$DateTimeWithAggregatesFilter<TRes> get updatedAt =>
      CopyWith$Input$DateTimeWithAggregatesFilter.stub(_res);

  CopyWith$Input$StringNullableWithAggregatesFilter<TRes> get userPrompt =>
      CopyWith$Input$StringNullableWithAggregatesFilter.stub(_res);

  CopyWith$Input$UuidWithAggregatesFilter<TRes> get uuid =>
      CopyWith$Input$UuidWithAggregatesFilter.stub(_res);
}

class Input$BookRevisionSumOrderByAggregateInput {
  factory Input$BookRevisionSumOrderByAggregateInput({
    Enum$SortOrder? completionTokens,
    Enum$SortOrder? promptTokens,
    Enum$SortOrder? totalTokens,
  }) =>
      Input$BookRevisionSumOrderByAggregateInput._({
        if (completionTokens != null) r'completionTokens': completionTokens,
        if (promptTokens != null) r'promptTokens': promptTokens,
        if (totalTokens != null) r'totalTokens': totalTokens,
      });

  Input$BookRevisionSumOrderByAggregateInput._(this._$data);

  factory Input$BookRevisionSumOrderByAggregateInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('completionTokens')) {
      final l$completionTokens = data['completionTokens'];
      result$data['completionTokens'] = l$completionTokens == null
          ? null
          : fromJson$Enum$SortOrder((l$completionTokens as String));
    }
    if (data.containsKey('promptTokens')) {
      final l$promptTokens = data['promptTokens'];
      result$data['promptTokens'] = l$promptTokens == null
          ? null
          : fromJson$Enum$SortOrder((l$promptTokens as String));
    }
    if (data.containsKey('totalTokens')) {
      final l$totalTokens = data['totalTokens'];
      result$data['totalTokens'] = l$totalTokens == null
          ? null
          : fromJson$Enum$SortOrder((l$totalTokens as String));
    }
    return Input$BookRevisionSumOrderByAggregateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$SortOrder? get completionTokens =>
      (_$data['completionTokens'] as Enum$SortOrder?);

  Enum$SortOrder? get promptTokens =>
      (_$data['promptTokens'] as Enum$SortOrder?);

  Enum$SortOrder? get totalTokens => (_$data['totalTokens'] as Enum$SortOrder?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('completionTokens')) {
      final l$completionTokens = completionTokens;
      result$data['completionTokens'] = l$completionTokens == null
          ? null
          : toJson$Enum$SortOrder(l$completionTokens);
    }
    if (_$data.containsKey('promptTokens')) {
      final l$promptTokens = promptTokens;
      result$data['promptTokens'] =
          l$promptTokens == null ? null : toJson$Enum$SortOrder(l$promptTokens);
    }
    if (_$data.containsKey('totalTokens')) {
      final l$totalTokens = totalTokens;
      result$data['totalTokens'] =
          l$totalTokens == null ? null : toJson$Enum$SortOrder(l$totalTokens);
    }
    return result$data;
  }

  CopyWith$Input$BookRevisionSumOrderByAggregateInput<
          Input$BookRevisionSumOrderByAggregateInput>
      get copyWith => CopyWith$Input$BookRevisionSumOrderByAggregateInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$BookRevisionSumOrderByAggregateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$completionTokens = completionTokens;
    final lOther$completionTokens = other.completionTokens;
    if (_$data.containsKey('completionTokens') !=
        other._$data.containsKey('completionTokens')) {
      return false;
    }
    if (l$completionTokens != lOther$completionTokens) {
      return false;
    }
    final l$promptTokens = promptTokens;
    final lOther$promptTokens = other.promptTokens;
    if (_$data.containsKey('promptTokens') !=
        other._$data.containsKey('promptTokens')) {
      return false;
    }
    if (l$promptTokens != lOther$promptTokens) {
      return false;
    }
    final l$totalTokens = totalTokens;
    final lOther$totalTokens = other.totalTokens;
    if (_$data.containsKey('totalTokens') !=
        other._$data.containsKey('totalTokens')) {
      return false;
    }
    if (l$totalTokens != lOther$totalTokens) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$completionTokens = completionTokens;
    final l$promptTokens = promptTokens;
    final l$totalTokens = totalTokens;
    return Object.hashAll([
      _$data.containsKey('completionTokens') ? l$completionTokens : const {},
      _$data.containsKey('promptTokens') ? l$promptTokens : const {},
      _$data.containsKey('totalTokens') ? l$totalTokens : const {},
    ]);
  }
}

abstract class CopyWith$Input$BookRevisionSumOrderByAggregateInput<TRes> {
  factory CopyWith$Input$BookRevisionSumOrderByAggregateInput(
    Input$BookRevisionSumOrderByAggregateInput instance,
    TRes Function(Input$BookRevisionSumOrderByAggregateInput) then,
  ) = _CopyWithImpl$Input$BookRevisionSumOrderByAggregateInput;

  factory CopyWith$Input$BookRevisionSumOrderByAggregateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$BookRevisionSumOrderByAggregateInput;

  TRes call({
    Enum$SortOrder? completionTokens,
    Enum$SortOrder? promptTokens,
    Enum$SortOrder? totalTokens,
  });
}

class _CopyWithImpl$Input$BookRevisionSumOrderByAggregateInput<TRes>
    implements CopyWith$Input$BookRevisionSumOrderByAggregateInput<TRes> {
  _CopyWithImpl$Input$BookRevisionSumOrderByAggregateInput(
    this._instance,
    this._then,
  );

  final Input$BookRevisionSumOrderByAggregateInput _instance;

  final TRes Function(Input$BookRevisionSumOrderByAggregateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? completionTokens = _undefined,
    Object? promptTokens = _undefined,
    Object? totalTokens = _undefined,
  }) =>
      _then(Input$BookRevisionSumOrderByAggregateInput._({
        ..._instance._$data,
        if (completionTokens != _undefined)
          'completionTokens': (completionTokens as Enum$SortOrder?),
        if (promptTokens != _undefined)
          'promptTokens': (promptTokens as Enum$SortOrder?),
        if (totalTokens != _undefined)
          'totalTokens': (totalTokens as Enum$SortOrder?),
      }));
}

class _CopyWithStubImpl$Input$BookRevisionSumOrderByAggregateInput<TRes>
    implements CopyWith$Input$BookRevisionSumOrderByAggregateInput<TRes> {
  _CopyWithStubImpl$Input$BookRevisionSumOrderByAggregateInput(this._res);

  TRes _res;

  call({
    Enum$SortOrder? completionTokens,
    Enum$SortOrder? promptTokens,
    Enum$SortOrder? totalTokens,
  }) =>
      _res;
}

class Input$BookRevisionUpdateInput {
  factory Input$BookRevisionUpdateInput({
    Input$BookUpdateOneWithoutBookEditedNestedInput? bookEdited,
    Input$BookUpdateOneWithoutBookRawNestedInput? bookRaw,
    Input$NullableIntFieldUpdateOperationsInput? completionTokens,
    Input$BookRevisionUpdatecontentInput? content,
    Input$DateTimeFieldUpdateOperationsInput? createdAt,
    Input$BoolFieldUpdateOperationsInput? isRaw,
    Input$NullableStringFieldUpdateOperationsInput? model,
    Input$NullableIntFieldUpdateOperationsInput? promptTokens,
    Input$NullableStringFieldUpdateOperationsInput? raw,
    Input$NullableStringFieldUpdateOperationsInput? requestId,
    Input$NullableStringFieldUpdateOperationsInput? systemPrompt,
    Input$NullableIntFieldUpdateOperationsInput? totalTokens,
    Input$DateTimeFieldUpdateOperationsInput? updatedAt,
    Input$NullableStringFieldUpdateOperationsInput? userPrompt,
    Input$StringFieldUpdateOperationsInput? uuid,
  }) =>
      Input$BookRevisionUpdateInput._({
        if (bookEdited != null) r'bookEdited': bookEdited,
        if (bookRaw != null) r'bookRaw': bookRaw,
        if (completionTokens != null) r'completionTokens': completionTokens,
        if (content != null) r'content': content,
        if (createdAt != null) r'createdAt': createdAt,
        if (isRaw != null) r'isRaw': isRaw,
        if (model != null) r'model': model,
        if (promptTokens != null) r'promptTokens': promptTokens,
        if (raw != null) r'raw': raw,
        if (requestId != null) r'requestId': requestId,
        if (systemPrompt != null) r'systemPrompt': systemPrompt,
        if (totalTokens != null) r'totalTokens': totalTokens,
        if (updatedAt != null) r'updatedAt': updatedAt,
        if (userPrompt != null) r'userPrompt': userPrompt,
        if (uuid != null) r'uuid': uuid,
      });

  Input$BookRevisionUpdateInput._(this._$data);

  factory Input$BookRevisionUpdateInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('bookEdited')) {
      final l$bookEdited = data['bookEdited'];
      result$data['bookEdited'] = l$bookEdited == null
          ? null
          : Input$BookUpdateOneWithoutBookEditedNestedInput.fromJson(
              (l$bookEdited as Map<String, dynamic>));
    }
    if (data.containsKey('bookRaw')) {
      final l$bookRaw = data['bookRaw'];
      result$data['bookRaw'] = l$bookRaw == null
          ? null
          : Input$BookUpdateOneWithoutBookRawNestedInput.fromJson(
              (l$bookRaw as Map<String, dynamic>));
    }
    if (data.containsKey('completionTokens')) {
      final l$completionTokens = data['completionTokens'];
      result$data['completionTokens'] = l$completionTokens == null
          ? null
          : Input$NullableIntFieldUpdateOperationsInput.fromJson(
              (l$completionTokens as Map<String, dynamic>));
    }
    if (data.containsKey('content')) {
      final l$content = data['content'];
      result$data['content'] = l$content == null
          ? null
          : Input$BookRevisionUpdatecontentInput.fromJson(
              (l$content as Map<String, dynamic>));
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : Input$DateTimeFieldUpdateOperationsInput.fromJson(
              (l$createdAt as Map<String, dynamic>));
    }
    if (data.containsKey('isRaw')) {
      final l$isRaw = data['isRaw'];
      result$data['isRaw'] = l$isRaw == null
          ? null
          : Input$BoolFieldUpdateOperationsInput.fromJson(
              (l$isRaw as Map<String, dynamic>));
    }
    if (data.containsKey('model')) {
      final l$model = data['model'];
      result$data['model'] = l$model == null
          ? null
          : Input$NullableStringFieldUpdateOperationsInput.fromJson(
              (l$model as Map<String, dynamic>));
    }
    if (data.containsKey('promptTokens')) {
      final l$promptTokens = data['promptTokens'];
      result$data['promptTokens'] = l$promptTokens == null
          ? null
          : Input$NullableIntFieldUpdateOperationsInput.fromJson(
              (l$promptTokens as Map<String, dynamic>));
    }
    if (data.containsKey('raw')) {
      final l$raw = data['raw'];
      result$data['raw'] = l$raw == null
          ? null
          : Input$NullableStringFieldUpdateOperationsInput.fromJson(
              (l$raw as Map<String, dynamic>));
    }
    if (data.containsKey('requestId')) {
      final l$requestId = data['requestId'];
      result$data['requestId'] = l$requestId == null
          ? null
          : Input$NullableStringFieldUpdateOperationsInput.fromJson(
              (l$requestId as Map<String, dynamic>));
    }
    if (data.containsKey('systemPrompt')) {
      final l$systemPrompt = data['systemPrompt'];
      result$data['systemPrompt'] = l$systemPrompt == null
          ? null
          : Input$NullableStringFieldUpdateOperationsInput.fromJson(
              (l$systemPrompt as Map<String, dynamic>));
    }
    if (data.containsKey('totalTokens')) {
      final l$totalTokens = data['totalTokens'];
      result$data['totalTokens'] = l$totalTokens == null
          ? null
          : Input$NullableIntFieldUpdateOperationsInput.fromJson(
              (l$totalTokens as Map<String, dynamic>));
    }
    if (data.containsKey('updatedAt')) {
      final l$updatedAt = data['updatedAt'];
      result$data['updatedAt'] = l$updatedAt == null
          ? null
          : Input$DateTimeFieldUpdateOperationsInput.fromJson(
              (l$updatedAt as Map<String, dynamic>));
    }
    if (data.containsKey('userPrompt')) {
      final l$userPrompt = data['userPrompt'];
      result$data['userPrompt'] = l$userPrompt == null
          ? null
          : Input$NullableStringFieldUpdateOperationsInput.fromJson(
              (l$userPrompt as Map<String, dynamic>));
    }
    if (data.containsKey('uuid')) {
      final l$uuid = data['uuid'];
      result$data['uuid'] = l$uuid == null
          ? null
          : Input$StringFieldUpdateOperationsInput.fromJson(
              (l$uuid as Map<String, dynamic>));
    }
    return Input$BookRevisionUpdateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$BookUpdateOneWithoutBookEditedNestedInput? get bookEdited =>
      (_$data['bookEdited']
          as Input$BookUpdateOneWithoutBookEditedNestedInput?);

  Input$BookUpdateOneWithoutBookRawNestedInput? get bookRaw =>
      (_$data['bookRaw'] as Input$BookUpdateOneWithoutBookRawNestedInput?);

  Input$NullableIntFieldUpdateOperationsInput? get completionTokens =>
      (_$data['completionTokens']
          as Input$NullableIntFieldUpdateOperationsInput?);

  Input$BookRevisionUpdatecontentInput? get content =>
      (_$data['content'] as Input$BookRevisionUpdatecontentInput?);

  Input$DateTimeFieldUpdateOperationsInput? get createdAt =>
      (_$data['createdAt'] as Input$DateTimeFieldUpdateOperationsInput?);

  Input$BoolFieldUpdateOperationsInput? get isRaw =>
      (_$data['isRaw'] as Input$BoolFieldUpdateOperationsInput?);

  Input$NullableStringFieldUpdateOperationsInput? get model =>
      (_$data['model'] as Input$NullableStringFieldUpdateOperationsInput?);

  Input$NullableIntFieldUpdateOperationsInput? get promptTokens =>
      (_$data['promptTokens'] as Input$NullableIntFieldUpdateOperationsInput?);

  Input$NullableStringFieldUpdateOperationsInput? get raw =>
      (_$data['raw'] as Input$NullableStringFieldUpdateOperationsInput?);

  Input$NullableStringFieldUpdateOperationsInput? get requestId =>
      (_$data['requestId'] as Input$NullableStringFieldUpdateOperationsInput?);

  Input$NullableStringFieldUpdateOperationsInput? get systemPrompt =>
      (_$data['systemPrompt']
          as Input$NullableStringFieldUpdateOperationsInput?);

  Input$NullableIntFieldUpdateOperationsInput? get totalTokens =>
      (_$data['totalTokens'] as Input$NullableIntFieldUpdateOperationsInput?);

  Input$DateTimeFieldUpdateOperationsInput? get updatedAt =>
      (_$data['updatedAt'] as Input$DateTimeFieldUpdateOperationsInput?);

  Input$NullableStringFieldUpdateOperationsInput? get userPrompt =>
      (_$data['userPrompt'] as Input$NullableStringFieldUpdateOperationsInput?);

  Input$StringFieldUpdateOperationsInput? get uuid =>
      (_$data['uuid'] as Input$StringFieldUpdateOperationsInput?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('bookEdited')) {
      final l$bookEdited = bookEdited;
      result$data['bookEdited'] = l$bookEdited?.toJson();
    }
    if (_$data.containsKey('bookRaw')) {
      final l$bookRaw = bookRaw;
      result$data['bookRaw'] = l$bookRaw?.toJson();
    }
    if (_$data.containsKey('completionTokens')) {
      final l$completionTokens = completionTokens;
      result$data['completionTokens'] = l$completionTokens?.toJson();
    }
    if (_$data.containsKey('content')) {
      final l$content = content;
      result$data['content'] = l$content?.toJson();
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toJson();
    }
    if (_$data.containsKey('isRaw')) {
      final l$isRaw = isRaw;
      result$data['isRaw'] = l$isRaw?.toJson();
    }
    if (_$data.containsKey('model')) {
      final l$model = model;
      result$data['model'] = l$model?.toJson();
    }
    if (_$data.containsKey('promptTokens')) {
      final l$promptTokens = promptTokens;
      result$data['promptTokens'] = l$promptTokens?.toJson();
    }
    if (_$data.containsKey('raw')) {
      final l$raw = raw;
      result$data['raw'] = l$raw?.toJson();
    }
    if (_$data.containsKey('requestId')) {
      final l$requestId = requestId;
      result$data['requestId'] = l$requestId?.toJson();
    }
    if (_$data.containsKey('systemPrompt')) {
      final l$systemPrompt = systemPrompt;
      result$data['systemPrompt'] = l$systemPrompt?.toJson();
    }
    if (_$data.containsKey('totalTokens')) {
      final l$totalTokens = totalTokens;
      result$data['totalTokens'] = l$totalTokens?.toJson();
    }
    if (_$data.containsKey('updatedAt')) {
      final l$updatedAt = updatedAt;
      result$data['updatedAt'] = l$updatedAt?.toJson();
    }
    if (_$data.containsKey('userPrompt')) {
      final l$userPrompt = userPrompt;
      result$data['userPrompt'] = l$userPrompt?.toJson();
    }
    if (_$data.containsKey('uuid')) {
      final l$uuid = uuid;
      result$data['uuid'] = l$uuid?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$BookRevisionUpdateInput<Input$BookRevisionUpdateInput>
      get copyWith => CopyWith$Input$BookRevisionUpdateInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$BookRevisionUpdateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$bookEdited = bookEdited;
    final lOther$bookEdited = other.bookEdited;
    if (_$data.containsKey('bookEdited') !=
        other._$data.containsKey('bookEdited')) {
      return false;
    }
    if (l$bookEdited != lOther$bookEdited) {
      return false;
    }
    final l$bookRaw = bookRaw;
    final lOther$bookRaw = other.bookRaw;
    if (_$data.containsKey('bookRaw') != other._$data.containsKey('bookRaw')) {
      return false;
    }
    if (l$bookRaw != lOther$bookRaw) {
      return false;
    }
    final l$completionTokens = completionTokens;
    final lOther$completionTokens = other.completionTokens;
    if (_$data.containsKey('completionTokens') !=
        other._$data.containsKey('completionTokens')) {
      return false;
    }
    if (l$completionTokens != lOther$completionTokens) {
      return false;
    }
    final l$content = content;
    final lOther$content = other.content;
    if (_$data.containsKey('content') != other._$data.containsKey('content')) {
      return false;
    }
    if (l$content != lOther$content) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$isRaw = isRaw;
    final lOther$isRaw = other.isRaw;
    if (_$data.containsKey('isRaw') != other._$data.containsKey('isRaw')) {
      return false;
    }
    if (l$isRaw != lOther$isRaw) {
      return false;
    }
    final l$model = model;
    final lOther$model = other.model;
    if (_$data.containsKey('model') != other._$data.containsKey('model')) {
      return false;
    }
    if (l$model != lOther$model) {
      return false;
    }
    final l$promptTokens = promptTokens;
    final lOther$promptTokens = other.promptTokens;
    if (_$data.containsKey('promptTokens') !=
        other._$data.containsKey('promptTokens')) {
      return false;
    }
    if (l$promptTokens != lOther$promptTokens) {
      return false;
    }
    final l$raw = raw;
    final lOther$raw = other.raw;
    if (_$data.containsKey('raw') != other._$data.containsKey('raw')) {
      return false;
    }
    if (l$raw != lOther$raw) {
      return false;
    }
    final l$requestId = requestId;
    final lOther$requestId = other.requestId;
    if (_$data.containsKey('requestId') !=
        other._$data.containsKey('requestId')) {
      return false;
    }
    if (l$requestId != lOther$requestId) {
      return false;
    }
    final l$systemPrompt = systemPrompt;
    final lOther$systemPrompt = other.systemPrompt;
    if (_$data.containsKey('systemPrompt') !=
        other._$data.containsKey('systemPrompt')) {
      return false;
    }
    if (l$systemPrompt != lOther$systemPrompt) {
      return false;
    }
    final l$totalTokens = totalTokens;
    final lOther$totalTokens = other.totalTokens;
    if (_$data.containsKey('totalTokens') !=
        other._$data.containsKey('totalTokens')) {
      return false;
    }
    if (l$totalTokens != lOther$totalTokens) {
      return false;
    }
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (_$data.containsKey('updatedAt') !=
        other._$data.containsKey('updatedAt')) {
      return false;
    }
    if (l$updatedAt != lOther$updatedAt) {
      return false;
    }
    final l$userPrompt = userPrompt;
    final lOther$userPrompt = other.userPrompt;
    if (_$data.containsKey('userPrompt') !=
        other._$data.containsKey('userPrompt')) {
      return false;
    }
    if (l$userPrompt != lOther$userPrompt) {
      return false;
    }
    final l$uuid = uuid;
    final lOther$uuid = other.uuid;
    if (_$data.containsKey('uuid') != other._$data.containsKey('uuid')) {
      return false;
    }
    if (l$uuid != lOther$uuid) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$bookEdited = bookEdited;
    final l$bookRaw = bookRaw;
    final l$completionTokens = completionTokens;
    final l$content = content;
    final l$createdAt = createdAt;
    final l$isRaw = isRaw;
    final l$model = model;
    final l$promptTokens = promptTokens;
    final l$raw = raw;
    final l$requestId = requestId;
    final l$systemPrompt = systemPrompt;
    final l$totalTokens = totalTokens;
    final l$updatedAt = updatedAt;
    final l$userPrompt = userPrompt;
    final l$uuid = uuid;
    return Object.hashAll([
      _$data.containsKey('bookEdited') ? l$bookEdited : const {},
      _$data.containsKey('bookRaw') ? l$bookRaw : const {},
      _$data.containsKey('completionTokens') ? l$completionTokens : const {},
      _$data.containsKey('content') ? l$content : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('isRaw') ? l$isRaw : const {},
      _$data.containsKey('model') ? l$model : const {},
      _$data.containsKey('promptTokens') ? l$promptTokens : const {},
      _$data.containsKey('raw') ? l$raw : const {},
      _$data.containsKey('requestId') ? l$requestId : const {},
      _$data.containsKey('systemPrompt') ? l$systemPrompt : const {},
      _$data.containsKey('totalTokens') ? l$totalTokens : const {},
      _$data.containsKey('updatedAt') ? l$updatedAt : const {},
      _$data.containsKey('userPrompt') ? l$userPrompt : const {},
      _$data.containsKey('uuid') ? l$uuid : const {},
    ]);
  }
}

abstract class CopyWith$Input$BookRevisionUpdateInput<TRes> {
  factory CopyWith$Input$BookRevisionUpdateInput(
    Input$BookRevisionUpdateInput instance,
    TRes Function(Input$BookRevisionUpdateInput) then,
  ) = _CopyWithImpl$Input$BookRevisionUpdateInput;

  factory CopyWith$Input$BookRevisionUpdateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$BookRevisionUpdateInput;

  TRes call({
    Input$BookUpdateOneWithoutBookEditedNestedInput? bookEdited,
    Input$BookUpdateOneWithoutBookRawNestedInput? bookRaw,
    Input$NullableIntFieldUpdateOperationsInput? completionTokens,
    Input$BookRevisionUpdatecontentInput? content,
    Input$DateTimeFieldUpdateOperationsInput? createdAt,
    Input$BoolFieldUpdateOperationsInput? isRaw,
    Input$NullableStringFieldUpdateOperationsInput? model,
    Input$NullableIntFieldUpdateOperationsInput? promptTokens,
    Input$NullableStringFieldUpdateOperationsInput? raw,
    Input$NullableStringFieldUpdateOperationsInput? requestId,
    Input$NullableStringFieldUpdateOperationsInput? systemPrompt,
    Input$NullableIntFieldUpdateOperationsInput? totalTokens,
    Input$DateTimeFieldUpdateOperationsInput? updatedAt,
    Input$NullableStringFieldUpdateOperationsInput? userPrompt,
    Input$StringFieldUpdateOperationsInput? uuid,
  });
  CopyWith$Input$BookUpdateOneWithoutBookEditedNestedInput<TRes> get bookEdited;
  CopyWith$Input$BookUpdateOneWithoutBookRawNestedInput<TRes> get bookRaw;
  CopyWith$Input$NullableIntFieldUpdateOperationsInput<TRes>
      get completionTokens;
  CopyWith$Input$BookRevisionUpdatecontentInput<TRes> get content;
  CopyWith$Input$DateTimeFieldUpdateOperationsInput<TRes> get createdAt;
  CopyWith$Input$BoolFieldUpdateOperationsInput<TRes> get isRaw;
  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get model;
  CopyWith$Input$NullableIntFieldUpdateOperationsInput<TRes> get promptTokens;
  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get raw;
  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get requestId;
  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes>
      get systemPrompt;
  CopyWith$Input$NullableIntFieldUpdateOperationsInput<TRes> get totalTokens;
  CopyWith$Input$DateTimeFieldUpdateOperationsInput<TRes> get updatedAt;
  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get userPrompt;
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get uuid;
}

class _CopyWithImpl$Input$BookRevisionUpdateInput<TRes>
    implements CopyWith$Input$BookRevisionUpdateInput<TRes> {
  _CopyWithImpl$Input$BookRevisionUpdateInput(
    this._instance,
    this._then,
  );

  final Input$BookRevisionUpdateInput _instance;

  final TRes Function(Input$BookRevisionUpdateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? bookEdited = _undefined,
    Object? bookRaw = _undefined,
    Object? completionTokens = _undefined,
    Object? content = _undefined,
    Object? createdAt = _undefined,
    Object? isRaw = _undefined,
    Object? model = _undefined,
    Object? promptTokens = _undefined,
    Object? raw = _undefined,
    Object? requestId = _undefined,
    Object? systemPrompt = _undefined,
    Object? totalTokens = _undefined,
    Object? updatedAt = _undefined,
    Object? userPrompt = _undefined,
    Object? uuid = _undefined,
  }) =>
      _then(Input$BookRevisionUpdateInput._({
        ..._instance._$data,
        if (bookEdited != _undefined)
          'bookEdited':
              (bookEdited as Input$BookUpdateOneWithoutBookEditedNestedInput?),
        if (bookRaw != _undefined)
          'bookRaw': (bookRaw as Input$BookUpdateOneWithoutBookRawNestedInput?),
        if (completionTokens != _undefined)
          'completionTokens': (completionTokens
              as Input$NullableIntFieldUpdateOperationsInput?),
        if (content != _undefined)
          'content': (content as Input$BookRevisionUpdatecontentInput?),
        if (createdAt != _undefined)
          'createdAt': (createdAt as Input$DateTimeFieldUpdateOperationsInput?),
        if (isRaw != _undefined)
          'isRaw': (isRaw as Input$BoolFieldUpdateOperationsInput?),
        if (model != _undefined)
          'model': (model as Input$NullableStringFieldUpdateOperationsInput?),
        if (promptTokens != _undefined)
          'promptTokens':
              (promptTokens as Input$NullableIntFieldUpdateOperationsInput?),
        if (raw != _undefined)
          'raw': (raw as Input$NullableStringFieldUpdateOperationsInput?),
        if (requestId != _undefined)
          'requestId':
              (requestId as Input$NullableStringFieldUpdateOperationsInput?),
        if (systemPrompt != _undefined)
          'systemPrompt':
              (systemPrompt as Input$NullableStringFieldUpdateOperationsInput?),
        if (totalTokens != _undefined)
          'totalTokens':
              (totalTokens as Input$NullableIntFieldUpdateOperationsInput?),
        if (updatedAt != _undefined)
          'updatedAt': (updatedAt as Input$DateTimeFieldUpdateOperationsInput?),
        if (userPrompt != _undefined)
          'userPrompt':
              (userPrompt as Input$NullableStringFieldUpdateOperationsInput?),
        if (uuid != _undefined)
          'uuid': (uuid as Input$StringFieldUpdateOperationsInput?),
      }));

  CopyWith$Input$BookUpdateOneWithoutBookEditedNestedInput<TRes>
      get bookEdited {
    final local$bookEdited = _instance.bookEdited;
    return local$bookEdited == null
        ? CopyWith$Input$BookUpdateOneWithoutBookEditedNestedInput.stub(
            _then(_instance))
        : CopyWith$Input$BookUpdateOneWithoutBookEditedNestedInput(
            local$bookEdited, (e) => call(bookEdited: e));
  }

  CopyWith$Input$BookUpdateOneWithoutBookRawNestedInput<TRes> get bookRaw {
    final local$bookRaw = _instance.bookRaw;
    return local$bookRaw == null
        ? CopyWith$Input$BookUpdateOneWithoutBookRawNestedInput.stub(
            _then(_instance))
        : CopyWith$Input$BookUpdateOneWithoutBookRawNestedInput(
            local$bookRaw, (e) => call(bookRaw: e));
  }

  CopyWith$Input$NullableIntFieldUpdateOperationsInput<TRes>
      get completionTokens {
    final local$completionTokens = _instance.completionTokens;
    return local$completionTokens == null
        ? CopyWith$Input$NullableIntFieldUpdateOperationsInput.stub(
            _then(_instance))
        : CopyWith$Input$NullableIntFieldUpdateOperationsInput(
            local$completionTokens, (e) => call(completionTokens: e));
  }

  CopyWith$Input$BookRevisionUpdatecontentInput<TRes> get content {
    final local$content = _instance.content;
    return local$content == null
        ? CopyWith$Input$BookRevisionUpdatecontentInput.stub(_then(_instance))
        : CopyWith$Input$BookRevisionUpdatecontentInput(
            local$content, (e) => call(content: e));
  }

  CopyWith$Input$DateTimeFieldUpdateOperationsInput<TRes> get createdAt {
    final local$createdAt = _instance.createdAt;
    return local$createdAt == null
        ? CopyWith$Input$DateTimeFieldUpdateOperationsInput.stub(
            _then(_instance))
        : CopyWith$Input$DateTimeFieldUpdateOperationsInput(
            local$createdAt, (e) => call(createdAt: e));
  }

  CopyWith$Input$BoolFieldUpdateOperationsInput<TRes> get isRaw {
    final local$isRaw = _instance.isRaw;
    return local$isRaw == null
        ? CopyWith$Input$BoolFieldUpdateOperationsInput.stub(_then(_instance))
        : CopyWith$Input$BoolFieldUpdateOperationsInput(
            local$isRaw, (e) => call(isRaw: e));
  }

  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get model {
    final local$model = _instance.model;
    return local$model == null
        ? CopyWith$Input$NullableStringFieldUpdateOperationsInput.stub(
            _then(_instance))
        : CopyWith$Input$NullableStringFieldUpdateOperationsInput(
            local$model, (e) => call(model: e));
  }

  CopyWith$Input$NullableIntFieldUpdateOperationsInput<TRes> get promptTokens {
    final local$promptTokens = _instance.promptTokens;
    return local$promptTokens == null
        ? CopyWith$Input$NullableIntFieldUpdateOperationsInput.stub(
            _then(_instance))
        : CopyWith$Input$NullableIntFieldUpdateOperationsInput(
            local$promptTokens, (e) => call(promptTokens: e));
  }

  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get raw {
    final local$raw = _instance.raw;
    return local$raw == null
        ? CopyWith$Input$NullableStringFieldUpdateOperationsInput.stub(
            _then(_instance))
        : CopyWith$Input$NullableStringFieldUpdateOperationsInput(
            local$raw, (e) => call(raw: e));
  }

  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get requestId {
    final local$requestId = _instance.requestId;
    return local$requestId == null
        ? CopyWith$Input$NullableStringFieldUpdateOperationsInput.stub(
            _then(_instance))
        : CopyWith$Input$NullableStringFieldUpdateOperationsInput(
            local$requestId, (e) => call(requestId: e));
  }

  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes>
      get systemPrompt {
    final local$systemPrompt = _instance.systemPrompt;
    return local$systemPrompt == null
        ? CopyWith$Input$NullableStringFieldUpdateOperationsInput.stub(
            _then(_instance))
        : CopyWith$Input$NullableStringFieldUpdateOperationsInput(
            local$systemPrompt, (e) => call(systemPrompt: e));
  }

  CopyWith$Input$NullableIntFieldUpdateOperationsInput<TRes> get totalTokens {
    final local$totalTokens = _instance.totalTokens;
    return local$totalTokens == null
        ? CopyWith$Input$NullableIntFieldUpdateOperationsInput.stub(
            _then(_instance))
        : CopyWith$Input$NullableIntFieldUpdateOperationsInput(
            local$totalTokens, (e) => call(totalTokens: e));
  }

  CopyWith$Input$DateTimeFieldUpdateOperationsInput<TRes> get updatedAt {
    final local$updatedAt = _instance.updatedAt;
    return local$updatedAt == null
        ? CopyWith$Input$DateTimeFieldUpdateOperationsInput.stub(
            _then(_instance))
        : CopyWith$Input$DateTimeFieldUpdateOperationsInput(
            local$updatedAt, (e) => call(updatedAt: e));
  }

  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get userPrompt {
    final local$userPrompt = _instance.userPrompt;
    return local$userPrompt == null
        ? CopyWith$Input$NullableStringFieldUpdateOperationsInput.stub(
            _then(_instance))
        : CopyWith$Input$NullableStringFieldUpdateOperationsInput(
            local$userPrompt, (e) => call(userPrompt: e));
  }

  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get uuid {
    final local$uuid = _instance.uuid;
    return local$uuid == null
        ? CopyWith$Input$StringFieldUpdateOperationsInput.stub(_then(_instance))
        : CopyWith$Input$StringFieldUpdateOperationsInput(
            local$uuid, (e) => call(uuid: e));
  }
}

class _CopyWithStubImpl$Input$BookRevisionUpdateInput<TRes>
    implements CopyWith$Input$BookRevisionUpdateInput<TRes> {
  _CopyWithStubImpl$Input$BookRevisionUpdateInput(this._res);

  TRes _res;

  call({
    Input$BookUpdateOneWithoutBookEditedNestedInput? bookEdited,
    Input$BookUpdateOneWithoutBookRawNestedInput? bookRaw,
    Input$NullableIntFieldUpdateOperationsInput? completionTokens,
    Input$BookRevisionUpdatecontentInput? content,
    Input$DateTimeFieldUpdateOperationsInput? createdAt,
    Input$BoolFieldUpdateOperationsInput? isRaw,
    Input$NullableStringFieldUpdateOperationsInput? model,
    Input$NullableIntFieldUpdateOperationsInput? promptTokens,
    Input$NullableStringFieldUpdateOperationsInput? raw,
    Input$NullableStringFieldUpdateOperationsInput? requestId,
    Input$NullableStringFieldUpdateOperationsInput? systemPrompt,
    Input$NullableIntFieldUpdateOperationsInput? totalTokens,
    Input$DateTimeFieldUpdateOperationsInput? updatedAt,
    Input$NullableStringFieldUpdateOperationsInput? userPrompt,
    Input$StringFieldUpdateOperationsInput? uuid,
  }) =>
      _res;

  CopyWith$Input$BookUpdateOneWithoutBookEditedNestedInput<TRes>
      get bookEdited =>
          CopyWith$Input$BookUpdateOneWithoutBookEditedNestedInput.stub(_res);

  CopyWith$Input$BookUpdateOneWithoutBookRawNestedInput<TRes> get bookRaw =>
      CopyWith$Input$BookUpdateOneWithoutBookRawNestedInput.stub(_res);

  CopyWith$Input$NullableIntFieldUpdateOperationsInput<TRes>
      get completionTokens =>
          CopyWith$Input$NullableIntFieldUpdateOperationsInput.stub(_res);

  CopyWith$Input$BookRevisionUpdatecontentInput<TRes> get content =>
      CopyWith$Input$BookRevisionUpdatecontentInput.stub(_res);

  CopyWith$Input$DateTimeFieldUpdateOperationsInput<TRes> get createdAt =>
      CopyWith$Input$DateTimeFieldUpdateOperationsInput.stub(_res);

  CopyWith$Input$BoolFieldUpdateOperationsInput<TRes> get isRaw =>
      CopyWith$Input$BoolFieldUpdateOperationsInput.stub(_res);

  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get model =>
      CopyWith$Input$NullableStringFieldUpdateOperationsInput.stub(_res);

  CopyWith$Input$NullableIntFieldUpdateOperationsInput<TRes> get promptTokens =>
      CopyWith$Input$NullableIntFieldUpdateOperationsInput.stub(_res);

  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get raw =>
      CopyWith$Input$NullableStringFieldUpdateOperationsInput.stub(_res);

  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get requestId =>
      CopyWith$Input$NullableStringFieldUpdateOperationsInput.stub(_res);

  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes>
      get systemPrompt =>
          CopyWith$Input$NullableStringFieldUpdateOperationsInput.stub(_res);

  CopyWith$Input$NullableIntFieldUpdateOperationsInput<TRes> get totalTokens =>
      CopyWith$Input$NullableIntFieldUpdateOperationsInput.stub(_res);

  CopyWith$Input$DateTimeFieldUpdateOperationsInput<TRes> get updatedAt =>
      CopyWith$Input$DateTimeFieldUpdateOperationsInput.stub(_res);

  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes>
      get userPrompt =>
          CopyWith$Input$NullableStringFieldUpdateOperationsInput.stub(_res);

  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get uuid =>
      CopyWith$Input$StringFieldUpdateOperationsInput.stub(_res);
}

class Input$BookRevisionUpdateManyMutationInput {
  factory Input$BookRevisionUpdateManyMutationInput({
    Input$NullableIntFieldUpdateOperationsInput? completionTokens,
    Input$BookRevisionUpdatecontentInput? content,
    Input$DateTimeFieldUpdateOperationsInput? createdAt,
    Input$BoolFieldUpdateOperationsInput? isRaw,
    Input$NullableStringFieldUpdateOperationsInput? model,
    Input$NullableIntFieldUpdateOperationsInput? promptTokens,
    Input$NullableStringFieldUpdateOperationsInput? raw,
    Input$NullableStringFieldUpdateOperationsInput? requestId,
    Input$NullableStringFieldUpdateOperationsInput? systemPrompt,
    Input$NullableIntFieldUpdateOperationsInput? totalTokens,
    Input$DateTimeFieldUpdateOperationsInput? updatedAt,
    Input$NullableStringFieldUpdateOperationsInput? userPrompt,
    Input$StringFieldUpdateOperationsInput? uuid,
  }) =>
      Input$BookRevisionUpdateManyMutationInput._({
        if (completionTokens != null) r'completionTokens': completionTokens,
        if (content != null) r'content': content,
        if (createdAt != null) r'createdAt': createdAt,
        if (isRaw != null) r'isRaw': isRaw,
        if (model != null) r'model': model,
        if (promptTokens != null) r'promptTokens': promptTokens,
        if (raw != null) r'raw': raw,
        if (requestId != null) r'requestId': requestId,
        if (systemPrompt != null) r'systemPrompt': systemPrompt,
        if (totalTokens != null) r'totalTokens': totalTokens,
        if (updatedAt != null) r'updatedAt': updatedAt,
        if (userPrompt != null) r'userPrompt': userPrompt,
        if (uuid != null) r'uuid': uuid,
      });

  Input$BookRevisionUpdateManyMutationInput._(this._$data);

  factory Input$BookRevisionUpdateManyMutationInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('completionTokens')) {
      final l$completionTokens = data['completionTokens'];
      result$data['completionTokens'] = l$completionTokens == null
          ? null
          : Input$NullableIntFieldUpdateOperationsInput.fromJson(
              (l$completionTokens as Map<String, dynamic>));
    }
    if (data.containsKey('content')) {
      final l$content = data['content'];
      result$data['content'] = l$content == null
          ? null
          : Input$BookRevisionUpdatecontentInput.fromJson(
              (l$content as Map<String, dynamic>));
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : Input$DateTimeFieldUpdateOperationsInput.fromJson(
              (l$createdAt as Map<String, dynamic>));
    }
    if (data.containsKey('isRaw')) {
      final l$isRaw = data['isRaw'];
      result$data['isRaw'] = l$isRaw == null
          ? null
          : Input$BoolFieldUpdateOperationsInput.fromJson(
              (l$isRaw as Map<String, dynamic>));
    }
    if (data.containsKey('model')) {
      final l$model = data['model'];
      result$data['model'] = l$model == null
          ? null
          : Input$NullableStringFieldUpdateOperationsInput.fromJson(
              (l$model as Map<String, dynamic>));
    }
    if (data.containsKey('promptTokens')) {
      final l$promptTokens = data['promptTokens'];
      result$data['promptTokens'] = l$promptTokens == null
          ? null
          : Input$NullableIntFieldUpdateOperationsInput.fromJson(
              (l$promptTokens as Map<String, dynamic>));
    }
    if (data.containsKey('raw')) {
      final l$raw = data['raw'];
      result$data['raw'] = l$raw == null
          ? null
          : Input$NullableStringFieldUpdateOperationsInput.fromJson(
              (l$raw as Map<String, dynamic>));
    }
    if (data.containsKey('requestId')) {
      final l$requestId = data['requestId'];
      result$data['requestId'] = l$requestId == null
          ? null
          : Input$NullableStringFieldUpdateOperationsInput.fromJson(
              (l$requestId as Map<String, dynamic>));
    }
    if (data.containsKey('systemPrompt')) {
      final l$systemPrompt = data['systemPrompt'];
      result$data['systemPrompt'] = l$systemPrompt == null
          ? null
          : Input$NullableStringFieldUpdateOperationsInput.fromJson(
              (l$systemPrompt as Map<String, dynamic>));
    }
    if (data.containsKey('totalTokens')) {
      final l$totalTokens = data['totalTokens'];
      result$data['totalTokens'] = l$totalTokens == null
          ? null
          : Input$NullableIntFieldUpdateOperationsInput.fromJson(
              (l$totalTokens as Map<String, dynamic>));
    }
    if (data.containsKey('updatedAt')) {
      final l$updatedAt = data['updatedAt'];
      result$data['updatedAt'] = l$updatedAt == null
          ? null
          : Input$DateTimeFieldUpdateOperationsInput.fromJson(
              (l$updatedAt as Map<String, dynamic>));
    }
    if (data.containsKey('userPrompt')) {
      final l$userPrompt = data['userPrompt'];
      result$data['userPrompt'] = l$userPrompt == null
          ? null
          : Input$NullableStringFieldUpdateOperationsInput.fromJson(
              (l$userPrompt as Map<String, dynamic>));
    }
    if (data.containsKey('uuid')) {
      final l$uuid = data['uuid'];
      result$data['uuid'] = l$uuid == null
          ? null
          : Input$StringFieldUpdateOperationsInput.fromJson(
              (l$uuid as Map<String, dynamic>));
    }
    return Input$BookRevisionUpdateManyMutationInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$NullableIntFieldUpdateOperationsInput? get completionTokens =>
      (_$data['completionTokens']
          as Input$NullableIntFieldUpdateOperationsInput?);

  Input$BookRevisionUpdatecontentInput? get content =>
      (_$data['content'] as Input$BookRevisionUpdatecontentInput?);

  Input$DateTimeFieldUpdateOperationsInput? get createdAt =>
      (_$data['createdAt'] as Input$DateTimeFieldUpdateOperationsInput?);

  Input$BoolFieldUpdateOperationsInput? get isRaw =>
      (_$data['isRaw'] as Input$BoolFieldUpdateOperationsInput?);

  Input$NullableStringFieldUpdateOperationsInput? get model =>
      (_$data['model'] as Input$NullableStringFieldUpdateOperationsInput?);

  Input$NullableIntFieldUpdateOperationsInput? get promptTokens =>
      (_$data['promptTokens'] as Input$NullableIntFieldUpdateOperationsInput?);

  Input$NullableStringFieldUpdateOperationsInput? get raw =>
      (_$data['raw'] as Input$NullableStringFieldUpdateOperationsInput?);

  Input$NullableStringFieldUpdateOperationsInput? get requestId =>
      (_$data['requestId'] as Input$NullableStringFieldUpdateOperationsInput?);

  Input$NullableStringFieldUpdateOperationsInput? get systemPrompt =>
      (_$data['systemPrompt']
          as Input$NullableStringFieldUpdateOperationsInput?);

  Input$NullableIntFieldUpdateOperationsInput? get totalTokens =>
      (_$data['totalTokens'] as Input$NullableIntFieldUpdateOperationsInput?);

  Input$DateTimeFieldUpdateOperationsInput? get updatedAt =>
      (_$data['updatedAt'] as Input$DateTimeFieldUpdateOperationsInput?);

  Input$NullableStringFieldUpdateOperationsInput? get userPrompt =>
      (_$data['userPrompt'] as Input$NullableStringFieldUpdateOperationsInput?);

  Input$StringFieldUpdateOperationsInput? get uuid =>
      (_$data['uuid'] as Input$StringFieldUpdateOperationsInput?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('completionTokens')) {
      final l$completionTokens = completionTokens;
      result$data['completionTokens'] = l$completionTokens?.toJson();
    }
    if (_$data.containsKey('content')) {
      final l$content = content;
      result$data['content'] = l$content?.toJson();
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toJson();
    }
    if (_$data.containsKey('isRaw')) {
      final l$isRaw = isRaw;
      result$data['isRaw'] = l$isRaw?.toJson();
    }
    if (_$data.containsKey('model')) {
      final l$model = model;
      result$data['model'] = l$model?.toJson();
    }
    if (_$data.containsKey('promptTokens')) {
      final l$promptTokens = promptTokens;
      result$data['promptTokens'] = l$promptTokens?.toJson();
    }
    if (_$data.containsKey('raw')) {
      final l$raw = raw;
      result$data['raw'] = l$raw?.toJson();
    }
    if (_$data.containsKey('requestId')) {
      final l$requestId = requestId;
      result$data['requestId'] = l$requestId?.toJson();
    }
    if (_$data.containsKey('systemPrompt')) {
      final l$systemPrompt = systemPrompt;
      result$data['systemPrompt'] = l$systemPrompt?.toJson();
    }
    if (_$data.containsKey('totalTokens')) {
      final l$totalTokens = totalTokens;
      result$data['totalTokens'] = l$totalTokens?.toJson();
    }
    if (_$data.containsKey('updatedAt')) {
      final l$updatedAt = updatedAt;
      result$data['updatedAt'] = l$updatedAt?.toJson();
    }
    if (_$data.containsKey('userPrompt')) {
      final l$userPrompt = userPrompt;
      result$data['userPrompt'] = l$userPrompt?.toJson();
    }
    if (_$data.containsKey('uuid')) {
      final l$uuid = uuid;
      result$data['uuid'] = l$uuid?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$BookRevisionUpdateManyMutationInput<
          Input$BookRevisionUpdateManyMutationInput>
      get copyWith => CopyWith$Input$BookRevisionUpdateManyMutationInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$BookRevisionUpdateManyMutationInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$completionTokens = completionTokens;
    final lOther$completionTokens = other.completionTokens;
    if (_$data.containsKey('completionTokens') !=
        other._$data.containsKey('completionTokens')) {
      return false;
    }
    if (l$completionTokens != lOther$completionTokens) {
      return false;
    }
    final l$content = content;
    final lOther$content = other.content;
    if (_$data.containsKey('content') != other._$data.containsKey('content')) {
      return false;
    }
    if (l$content != lOther$content) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$isRaw = isRaw;
    final lOther$isRaw = other.isRaw;
    if (_$data.containsKey('isRaw') != other._$data.containsKey('isRaw')) {
      return false;
    }
    if (l$isRaw != lOther$isRaw) {
      return false;
    }
    final l$model = model;
    final lOther$model = other.model;
    if (_$data.containsKey('model') != other._$data.containsKey('model')) {
      return false;
    }
    if (l$model != lOther$model) {
      return false;
    }
    final l$promptTokens = promptTokens;
    final lOther$promptTokens = other.promptTokens;
    if (_$data.containsKey('promptTokens') !=
        other._$data.containsKey('promptTokens')) {
      return false;
    }
    if (l$promptTokens != lOther$promptTokens) {
      return false;
    }
    final l$raw = raw;
    final lOther$raw = other.raw;
    if (_$data.containsKey('raw') != other._$data.containsKey('raw')) {
      return false;
    }
    if (l$raw != lOther$raw) {
      return false;
    }
    final l$requestId = requestId;
    final lOther$requestId = other.requestId;
    if (_$data.containsKey('requestId') !=
        other._$data.containsKey('requestId')) {
      return false;
    }
    if (l$requestId != lOther$requestId) {
      return false;
    }
    final l$systemPrompt = systemPrompt;
    final lOther$systemPrompt = other.systemPrompt;
    if (_$data.containsKey('systemPrompt') !=
        other._$data.containsKey('systemPrompt')) {
      return false;
    }
    if (l$systemPrompt != lOther$systemPrompt) {
      return false;
    }
    final l$totalTokens = totalTokens;
    final lOther$totalTokens = other.totalTokens;
    if (_$data.containsKey('totalTokens') !=
        other._$data.containsKey('totalTokens')) {
      return false;
    }
    if (l$totalTokens != lOther$totalTokens) {
      return false;
    }
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (_$data.containsKey('updatedAt') !=
        other._$data.containsKey('updatedAt')) {
      return false;
    }
    if (l$updatedAt != lOther$updatedAt) {
      return false;
    }
    final l$userPrompt = userPrompt;
    final lOther$userPrompt = other.userPrompt;
    if (_$data.containsKey('userPrompt') !=
        other._$data.containsKey('userPrompt')) {
      return false;
    }
    if (l$userPrompt != lOther$userPrompt) {
      return false;
    }
    final l$uuid = uuid;
    final lOther$uuid = other.uuid;
    if (_$data.containsKey('uuid') != other._$data.containsKey('uuid')) {
      return false;
    }
    if (l$uuid != lOther$uuid) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$completionTokens = completionTokens;
    final l$content = content;
    final l$createdAt = createdAt;
    final l$isRaw = isRaw;
    final l$model = model;
    final l$promptTokens = promptTokens;
    final l$raw = raw;
    final l$requestId = requestId;
    final l$systemPrompt = systemPrompt;
    final l$totalTokens = totalTokens;
    final l$updatedAt = updatedAt;
    final l$userPrompt = userPrompt;
    final l$uuid = uuid;
    return Object.hashAll([
      _$data.containsKey('completionTokens') ? l$completionTokens : const {},
      _$data.containsKey('content') ? l$content : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('isRaw') ? l$isRaw : const {},
      _$data.containsKey('model') ? l$model : const {},
      _$data.containsKey('promptTokens') ? l$promptTokens : const {},
      _$data.containsKey('raw') ? l$raw : const {},
      _$data.containsKey('requestId') ? l$requestId : const {},
      _$data.containsKey('systemPrompt') ? l$systemPrompt : const {},
      _$data.containsKey('totalTokens') ? l$totalTokens : const {},
      _$data.containsKey('updatedAt') ? l$updatedAt : const {},
      _$data.containsKey('userPrompt') ? l$userPrompt : const {},
      _$data.containsKey('uuid') ? l$uuid : const {},
    ]);
  }
}

abstract class CopyWith$Input$BookRevisionUpdateManyMutationInput<TRes> {
  factory CopyWith$Input$BookRevisionUpdateManyMutationInput(
    Input$BookRevisionUpdateManyMutationInput instance,
    TRes Function(Input$BookRevisionUpdateManyMutationInput) then,
  ) = _CopyWithImpl$Input$BookRevisionUpdateManyMutationInput;

  factory CopyWith$Input$BookRevisionUpdateManyMutationInput.stub(TRes res) =
      _CopyWithStubImpl$Input$BookRevisionUpdateManyMutationInput;

  TRes call({
    Input$NullableIntFieldUpdateOperationsInput? completionTokens,
    Input$BookRevisionUpdatecontentInput? content,
    Input$DateTimeFieldUpdateOperationsInput? createdAt,
    Input$BoolFieldUpdateOperationsInput? isRaw,
    Input$NullableStringFieldUpdateOperationsInput? model,
    Input$NullableIntFieldUpdateOperationsInput? promptTokens,
    Input$NullableStringFieldUpdateOperationsInput? raw,
    Input$NullableStringFieldUpdateOperationsInput? requestId,
    Input$NullableStringFieldUpdateOperationsInput? systemPrompt,
    Input$NullableIntFieldUpdateOperationsInput? totalTokens,
    Input$DateTimeFieldUpdateOperationsInput? updatedAt,
    Input$NullableStringFieldUpdateOperationsInput? userPrompt,
    Input$StringFieldUpdateOperationsInput? uuid,
  });
  CopyWith$Input$NullableIntFieldUpdateOperationsInput<TRes>
      get completionTokens;
  CopyWith$Input$BookRevisionUpdatecontentInput<TRes> get content;
  CopyWith$Input$DateTimeFieldUpdateOperationsInput<TRes> get createdAt;
  CopyWith$Input$BoolFieldUpdateOperationsInput<TRes> get isRaw;
  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get model;
  CopyWith$Input$NullableIntFieldUpdateOperationsInput<TRes> get promptTokens;
  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get raw;
  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get requestId;
  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes>
      get systemPrompt;
  CopyWith$Input$NullableIntFieldUpdateOperationsInput<TRes> get totalTokens;
  CopyWith$Input$DateTimeFieldUpdateOperationsInput<TRes> get updatedAt;
  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get userPrompt;
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get uuid;
}

class _CopyWithImpl$Input$BookRevisionUpdateManyMutationInput<TRes>
    implements CopyWith$Input$BookRevisionUpdateManyMutationInput<TRes> {
  _CopyWithImpl$Input$BookRevisionUpdateManyMutationInput(
    this._instance,
    this._then,
  );

  final Input$BookRevisionUpdateManyMutationInput _instance;

  final TRes Function(Input$BookRevisionUpdateManyMutationInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? completionTokens = _undefined,
    Object? content = _undefined,
    Object? createdAt = _undefined,
    Object? isRaw = _undefined,
    Object? model = _undefined,
    Object? promptTokens = _undefined,
    Object? raw = _undefined,
    Object? requestId = _undefined,
    Object? systemPrompt = _undefined,
    Object? totalTokens = _undefined,
    Object? updatedAt = _undefined,
    Object? userPrompt = _undefined,
    Object? uuid = _undefined,
  }) =>
      _then(Input$BookRevisionUpdateManyMutationInput._({
        ..._instance._$data,
        if (completionTokens != _undefined)
          'completionTokens': (completionTokens
              as Input$NullableIntFieldUpdateOperationsInput?),
        if (content != _undefined)
          'content': (content as Input$BookRevisionUpdatecontentInput?),
        if (createdAt != _undefined)
          'createdAt': (createdAt as Input$DateTimeFieldUpdateOperationsInput?),
        if (isRaw != _undefined)
          'isRaw': (isRaw as Input$BoolFieldUpdateOperationsInput?),
        if (model != _undefined)
          'model': (model as Input$NullableStringFieldUpdateOperationsInput?),
        if (promptTokens != _undefined)
          'promptTokens':
              (promptTokens as Input$NullableIntFieldUpdateOperationsInput?),
        if (raw != _undefined)
          'raw': (raw as Input$NullableStringFieldUpdateOperationsInput?),
        if (requestId != _undefined)
          'requestId':
              (requestId as Input$NullableStringFieldUpdateOperationsInput?),
        if (systemPrompt != _undefined)
          'systemPrompt':
              (systemPrompt as Input$NullableStringFieldUpdateOperationsInput?),
        if (totalTokens != _undefined)
          'totalTokens':
              (totalTokens as Input$NullableIntFieldUpdateOperationsInput?),
        if (updatedAt != _undefined)
          'updatedAt': (updatedAt as Input$DateTimeFieldUpdateOperationsInput?),
        if (userPrompt != _undefined)
          'userPrompt':
              (userPrompt as Input$NullableStringFieldUpdateOperationsInput?),
        if (uuid != _undefined)
          'uuid': (uuid as Input$StringFieldUpdateOperationsInput?),
      }));

  CopyWith$Input$NullableIntFieldUpdateOperationsInput<TRes>
      get completionTokens {
    final local$completionTokens = _instance.completionTokens;
    return local$completionTokens == null
        ? CopyWith$Input$NullableIntFieldUpdateOperationsInput.stub(
            _then(_instance))
        : CopyWith$Input$NullableIntFieldUpdateOperationsInput(
            local$completionTokens, (e) => call(completionTokens: e));
  }

  CopyWith$Input$BookRevisionUpdatecontentInput<TRes> get content {
    final local$content = _instance.content;
    return local$content == null
        ? CopyWith$Input$BookRevisionUpdatecontentInput.stub(_then(_instance))
        : CopyWith$Input$BookRevisionUpdatecontentInput(
            local$content, (e) => call(content: e));
  }

  CopyWith$Input$DateTimeFieldUpdateOperationsInput<TRes> get createdAt {
    final local$createdAt = _instance.createdAt;
    return local$createdAt == null
        ? CopyWith$Input$DateTimeFieldUpdateOperationsInput.stub(
            _then(_instance))
        : CopyWith$Input$DateTimeFieldUpdateOperationsInput(
            local$createdAt, (e) => call(createdAt: e));
  }

  CopyWith$Input$BoolFieldUpdateOperationsInput<TRes> get isRaw {
    final local$isRaw = _instance.isRaw;
    return local$isRaw == null
        ? CopyWith$Input$BoolFieldUpdateOperationsInput.stub(_then(_instance))
        : CopyWith$Input$BoolFieldUpdateOperationsInput(
            local$isRaw, (e) => call(isRaw: e));
  }

  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get model {
    final local$model = _instance.model;
    return local$model == null
        ? CopyWith$Input$NullableStringFieldUpdateOperationsInput.stub(
            _then(_instance))
        : CopyWith$Input$NullableStringFieldUpdateOperationsInput(
            local$model, (e) => call(model: e));
  }

  CopyWith$Input$NullableIntFieldUpdateOperationsInput<TRes> get promptTokens {
    final local$promptTokens = _instance.promptTokens;
    return local$promptTokens == null
        ? CopyWith$Input$NullableIntFieldUpdateOperationsInput.stub(
            _then(_instance))
        : CopyWith$Input$NullableIntFieldUpdateOperationsInput(
            local$promptTokens, (e) => call(promptTokens: e));
  }

  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get raw {
    final local$raw = _instance.raw;
    return local$raw == null
        ? CopyWith$Input$NullableStringFieldUpdateOperationsInput.stub(
            _then(_instance))
        : CopyWith$Input$NullableStringFieldUpdateOperationsInput(
            local$raw, (e) => call(raw: e));
  }

  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get requestId {
    final local$requestId = _instance.requestId;
    return local$requestId == null
        ? CopyWith$Input$NullableStringFieldUpdateOperationsInput.stub(
            _then(_instance))
        : CopyWith$Input$NullableStringFieldUpdateOperationsInput(
            local$requestId, (e) => call(requestId: e));
  }

  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes>
      get systemPrompt {
    final local$systemPrompt = _instance.systemPrompt;
    return local$systemPrompt == null
        ? CopyWith$Input$NullableStringFieldUpdateOperationsInput.stub(
            _then(_instance))
        : CopyWith$Input$NullableStringFieldUpdateOperationsInput(
            local$systemPrompt, (e) => call(systemPrompt: e));
  }

  CopyWith$Input$NullableIntFieldUpdateOperationsInput<TRes> get totalTokens {
    final local$totalTokens = _instance.totalTokens;
    return local$totalTokens == null
        ? CopyWith$Input$NullableIntFieldUpdateOperationsInput.stub(
            _then(_instance))
        : CopyWith$Input$NullableIntFieldUpdateOperationsInput(
            local$totalTokens, (e) => call(totalTokens: e));
  }

  CopyWith$Input$DateTimeFieldUpdateOperationsInput<TRes> get updatedAt {
    final local$updatedAt = _instance.updatedAt;
    return local$updatedAt == null
        ? CopyWith$Input$DateTimeFieldUpdateOperationsInput.stub(
            _then(_instance))
        : CopyWith$Input$DateTimeFieldUpdateOperationsInput(
            local$updatedAt, (e) => call(updatedAt: e));
  }

  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get userPrompt {
    final local$userPrompt = _instance.userPrompt;
    return local$userPrompt == null
        ? CopyWith$Input$NullableStringFieldUpdateOperationsInput.stub(
            _then(_instance))
        : CopyWith$Input$NullableStringFieldUpdateOperationsInput(
            local$userPrompt, (e) => call(userPrompt: e));
  }

  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get uuid {
    final local$uuid = _instance.uuid;
    return local$uuid == null
        ? CopyWith$Input$StringFieldUpdateOperationsInput.stub(_then(_instance))
        : CopyWith$Input$StringFieldUpdateOperationsInput(
            local$uuid, (e) => call(uuid: e));
  }
}

class _CopyWithStubImpl$Input$BookRevisionUpdateManyMutationInput<TRes>
    implements CopyWith$Input$BookRevisionUpdateManyMutationInput<TRes> {
  _CopyWithStubImpl$Input$BookRevisionUpdateManyMutationInput(this._res);

  TRes _res;

  call({
    Input$NullableIntFieldUpdateOperationsInput? completionTokens,
    Input$BookRevisionUpdatecontentInput? content,
    Input$DateTimeFieldUpdateOperationsInput? createdAt,
    Input$BoolFieldUpdateOperationsInput? isRaw,
    Input$NullableStringFieldUpdateOperationsInput? model,
    Input$NullableIntFieldUpdateOperationsInput? promptTokens,
    Input$NullableStringFieldUpdateOperationsInput? raw,
    Input$NullableStringFieldUpdateOperationsInput? requestId,
    Input$NullableStringFieldUpdateOperationsInput? systemPrompt,
    Input$NullableIntFieldUpdateOperationsInput? totalTokens,
    Input$DateTimeFieldUpdateOperationsInput? updatedAt,
    Input$NullableStringFieldUpdateOperationsInput? userPrompt,
    Input$StringFieldUpdateOperationsInput? uuid,
  }) =>
      _res;

  CopyWith$Input$NullableIntFieldUpdateOperationsInput<TRes>
      get completionTokens =>
          CopyWith$Input$NullableIntFieldUpdateOperationsInput.stub(_res);

  CopyWith$Input$BookRevisionUpdatecontentInput<TRes> get content =>
      CopyWith$Input$BookRevisionUpdatecontentInput.stub(_res);

  CopyWith$Input$DateTimeFieldUpdateOperationsInput<TRes> get createdAt =>
      CopyWith$Input$DateTimeFieldUpdateOperationsInput.stub(_res);

  CopyWith$Input$BoolFieldUpdateOperationsInput<TRes> get isRaw =>
      CopyWith$Input$BoolFieldUpdateOperationsInput.stub(_res);

  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get model =>
      CopyWith$Input$NullableStringFieldUpdateOperationsInput.stub(_res);

  CopyWith$Input$NullableIntFieldUpdateOperationsInput<TRes> get promptTokens =>
      CopyWith$Input$NullableIntFieldUpdateOperationsInput.stub(_res);

  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get raw =>
      CopyWith$Input$NullableStringFieldUpdateOperationsInput.stub(_res);

  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get requestId =>
      CopyWith$Input$NullableStringFieldUpdateOperationsInput.stub(_res);

  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes>
      get systemPrompt =>
          CopyWith$Input$NullableStringFieldUpdateOperationsInput.stub(_res);

  CopyWith$Input$NullableIntFieldUpdateOperationsInput<TRes> get totalTokens =>
      CopyWith$Input$NullableIntFieldUpdateOperationsInput.stub(_res);

  CopyWith$Input$DateTimeFieldUpdateOperationsInput<TRes> get updatedAt =>
      CopyWith$Input$DateTimeFieldUpdateOperationsInput.stub(_res);

  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes>
      get userPrompt =>
          CopyWith$Input$NullableStringFieldUpdateOperationsInput.stub(_res);

  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get uuid =>
      CopyWith$Input$StringFieldUpdateOperationsInput.stub(_res);
}

class Input$BookRevisionUpdateOneWithoutBookEditedNestedInput {
  factory Input$BookRevisionUpdateOneWithoutBookEditedNestedInput({
    Input$BookRevisionWhereUniqueInput? connect,
    Input$BookRevisionCreateOrConnectWithoutBookEditedInput? connectOrCreate,
    Input$BookRevisionCreateWithoutBookEditedInput? create,
    Input$BookRevisionWhereInput? delete,
    Input$BookRevisionWhereInput? disconnect,
    Input$BookRevisionUpdateToOneWithWhereWithoutBookEditedInput? update,
    Input$BookRevisionUpsertWithoutBookEditedInput? upsert,
  }) =>
      Input$BookRevisionUpdateOneWithoutBookEditedNestedInput._({
        if (connect != null) r'connect': connect,
        if (connectOrCreate != null) r'connectOrCreate': connectOrCreate,
        if (create != null) r'create': create,
        if (delete != null) r'delete': delete,
        if (disconnect != null) r'disconnect': disconnect,
        if (update != null) r'update': update,
        if (upsert != null) r'upsert': upsert,
      });

  Input$BookRevisionUpdateOneWithoutBookEditedNestedInput._(this._$data);

  factory Input$BookRevisionUpdateOneWithoutBookEditedNestedInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('connect')) {
      final l$connect = data['connect'];
      result$data['connect'] = l$connect == null
          ? null
          : Input$BookRevisionWhereUniqueInput.fromJson(
              (l$connect as Map<String, dynamic>));
    }
    if (data.containsKey('connectOrCreate')) {
      final l$connectOrCreate = data['connectOrCreate'];
      result$data['connectOrCreate'] = l$connectOrCreate == null
          ? null
          : Input$BookRevisionCreateOrConnectWithoutBookEditedInput.fromJson(
              (l$connectOrCreate as Map<String, dynamic>));
    }
    if (data.containsKey('create')) {
      final l$create = data['create'];
      result$data['create'] = l$create == null
          ? null
          : Input$BookRevisionCreateWithoutBookEditedInput.fromJson(
              (l$create as Map<String, dynamic>));
    }
    if (data.containsKey('delete')) {
      final l$delete = data['delete'];
      result$data['delete'] = l$delete == null
          ? null
          : Input$BookRevisionWhereInput.fromJson(
              (l$delete as Map<String, dynamic>));
    }
    if (data.containsKey('disconnect')) {
      final l$disconnect = data['disconnect'];
      result$data['disconnect'] = l$disconnect == null
          ? null
          : Input$BookRevisionWhereInput.fromJson(
              (l$disconnect as Map<String, dynamic>));
    }
    if (data.containsKey('update')) {
      final l$update = data['update'];
      result$data['update'] = l$update == null
          ? null
          : Input$BookRevisionUpdateToOneWithWhereWithoutBookEditedInput
              .fromJson((l$update as Map<String, dynamic>));
    }
    if (data.containsKey('upsert')) {
      final l$upsert = data['upsert'];
      result$data['upsert'] = l$upsert == null
          ? null
          : Input$BookRevisionUpsertWithoutBookEditedInput.fromJson(
              (l$upsert as Map<String, dynamic>));
    }
    return Input$BookRevisionUpdateOneWithoutBookEditedNestedInput._(
        result$data);
  }

  Map<String, dynamic> _$data;

  Input$BookRevisionWhereUniqueInput? get connect =>
      (_$data['connect'] as Input$BookRevisionWhereUniqueInput?);

  Input$BookRevisionCreateOrConnectWithoutBookEditedInput?
      get connectOrCreate => (_$data['connectOrCreate']
          as Input$BookRevisionCreateOrConnectWithoutBookEditedInput?);

  Input$BookRevisionCreateWithoutBookEditedInput? get create =>
      (_$data['create'] as Input$BookRevisionCreateWithoutBookEditedInput?);

  Input$BookRevisionWhereInput? get delete =>
      (_$data['delete'] as Input$BookRevisionWhereInput?);

  Input$BookRevisionWhereInput? get disconnect =>
      (_$data['disconnect'] as Input$BookRevisionWhereInput?);

  Input$BookRevisionUpdateToOneWithWhereWithoutBookEditedInput? get update =>
      (_$data['update']
          as Input$BookRevisionUpdateToOneWithWhereWithoutBookEditedInput?);

  Input$BookRevisionUpsertWithoutBookEditedInput? get upsert =>
      (_$data['upsert'] as Input$BookRevisionUpsertWithoutBookEditedInput?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('connect')) {
      final l$connect = connect;
      result$data['connect'] = l$connect?.toJson();
    }
    if (_$data.containsKey('connectOrCreate')) {
      final l$connectOrCreate = connectOrCreate;
      result$data['connectOrCreate'] = l$connectOrCreate?.toJson();
    }
    if (_$data.containsKey('create')) {
      final l$create = create;
      result$data['create'] = l$create?.toJson();
    }
    if (_$data.containsKey('delete')) {
      final l$delete = delete;
      result$data['delete'] = l$delete?.toJson();
    }
    if (_$data.containsKey('disconnect')) {
      final l$disconnect = disconnect;
      result$data['disconnect'] = l$disconnect?.toJson();
    }
    if (_$data.containsKey('update')) {
      final l$update = update;
      result$data['update'] = l$update?.toJson();
    }
    if (_$data.containsKey('upsert')) {
      final l$upsert = upsert;
      result$data['upsert'] = l$upsert?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$BookRevisionUpdateOneWithoutBookEditedNestedInput<
          Input$BookRevisionUpdateOneWithoutBookEditedNestedInput>
      get copyWith =>
          CopyWith$Input$BookRevisionUpdateOneWithoutBookEditedNestedInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$BookRevisionUpdateOneWithoutBookEditedNestedInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$connect = connect;
    final lOther$connect = other.connect;
    if (_$data.containsKey('connect') != other._$data.containsKey('connect')) {
      return false;
    }
    if (l$connect != lOther$connect) {
      return false;
    }
    final l$connectOrCreate = connectOrCreate;
    final lOther$connectOrCreate = other.connectOrCreate;
    if (_$data.containsKey('connectOrCreate') !=
        other._$data.containsKey('connectOrCreate')) {
      return false;
    }
    if (l$connectOrCreate != lOther$connectOrCreate) {
      return false;
    }
    final l$create = create;
    final lOther$create = other.create;
    if (_$data.containsKey('create') != other._$data.containsKey('create')) {
      return false;
    }
    if (l$create != lOther$create) {
      return false;
    }
    final l$delete = delete;
    final lOther$delete = other.delete;
    if (_$data.containsKey('delete') != other._$data.containsKey('delete')) {
      return false;
    }
    if (l$delete != lOther$delete) {
      return false;
    }
    final l$disconnect = disconnect;
    final lOther$disconnect = other.disconnect;
    if (_$data.containsKey('disconnect') !=
        other._$data.containsKey('disconnect')) {
      return false;
    }
    if (l$disconnect != lOther$disconnect) {
      return false;
    }
    final l$update = update;
    final lOther$update = other.update;
    if (_$data.containsKey('update') != other._$data.containsKey('update')) {
      return false;
    }
    if (l$update != lOther$update) {
      return false;
    }
    final l$upsert = upsert;
    final lOther$upsert = other.upsert;
    if (_$data.containsKey('upsert') != other._$data.containsKey('upsert')) {
      return false;
    }
    if (l$upsert != lOther$upsert) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$connect = connect;
    final l$connectOrCreate = connectOrCreate;
    final l$create = create;
    final l$delete = delete;
    final l$disconnect = disconnect;
    final l$update = update;
    final l$upsert = upsert;
    return Object.hashAll([
      _$data.containsKey('connect') ? l$connect : const {},
      _$data.containsKey('connectOrCreate') ? l$connectOrCreate : const {},
      _$data.containsKey('create') ? l$create : const {},
      _$data.containsKey('delete') ? l$delete : const {},
      _$data.containsKey('disconnect') ? l$disconnect : const {},
      _$data.containsKey('update') ? l$update : const {},
      _$data.containsKey('upsert') ? l$upsert : const {},
    ]);
  }
}

abstract class CopyWith$Input$BookRevisionUpdateOneWithoutBookEditedNestedInput<
    TRes> {
  factory CopyWith$Input$BookRevisionUpdateOneWithoutBookEditedNestedInput(
    Input$BookRevisionUpdateOneWithoutBookEditedNestedInput instance,
    TRes Function(Input$BookRevisionUpdateOneWithoutBookEditedNestedInput) then,
  ) = _CopyWithImpl$Input$BookRevisionUpdateOneWithoutBookEditedNestedInput;

  factory CopyWith$Input$BookRevisionUpdateOneWithoutBookEditedNestedInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$BookRevisionUpdateOneWithoutBookEditedNestedInput;

  TRes call({
    Input$BookRevisionWhereUniqueInput? connect,
    Input$BookRevisionCreateOrConnectWithoutBookEditedInput? connectOrCreate,
    Input$BookRevisionCreateWithoutBookEditedInput? create,
    Input$BookRevisionWhereInput? delete,
    Input$BookRevisionWhereInput? disconnect,
    Input$BookRevisionUpdateToOneWithWhereWithoutBookEditedInput? update,
    Input$BookRevisionUpsertWithoutBookEditedInput? upsert,
  });
  CopyWith$Input$BookRevisionWhereUniqueInput<TRes> get connect;
  CopyWith$Input$BookRevisionCreateOrConnectWithoutBookEditedInput<TRes>
      get connectOrCreate;
  CopyWith$Input$BookRevisionCreateWithoutBookEditedInput<TRes> get create;
  CopyWith$Input$BookRevisionWhereInput<TRes> get delete;
  CopyWith$Input$BookRevisionWhereInput<TRes> get disconnect;
  CopyWith$Input$BookRevisionUpdateToOneWithWhereWithoutBookEditedInput<TRes>
      get update;
  CopyWith$Input$BookRevisionUpsertWithoutBookEditedInput<TRes> get upsert;
}

class _CopyWithImpl$Input$BookRevisionUpdateOneWithoutBookEditedNestedInput<
        TRes>
    implements
        CopyWith$Input$BookRevisionUpdateOneWithoutBookEditedNestedInput<TRes> {
  _CopyWithImpl$Input$BookRevisionUpdateOneWithoutBookEditedNestedInput(
    this._instance,
    this._then,
  );

  final Input$BookRevisionUpdateOneWithoutBookEditedNestedInput _instance;

  final TRes Function(Input$BookRevisionUpdateOneWithoutBookEditedNestedInput)
      _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? connect = _undefined,
    Object? connectOrCreate = _undefined,
    Object? create = _undefined,
    Object? delete = _undefined,
    Object? disconnect = _undefined,
    Object? update = _undefined,
    Object? upsert = _undefined,
  }) =>
      _then(Input$BookRevisionUpdateOneWithoutBookEditedNestedInput._({
        ..._instance._$data,
        if (connect != _undefined)
          'connect': (connect as Input$BookRevisionWhereUniqueInput?),
        if (connectOrCreate != _undefined)
          'connectOrCreate': (connectOrCreate
              as Input$BookRevisionCreateOrConnectWithoutBookEditedInput?),
        if (create != _undefined)
          'create': (create as Input$BookRevisionCreateWithoutBookEditedInput?),
        if (delete != _undefined)
          'delete': (delete as Input$BookRevisionWhereInput?),
        if (disconnect != _undefined)
          'disconnect': (disconnect as Input$BookRevisionWhereInput?),
        if (update != _undefined)
          'update': (update
              as Input$BookRevisionUpdateToOneWithWhereWithoutBookEditedInput?),
        if (upsert != _undefined)
          'upsert': (upsert as Input$BookRevisionUpsertWithoutBookEditedInput?),
      }));

  CopyWith$Input$BookRevisionWhereUniqueInput<TRes> get connect {
    final local$connect = _instance.connect;
    return local$connect == null
        ? CopyWith$Input$BookRevisionWhereUniqueInput.stub(_then(_instance))
        : CopyWith$Input$BookRevisionWhereUniqueInput(
            local$connect, (e) => call(connect: e));
  }

  CopyWith$Input$BookRevisionCreateOrConnectWithoutBookEditedInput<TRes>
      get connectOrCreate {
    final local$connectOrCreate = _instance.connectOrCreate;
    return local$connectOrCreate == null
        ? CopyWith$Input$BookRevisionCreateOrConnectWithoutBookEditedInput.stub(
            _then(_instance))
        : CopyWith$Input$BookRevisionCreateOrConnectWithoutBookEditedInput(
            local$connectOrCreate, (e) => call(connectOrCreate: e));
  }

  CopyWith$Input$BookRevisionCreateWithoutBookEditedInput<TRes> get create {
    final local$create = _instance.create;
    return local$create == null
        ? CopyWith$Input$BookRevisionCreateWithoutBookEditedInput.stub(
            _then(_instance))
        : CopyWith$Input$BookRevisionCreateWithoutBookEditedInput(
            local$create, (e) => call(create: e));
  }

  CopyWith$Input$BookRevisionWhereInput<TRes> get delete {
    final local$delete = _instance.delete;
    return local$delete == null
        ? CopyWith$Input$BookRevisionWhereInput.stub(_then(_instance))
        : CopyWith$Input$BookRevisionWhereInput(
            local$delete, (e) => call(delete: e));
  }

  CopyWith$Input$BookRevisionWhereInput<TRes> get disconnect {
    final local$disconnect = _instance.disconnect;
    return local$disconnect == null
        ? CopyWith$Input$BookRevisionWhereInput.stub(_then(_instance))
        : CopyWith$Input$BookRevisionWhereInput(
            local$disconnect, (e) => call(disconnect: e));
  }

  CopyWith$Input$BookRevisionUpdateToOneWithWhereWithoutBookEditedInput<TRes>
      get update {
    final local$update = _instance.update;
    return local$update == null
        ? CopyWith$Input$BookRevisionUpdateToOneWithWhereWithoutBookEditedInput
            .stub(_then(_instance))
        : CopyWith$Input$BookRevisionUpdateToOneWithWhereWithoutBookEditedInput(
            local$update, (e) => call(update: e));
  }

  CopyWith$Input$BookRevisionUpsertWithoutBookEditedInput<TRes> get upsert {
    final local$upsert = _instance.upsert;
    return local$upsert == null
        ? CopyWith$Input$BookRevisionUpsertWithoutBookEditedInput.stub(
            _then(_instance))
        : CopyWith$Input$BookRevisionUpsertWithoutBookEditedInput(
            local$upsert, (e) => call(upsert: e));
  }
}

class _CopyWithStubImpl$Input$BookRevisionUpdateOneWithoutBookEditedNestedInput<
        TRes>
    implements
        CopyWith$Input$BookRevisionUpdateOneWithoutBookEditedNestedInput<TRes> {
  _CopyWithStubImpl$Input$BookRevisionUpdateOneWithoutBookEditedNestedInput(
      this._res);

  TRes _res;

  call({
    Input$BookRevisionWhereUniqueInput? connect,
    Input$BookRevisionCreateOrConnectWithoutBookEditedInput? connectOrCreate,
    Input$BookRevisionCreateWithoutBookEditedInput? create,
    Input$BookRevisionWhereInput? delete,
    Input$BookRevisionWhereInput? disconnect,
    Input$BookRevisionUpdateToOneWithWhereWithoutBookEditedInput? update,
    Input$BookRevisionUpsertWithoutBookEditedInput? upsert,
  }) =>
      _res;

  CopyWith$Input$BookRevisionWhereUniqueInput<TRes> get connect =>
      CopyWith$Input$BookRevisionWhereUniqueInput.stub(_res);

  CopyWith$Input$BookRevisionCreateOrConnectWithoutBookEditedInput<TRes>
      get connectOrCreate =>
          CopyWith$Input$BookRevisionCreateOrConnectWithoutBookEditedInput.stub(
              _res);

  CopyWith$Input$BookRevisionCreateWithoutBookEditedInput<TRes> get create =>
      CopyWith$Input$BookRevisionCreateWithoutBookEditedInput.stub(_res);

  CopyWith$Input$BookRevisionWhereInput<TRes> get delete =>
      CopyWith$Input$BookRevisionWhereInput.stub(_res);

  CopyWith$Input$BookRevisionWhereInput<TRes> get disconnect =>
      CopyWith$Input$BookRevisionWhereInput.stub(_res);

  CopyWith$Input$BookRevisionUpdateToOneWithWhereWithoutBookEditedInput<TRes>
      get update =>
          CopyWith$Input$BookRevisionUpdateToOneWithWhereWithoutBookEditedInput
              .stub(_res);

  CopyWith$Input$BookRevisionUpsertWithoutBookEditedInput<TRes> get upsert =>
      CopyWith$Input$BookRevisionUpsertWithoutBookEditedInput.stub(_res);
}

class Input$BookRevisionUpdateOneWithoutBookRawNestedInput {
  factory Input$BookRevisionUpdateOneWithoutBookRawNestedInput({
    Input$BookRevisionWhereUniqueInput? connect,
    Input$BookRevisionCreateOrConnectWithoutBookRawInput? connectOrCreate,
    Input$BookRevisionCreateWithoutBookRawInput? create,
    Input$BookRevisionWhereInput? delete,
    Input$BookRevisionWhereInput? disconnect,
    Input$BookRevisionUpdateToOneWithWhereWithoutBookRawInput? update,
    Input$BookRevisionUpsertWithoutBookRawInput? upsert,
  }) =>
      Input$BookRevisionUpdateOneWithoutBookRawNestedInput._({
        if (connect != null) r'connect': connect,
        if (connectOrCreate != null) r'connectOrCreate': connectOrCreate,
        if (create != null) r'create': create,
        if (delete != null) r'delete': delete,
        if (disconnect != null) r'disconnect': disconnect,
        if (update != null) r'update': update,
        if (upsert != null) r'upsert': upsert,
      });

  Input$BookRevisionUpdateOneWithoutBookRawNestedInput._(this._$data);

  factory Input$BookRevisionUpdateOneWithoutBookRawNestedInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('connect')) {
      final l$connect = data['connect'];
      result$data['connect'] = l$connect == null
          ? null
          : Input$BookRevisionWhereUniqueInput.fromJson(
              (l$connect as Map<String, dynamic>));
    }
    if (data.containsKey('connectOrCreate')) {
      final l$connectOrCreate = data['connectOrCreate'];
      result$data['connectOrCreate'] = l$connectOrCreate == null
          ? null
          : Input$BookRevisionCreateOrConnectWithoutBookRawInput.fromJson(
              (l$connectOrCreate as Map<String, dynamic>));
    }
    if (data.containsKey('create')) {
      final l$create = data['create'];
      result$data['create'] = l$create == null
          ? null
          : Input$BookRevisionCreateWithoutBookRawInput.fromJson(
              (l$create as Map<String, dynamic>));
    }
    if (data.containsKey('delete')) {
      final l$delete = data['delete'];
      result$data['delete'] = l$delete == null
          ? null
          : Input$BookRevisionWhereInput.fromJson(
              (l$delete as Map<String, dynamic>));
    }
    if (data.containsKey('disconnect')) {
      final l$disconnect = data['disconnect'];
      result$data['disconnect'] = l$disconnect == null
          ? null
          : Input$BookRevisionWhereInput.fromJson(
              (l$disconnect as Map<String, dynamic>));
    }
    if (data.containsKey('update')) {
      final l$update = data['update'];
      result$data['update'] = l$update == null
          ? null
          : Input$BookRevisionUpdateToOneWithWhereWithoutBookRawInput.fromJson(
              (l$update as Map<String, dynamic>));
    }
    if (data.containsKey('upsert')) {
      final l$upsert = data['upsert'];
      result$data['upsert'] = l$upsert == null
          ? null
          : Input$BookRevisionUpsertWithoutBookRawInput.fromJson(
              (l$upsert as Map<String, dynamic>));
    }
    return Input$BookRevisionUpdateOneWithoutBookRawNestedInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$BookRevisionWhereUniqueInput? get connect =>
      (_$data['connect'] as Input$BookRevisionWhereUniqueInput?);

  Input$BookRevisionCreateOrConnectWithoutBookRawInput? get connectOrCreate =>
      (_$data['connectOrCreate']
          as Input$BookRevisionCreateOrConnectWithoutBookRawInput?);

  Input$BookRevisionCreateWithoutBookRawInput? get create =>
      (_$data['create'] as Input$BookRevisionCreateWithoutBookRawInput?);

  Input$BookRevisionWhereInput? get delete =>
      (_$data['delete'] as Input$BookRevisionWhereInput?);

  Input$BookRevisionWhereInput? get disconnect =>
      (_$data['disconnect'] as Input$BookRevisionWhereInput?);

  Input$BookRevisionUpdateToOneWithWhereWithoutBookRawInput? get update =>
      (_$data['update']
          as Input$BookRevisionUpdateToOneWithWhereWithoutBookRawInput?);

  Input$BookRevisionUpsertWithoutBookRawInput? get upsert =>
      (_$data['upsert'] as Input$BookRevisionUpsertWithoutBookRawInput?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('connect')) {
      final l$connect = connect;
      result$data['connect'] = l$connect?.toJson();
    }
    if (_$data.containsKey('connectOrCreate')) {
      final l$connectOrCreate = connectOrCreate;
      result$data['connectOrCreate'] = l$connectOrCreate?.toJson();
    }
    if (_$data.containsKey('create')) {
      final l$create = create;
      result$data['create'] = l$create?.toJson();
    }
    if (_$data.containsKey('delete')) {
      final l$delete = delete;
      result$data['delete'] = l$delete?.toJson();
    }
    if (_$data.containsKey('disconnect')) {
      final l$disconnect = disconnect;
      result$data['disconnect'] = l$disconnect?.toJson();
    }
    if (_$data.containsKey('update')) {
      final l$update = update;
      result$data['update'] = l$update?.toJson();
    }
    if (_$data.containsKey('upsert')) {
      final l$upsert = upsert;
      result$data['upsert'] = l$upsert?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$BookRevisionUpdateOneWithoutBookRawNestedInput<
          Input$BookRevisionUpdateOneWithoutBookRawNestedInput>
      get copyWith =>
          CopyWith$Input$BookRevisionUpdateOneWithoutBookRawNestedInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$BookRevisionUpdateOneWithoutBookRawNestedInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$connect = connect;
    final lOther$connect = other.connect;
    if (_$data.containsKey('connect') != other._$data.containsKey('connect')) {
      return false;
    }
    if (l$connect != lOther$connect) {
      return false;
    }
    final l$connectOrCreate = connectOrCreate;
    final lOther$connectOrCreate = other.connectOrCreate;
    if (_$data.containsKey('connectOrCreate') !=
        other._$data.containsKey('connectOrCreate')) {
      return false;
    }
    if (l$connectOrCreate != lOther$connectOrCreate) {
      return false;
    }
    final l$create = create;
    final lOther$create = other.create;
    if (_$data.containsKey('create') != other._$data.containsKey('create')) {
      return false;
    }
    if (l$create != lOther$create) {
      return false;
    }
    final l$delete = delete;
    final lOther$delete = other.delete;
    if (_$data.containsKey('delete') != other._$data.containsKey('delete')) {
      return false;
    }
    if (l$delete != lOther$delete) {
      return false;
    }
    final l$disconnect = disconnect;
    final lOther$disconnect = other.disconnect;
    if (_$data.containsKey('disconnect') !=
        other._$data.containsKey('disconnect')) {
      return false;
    }
    if (l$disconnect != lOther$disconnect) {
      return false;
    }
    final l$update = update;
    final lOther$update = other.update;
    if (_$data.containsKey('update') != other._$data.containsKey('update')) {
      return false;
    }
    if (l$update != lOther$update) {
      return false;
    }
    final l$upsert = upsert;
    final lOther$upsert = other.upsert;
    if (_$data.containsKey('upsert') != other._$data.containsKey('upsert')) {
      return false;
    }
    if (l$upsert != lOther$upsert) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$connect = connect;
    final l$connectOrCreate = connectOrCreate;
    final l$create = create;
    final l$delete = delete;
    final l$disconnect = disconnect;
    final l$update = update;
    final l$upsert = upsert;
    return Object.hashAll([
      _$data.containsKey('connect') ? l$connect : const {},
      _$data.containsKey('connectOrCreate') ? l$connectOrCreate : const {},
      _$data.containsKey('create') ? l$create : const {},
      _$data.containsKey('delete') ? l$delete : const {},
      _$data.containsKey('disconnect') ? l$disconnect : const {},
      _$data.containsKey('update') ? l$update : const {},
      _$data.containsKey('upsert') ? l$upsert : const {},
    ]);
  }
}

abstract class CopyWith$Input$BookRevisionUpdateOneWithoutBookRawNestedInput<
    TRes> {
  factory CopyWith$Input$BookRevisionUpdateOneWithoutBookRawNestedInput(
    Input$BookRevisionUpdateOneWithoutBookRawNestedInput instance,
    TRes Function(Input$BookRevisionUpdateOneWithoutBookRawNestedInput) then,
  ) = _CopyWithImpl$Input$BookRevisionUpdateOneWithoutBookRawNestedInput;

  factory CopyWith$Input$BookRevisionUpdateOneWithoutBookRawNestedInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$BookRevisionUpdateOneWithoutBookRawNestedInput;

  TRes call({
    Input$BookRevisionWhereUniqueInput? connect,
    Input$BookRevisionCreateOrConnectWithoutBookRawInput? connectOrCreate,
    Input$BookRevisionCreateWithoutBookRawInput? create,
    Input$BookRevisionWhereInput? delete,
    Input$BookRevisionWhereInput? disconnect,
    Input$BookRevisionUpdateToOneWithWhereWithoutBookRawInput? update,
    Input$BookRevisionUpsertWithoutBookRawInput? upsert,
  });
  CopyWith$Input$BookRevisionWhereUniqueInput<TRes> get connect;
  CopyWith$Input$BookRevisionCreateOrConnectWithoutBookRawInput<TRes>
      get connectOrCreate;
  CopyWith$Input$BookRevisionCreateWithoutBookRawInput<TRes> get create;
  CopyWith$Input$BookRevisionWhereInput<TRes> get delete;
  CopyWith$Input$BookRevisionWhereInput<TRes> get disconnect;
  CopyWith$Input$BookRevisionUpdateToOneWithWhereWithoutBookRawInput<TRes>
      get update;
  CopyWith$Input$BookRevisionUpsertWithoutBookRawInput<TRes> get upsert;
}

class _CopyWithImpl$Input$BookRevisionUpdateOneWithoutBookRawNestedInput<TRes>
    implements
        CopyWith$Input$BookRevisionUpdateOneWithoutBookRawNestedInput<TRes> {
  _CopyWithImpl$Input$BookRevisionUpdateOneWithoutBookRawNestedInput(
    this._instance,
    this._then,
  );

  final Input$BookRevisionUpdateOneWithoutBookRawNestedInput _instance;

  final TRes Function(Input$BookRevisionUpdateOneWithoutBookRawNestedInput)
      _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? connect = _undefined,
    Object? connectOrCreate = _undefined,
    Object? create = _undefined,
    Object? delete = _undefined,
    Object? disconnect = _undefined,
    Object? update = _undefined,
    Object? upsert = _undefined,
  }) =>
      _then(Input$BookRevisionUpdateOneWithoutBookRawNestedInput._({
        ..._instance._$data,
        if (connect != _undefined)
          'connect': (connect as Input$BookRevisionWhereUniqueInput?),
        if (connectOrCreate != _undefined)
          'connectOrCreate': (connectOrCreate
              as Input$BookRevisionCreateOrConnectWithoutBookRawInput?),
        if (create != _undefined)
          'create': (create as Input$BookRevisionCreateWithoutBookRawInput?),
        if (delete != _undefined)
          'delete': (delete as Input$BookRevisionWhereInput?),
        if (disconnect != _undefined)
          'disconnect': (disconnect as Input$BookRevisionWhereInput?),
        if (update != _undefined)
          'update': (update
              as Input$BookRevisionUpdateToOneWithWhereWithoutBookRawInput?),
        if (upsert != _undefined)
          'upsert': (upsert as Input$BookRevisionUpsertWithoutBookRawInput?),
      }));

  CopyWith$Input$BookRevisionWhereUniqueInput<TRes> get connect {
    final local$connect = _instance.connect;
    return local$connect == null
        ? CopyWith$Input$BookRevisionWhereUniqueInput.stub(_then(_instance))
        : CopyWith$Input$BookRevisionWhereUniqueInput(
            local$connect, (e) => call(connect: e));
  }

  CopyWith$Input$BookRevisionCreateOrConnectWithoutBookRawInput<TRes>
      get connectOrCreate {
    final local$connectOrCreate = _instance.connectOrCreate;
    return local$connectOrCreate == null
        ? CopyWith$Input$BookRevisionCreateOrConnectWithoutBookRawInput.stub(
            _then(_instance))
        : CopyWith$Input$BookRevisionCreateOrConnectWithoutBookRawInput(
            local$connectOrCreate, (e) => call(connectOrCreate: e));
  }

  CopyWith$Input$BookRevisionCreateWithoutBookRawInput<TRes> get create {
    final local$create = _instance.create;
    return local$create == null
        ? CopyWith$Input$BookRevisionCreateWithoutBookRawInput.stub(
            _then(_instance))
        : CopyWith$Input$BookRevisionCreateWithoutBookRawInput(
            local$create, (e) => call(create: e));
  }

  CopyWith$Input$BookRevisionWhereInput<TRes> get delete {
    final local$delete = _instance.delete;
    return local$delete == null
        ? CopyWith$Input$BookRevisionWhereInput.stub(_then(_instance))
        : CopyWith$Input$BookRevisionWhereInput(
            local$delete, (e) => call(delete: e));
  }

  CopyWith$Input$BookRevisionWhereInput<TRes> get disconnect {
    final local$disconnect = _instance.disconnect;
    return local$disconnect == null
        ? CopyWith$Input$BookRevisionWhereInput.stub(_then(_instance))
        : CopyWith$Input$BookRevisionWhereInput(
            local$disconnect, (e) => call(disconnect: e));
  }

  CopyWith$Input$BookRevisionUpdateToOneWithWhereWithoutBookRawInput<TRes>
      get update {
    final local$update = _instance.update;
    return local$update == null
        ? CopyWith$Input$BookRevisionUpdateToOneWithWhereWithoutBookRawInput
            .stub(_then(_instance))
        : CopyWith$Input$BookRevisionUpdateToOneWithWhereWithoutBookRawInput(
            local$update, (e) => call(update: e));
  }

  CopyWith$Input$BookRevisionUpsertWithoutBookRawInput<TRes> get upsert {
    final local$upsert = _instance.upsert;
    return local$upsert == null
        ? CopyWith$Input$BookRevisionUpsertWithoutBookRawInput.stub(
            _then(_instance))
        : CopyWith$Input$BookRevisionUpsertWithoutBookRawInput(
            local$upsert, (e) => call(upsert: e));
  }
}

class _CopyWithStubImpl$Input$BookRevisionUpdateOneWithoutBookRawNestedInput<
        TRes>
    implements
        CopyWith$Input$BookRevisionUpdateOneWithoutBookRawNestedInput<TRes> {
  _CopyWithStubImpl$Input$BookRevisionUpdateOneWithoutBookRawNestedInput(
      this._res);

  TRes _res;

  call({
    Input$BookRevisionWhereUniqueInput? connect,
    Input$BookRevisionCreateOrConnectWithoutBookRawInput? connectOrCreate,
    Input$BookRevisionCreateWithoutBookRawInput? create,
    Input$BookRevisionWhereInput? delete,
    Input$BookRevisionWhereInput? disconnect,
    Input$BookRevisionUpdateToOneWithWhereWithoutBookRawInput? update,
    Input$BookRevisionUpsertWithoutBookRawInput? upsert,
  }) =>
      _res;

  CopyWith$Input$BookRevisionWhereUniqueInput<TRes> get connect =>
      CopyWith$Input$BookRevisionWhereUniqueInput.stub(_res);

  CopyWith$Input$BookRevisionCreateOrConnectWithoutBookRawInput<TRes>
      get connectOrCreate =>
          CopyWith$Input$BookRevisionCreateOrConnectWithoutBookRawInput.stub(
              _res);

  CopyWith$Input$BookRevisionCreateWithoutBookRawInput<TRes> get create =>
      CopyWith$Input$BookRevisionCreateWithoutBookRawInput.stub(_res);

  CopyWith$Input$BookRevisionWhereInput<TRes> get delete =>
      CopyWith$Input$BookRevisionWhereInput.stub(_res);

  CopyWith$Input$BookRevisionWhereInput<TRes> get disconnect =>
      CopyWith$Input$BookRevisionWhereInput.stub(_res);

  CopyWith$Input$BookRevisionUpdateToOneWithWhereWithoutBookRawInput<TRes>
      get update =>
          CopyWith$Input$BookRevisionUpdateToOneWithWhereWithoutBookRawInput
              .stub(_res);

  CopyWith$Input$BookRevisionUpsertWithoutBookRawInput<TRes> get upsert =>
      CopyWith$Input$BookRevisionUpsertWithoutBookRawInput.stub(_res);
}

class Input$BookRevisionUpdateToOneWithWhereWithoutBookEditedInput {
  factory Input$BookRevisionUpdateToOneWithWhereWithoutBookEditedInput({
    required Input$BookRevisionUpdateWithoutBookEditedInput data,
    Input$BookRevisionWhereInput? where,
  }) =>
      Input$BookRevisionUpdateToOneWithWhereWithoutBookEditedInput._({
        r'data': data,
        if (where != null) r'where': where,
      });

  Input$BookRevisionUpdateToOneWithWhereWithoutBookEditedInput._(this._$data);

  factory Input$BookRevisionUpdateToOneWithWhereWithoutBookEditedInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$data = data['data'];
    result$data['data'] =
        Input$BookRevisionUpdateWithoutBookEditedInput.fromJson(
            (l$data as Map<String, dynamic>));
    if (data.containsKey('where')) {
      final l$where = data['where'];
      result$data['where'] = l$where == null
          ? null
          : Input$BookRevisionWhereInput.fromJson(
              (l$where as Map<String, dynamic>));
    }
    return Input$BookRevisionUpdateToOneWithWhereWithoutBookEditedInput._(
        result$data);
  }

  Map<String, dynamic> _$data;

  Input$BookRevisionUpdateWithoutBookEditedInput get data =>
      (_$data['data'] as Input$BookRevisionUpdateWithoutBookEditedInput);

  Input$BookRevisionWhereInput? get where =>
      (_$data['where'] as Input$BookRevisionWhereInput?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$data = data;
    result$data['data'] = l$data.toJson();
    if (_$data.containsKey('where')) {
      final l$where = where;
      result$data['where'] = l$where?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$BookRevisionUpdateToOneWithWhereWithoutBookEditedInput<
          Input$BookRevisionUpdateToOneWithWhereWithoutBookEditedInput>
      get copyWith =>
          CopyWith$Input$BookRevisionUpdateToOneWithWhereWithoutBookEditedInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other
            is Input$BookRevisionUpdateToOneWithWhereWithoutBookEditedInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$data = data;
    final lOther$data = other.data;
    if (l$data != lOther$data) {
      return false;
    }
    final l$where = where;
    final lOther$where = other.where;
    if (_$data.containsKey('where') != other._$data.containsKey('where')) {
      return false;
    }
    if (l$where != lOther$where) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$data = data;
    final l$where = where;
    return Object.hashAll([
      l$data,
      _$data.containsKey('where') ? l$where : const {},
    ]);
  }
}

abstract class CopyWith$Input$BookRevisionUpdateToOneWithWhereWithoutBookEditedInput<
    TRes> {
  factory CopyWith$Input$BookRevisionUpdateToOneWithWhereWithoutBookEditedInput(
    Input$BookRevisionUpdateToOneWithWhereWithoutBookEditedInput instance,
    TRes Function(Input$BookRevisionUpdateToOneWithWhereWithoutBookEditedInput)
        then,
  ) = _CopyWithImpl$Input$BookRevisionUpdateToOneWithWhereWithoutBookEditedInput;

  factory CopyWith$Input$BookRevisionUpdateToOneWithWhereWithoutBookEditedInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$BookRevisionUpdateToOneWithWhereWithoutBookEditedInput;

  TRes call({
    Input$BookRevisionUpdateWithoutBookEditedInput? data,
    Input$BookRevisionWhereInput? where,
  });
  CopyWith$Input$BookRevisionUpdateWithoutBookEditedInput<TRes> get data;
  CopyWith$Input$BookRevisionWhereInput<TRes> get where;
}

class _CopyWithImpl$Input$BookRevisionUpdateToOneWithWhereWithoutBookEditedInput<
        TRes>
    implements
        CopyWith$Input$BookRevisionUpdateToOneWithWhereWithoutBookEditedInput<
            TRes> {
  _CopyWithImpl$Input$BookRevisionUpdateToOneWithWhereWithoutBookEditedInput(
    this._instance,
    this._then,
  );

  final Input$BookRevisionUpdateToOneWithWhereWithoutBookEditedInput _instance;

  final TRes Function(
      Input$BookRevisionUpdateToOneWithWhereWithoutBookEditedInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? data = _undefined,
    Object? where = _undefined,
  }) =>
      _then(Input$BookRevisionUpdateToOneWithWhereWithoutBookEditedInput._({
        ..._instance._$data,
        if (data != _undefined && data != null)
          'data': (data as Input$BookRevisionUpdateWithoutBookEditedInput),
        if (where != _undefined)
          'where': (where as Input$BookRevisionWhereInput?),
      }));

  CopyWith$Input$BookRevisionUpdateWithoutBookEditedInput<TRes> get data {
    final local$data = _instance.data;
    return CopyWith$Input$BookRevisionUpdateWithoutBookEditedInput(
        local$data, (e) => call(data: e));
  }

  CopyWith$Input$BookRevisionWhereInput<TRes> get where {
    final local$where = _instance.where;
    return local$where == null
        ? CopyWith$Input$BookRevisionWhereInput.stub(_then(_instance))
        : CopyWith$Input$BookRevisionWhereInput(
            local$where, (e) => call(where: e));
  }
}

class _CopyWithStubImpl$Input$BookRevisionUpdateToOneWithWhereWithoutBookEditedInput<
        TRes>
    implements
        CopyWith$Input$BookRevisionUpdateToOneWithWhereWithoutBookEditedInput<
            TRes> {
  _CopyWithStubImpl$Input$BookRevisionUpdateToOneWithWhereWithoutBookEditedInput(
      this._res);

  TRes _res;

  call({
    Input$BookRevisionUpdateWithoutBookEditedInput? data,
    Input$BookRevisionWhereInput? where,
  }) =>
      _res;

  CopyWith$Input$BookRevisionUpdateWithoutBookEditedInput<TRes> get data =>
      CopyWith$Input$BookRevisionUpdateWithoutBookEditedInput.stub(_res);

  CopyWith$Input$BookRevisionWhereInput<TRes> get where =>
      CopyWith$Input$BookRevisionWhereInput.stub(_res);
}

class Input$BookRevisionUpdateToOneWithWhereWithoutBookRawInput {
  factory Input$BookRevisionUpdateToOneWithWhereWithoutBookRawInput({
    required Input$BookRevisionUpdateWithoutBookRawInput data,
    Input$BookRevisionWhereInput? where,
  }) =>
      Input$BookRevisionUpdateToOneWithWhereWithoutBookRawInput._({
        r'data': data,
        if (where != null) r'where': where,
      });

  Input$BookRevisionUpdateToOneWithWhereWithoutBookRawInput._(this._$data);

  factory Input$BookRevisionUpdateToOneWithWhereWithoutBookRawInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$data = data['data'];
    result$data['data'] = Input$BookRevisionUpdateWithoutBookRawInput.fromJson(
        (l$data as Map<String, dynamic>));
    if (data.containsKey('where')) {
      final l$where = data['where'];
      result$data['where'] = l$where == null
          ? null
          : Input$BookRevisionWhereInput.fromJson(
              (l$where as Map<String, dynamic>));
    }
    return Input$BookRevisionUpdateToOneWithWhereWithoutBookRawInput._(
        result$data);
  }

  Map<String, dynamic> _$data;

  Input$BookRevisionUpdateWithoutBookRawInput get data =>
      (_$data['data'] as Input$BookRevisionUpdateWithoutBookRawInput);

  Input$BookRevisionWhereInput? get where =>
      (_$data['where'] as Input$BookRevisionWhereInput?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$data = data;
    result$data['data'] = l$data.toJson();
    if (_$data.containsKey('where')) {
      final l$where = where;
      result$data['where'] = l$where?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$BookRevisionUpdateToOneWithWhereWithoutBookRawInput<
          Input$BookRevisionUpdateToOneWithWhereWithoutBookRawInput>
      get copyWith =>
          CopyWith$Input$BookRevisionUpdateToOneWithWhereWithoutBookRawInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$BookRevisionUpdateToOneWithWhereWithoutBookRawInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$data = data;
    final lOther$data = other.data;
    if (l$data != lOther$data) {
      return false;
    }
    final l$where = where;
    final lOther$where = other.where;
    if (_$data.containsKey('where') != other._$data.containsKey('where')) {
      return false;
    }
    if (l$where != lOther$where) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$data = data;
    final l$where = where;
    return Object.hashAll([
      l$data,
      _$data.containsKey('where') ? l$where : const {},
    ]);
  }
}

abstract class CopyWith$Input$BookRevisionUpdateToOneWithWhereWithoutBookRawInput<
    TRes> {
  factory CopyWith$Input$BookRevisionUpdateToOneWithWhereWithoutBookRawInput(
    Input$BookRevisionUpdateToOneWithWhereWithoutBookRawInput instance,
    TRes Function(Input$BookRevisionUpdateToOneWithWhereWithoutBookRawInput)
        then,
  ) = _CopyWithImpl$Input$BookRevisionUpdateToOneWithWhereWithoutBookRawInput;

  factory CopyWith$Input$BookRevisionUpdateToOneWithWhereWithoutBookRawInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$BookRevisionUpdateToOneWithWhereWithoutBookRawInput;

  TRes call({
    Input$BookRevisionUpdateWithoutBookRawInput? data,
    Input$BookRevisionWhereInput? where,
  });
  CopyWith$Input$BookRevisionUpdateWithoutBookRawInput<TRes> get data;
  CopyWith$Input$BookRevisionWhereInput<TRes> get where;
}

class _CopyWithImpl$Input$BookRevisionUpdateToOneWithWhereWithoutBookRawInput<
        TRes>
    implements
        CopyWith$Input$BookRevisionUpdateToOneWithWhereWithoutBookRawInput<
            TRes> {
  _CopyWithImpl$Input$BookRevisionUpdateToOneWithWhereWithoutBookRawInput(
    this._instance,
    this._then,
  );

  final Input$BookRevisionUpdateToOneWithWhereWithoutBookRawInput _instance;

  final TRes Function(Input$BookRevisionUpdateToOneWithWhereWithoutBookRawInput)
      _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? data = _undefined,
    Object? where = _undefined,
  }) =>
      _then(Input$BookRevisionUpdateToOneWithWhereWithoutBookRawInput._({
        ..._instance._$data,
        if (data != _undefined && data != null)
          'data': (data as Input$BookRevisionUpdateWithoutBookRawInput),
        if (where != _undefined)
          'where': (where as Input$BookRevisionWhereInput?),
      }));

  CopyWith$Input$BookRevisionUpdateWithoutBookRawInput<TRes> get data {
    final local$data = _instance.data;
    return CopyWith$Input$BookRevisionUpdateWithoutBookRawInput(
        local$data, (e) => call(data: e));
  }

  CopyWith$Input$BookRevisionWhereInput<TRes> get where {
    final local$where = _instance.where;
    return local$where == null
        ? CopyWith$Input$BookRevisionWhereInput.stub(_then(_instance))
        : CopyWith$Input$BookRevisionWhereInput(
            local$where, (e) => call(where: e));
  }
}

class _CopyWithStubImpl$Input$BookRevisionUpdateToOneWithWhereWithoutBookRawInput<
        TRes>
    implements
        CopyWith$Input$BookRevisionUpdateToOneWithWhereWithoutBookRawInput<
            TRes> {
  _CopyWithStubImpl$Input$BookRevisionUpdateToOneWithWhereWithoutBookRawInput(
      this._res);

  TRes _res;

  call({
    Input$BookRevisionUpdateWithoutBookRawInput? data,
    Input$BookRevisionWhereInput? where,
  }) =>
      _res;

  CopyWith$Input$BookRevisionUpdateWithoutBookRawInput<TRes> get data =>
      CopyWith$Input$BookRevisionUpdateWithoutBookRawInput.stub(_res);

  CopyWith$Input$BookRevisionWhereInput<TRes> get where =>
      CopyWith$Input$BookRevisionWhereInput.stub(_res);
}

class Input$BookRevisionUpdateWithoutBookEditedInput {
  factory Input$BookRevisionUpdateWithoutBookEditedInput({
    Input$BookUpdateOneWithoutBookRawNestedInput? bookRaw,
    Input$NullableIntFieldUpdateOperationsInput? completionTokens,
    Input$BookRevisionUpdatecontentInput? content,
    Input$DateTimeFieldUpdateOperationsInput? createdAt,
    Input$BoolFieldUpdateOperationsInput? isRaw,
    Input$NullableStringFieldUpdateOperationsInput? model,
    Input$NullableIntFieldUpdateOperationsInput? promptTokens,
    Input$NullableStringFieldUpdateOperationsInput? raw,
    Input$NullableStringFieldUpdateOperationsInput? requestId,
    Input$NullableStringFieldUpdateOperationsInput? systemPrompt,
    Input$NullableIntFieldUpdateOperationsInput? totalTokens,
    Input$DateTimeFieldUpdateOperationsInput? updatedAt,
    Input$NullableStringFieldUpdateOperationsInput? userPrompt,
    Input$StringFieldUpdateOperationsInput? uuid,
  }) =>
      Input$BookRevisionUpdateWithoutBookEditedInput._({
        if (bookRaw != null) r'bookRaw': bookRaw,
        if (completionTokens != null) r'completionTokens': completionTokens,
        if (content != null) r'content': content,
        if (createdAt != null) r'createdAt': createdAt,
        if (isRaw != null) r'isRaw': isRaw,
        if (model != null) r'model': model,
        if (promptTokens != null) r'promptTokens': promptTokens,
        if (raw != null) r'raw': raw,
        if (requestId != null) r'requestId': requestId,
        if (systemPrompt != null) r'systemPrompt': systemPrompt,
        if (totalTokens != null) r'totalTokens': totalTokens,
        if (updatedAt != null) r'updatedAt': updatedAt,
        if (userPrompt != null) r'userPrompt': userPrompt,
        if (uuid != null) r'uuid': uuid,
      });

  Input$BookRevisionUpdateWithoutBookEditedInput._(this._$data);

  factory Input$BookRevisionUpdateWithoutBookEditedInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('bookRaw')) {
      final l$bookRaw = data['bookRaw'];
      result$data['bookRaw'] = l$bookRaw == null
          ? null
          : Input$BookUpdateOneWithoutBookRawNestedInput.fromJson(
              (l$bookRaw as Map<String, dynamic>));
    }
    if (data.containsKey('completionTokens')) {
      final l$completionTokens = data['completionTokens'];
      result$data['completionTokens'] = l$completionTokens == null
          ? null
          : Input$NullableIntFieldUpdateOperationsInput.fromJson(
              (l$completionTokens as Map<String, dynamic>));
    }
    if (data.containsKey('content')) {
      final l$content = data['content'];
      result$data['content'] = l$content == null
          ? null
          : Input$BookRevisionUpdatecontentInput.fromJson(
              (l$content as Map<String, dynamic>));
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : Input$DateTimeFieldUpdateOperationsInput.fromJson(
              (l$createdAt as Map<String, dynamic>));
    }
    if (data.containsKey('isRaw')) {
      final l$isRaw = data['isRaw'];
      result$data['isRaw'] = l$isRaw == null
          ? null
          : Input$BoolFieldUpdateOperationsInput.fromJson(
              (l$isRaw as Map<String, dynamic>));
    }
    if (data.containsKey('model')) {
      final l$model = data['model'];
      result$data['model'] = l$model == null
          ? null
          : Input$NullableStringFieldUpdateOperationsInput.fromJson(
              (l$model as Map<String, dynamic>));
    }
    if (data.containsKey('promptTokens')) {
      final l$promptTokens = data['promptTokens'];
      result$data['promptTokens'] = l$promptTokens == null
          ? null
          : Input$NullableIntFieldUpdateOperationsInput.fromJson(
              (l$promptTokens as Map<String, dynamic>));
    }
    if (data.containsKey('raw')) {
      final l$raw = data['raw'];
      result$data['raw'] = l$raw == null
          ? null
          : Input$NullableStringFieldUpdateOperationsInput.fromJson(
              (l$raw as Map<String, dynamic>));
    }
    if (data.containsKey('requestId')) {
      final l$requestId = data['requestId'];
      result$data['requestId'] = l$requestId == null
          ? null
          : Input$NullableStringFieldUpdateOperationsInput.fromJson(
              (l$requestId as Map<String, dynamic>));
    }
    if (data.containsKey('systemPrompt')) {
      final l$systemPrompt = data['systemPrompt'];
      result$data['systemPrompt'] = l$systemPrompt == null
          ? null
          : Input$NullableStringFieldUpdateOperationsInput.fromJson(
              (l$systemPrompt as Map<String, dynamic>));
    }
    if (data.containsKey('totalTokens')) {
      final l$totalTokens = data['totalTokens'];
      result$data['totalTokens'] = l$totalTokens == null
          ? null
          : Input$NullableIntFieldUpdateOperationsInput.fromJson(
              (l$totalTokens as Map<String, dynamic>));
    }
    if (data.containsKey('updatedAt')) {
      final l$updatedAt = data['updatedAt'];
      result$data['updatedAt'] = l$updatedAt == null
          ? null
          : Input$DateTimeFieldUpdateOperationsInput.fromJson(
              (l$updatedAt as Map<String, dynamic>));
    }
    if (data.containsKey('userPrompt')) {
      final l$userPrompt = data['userPrompt'];
      result$data['userPrompt'] = l$userPrompt == null
          ? null
          : Input$NullableStringFieldUpdateOperationsInput.fromJson(
              (l$userPrompt as Map<String, dynamic>));
    }
    if (data.containsKey('uuid')) {
      final l$uuid = data['uuid'];
      result$data['uuid'] = l$uuid == null
          ? null
          : Input$StringFieldUpdateOperationsInput.fromJson(
              (l$uuid as Map<String, dynamic>));
    }
    return Input$BookRevisionUpdateWithoutBookEditedInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$BookUpdateOneWithoutBookRawNestedInput? get bookRaw =>
      (_$data['bookRaw'] as Input$BookUpdateOneWithoutBookRawNestedInput?);

  Input$NullableIntFieldUpdateOperationsInput? get completionTokens =>
      (_$data['completionTokens']
          as Input$NullableIntFieldUpdateOperationsInput?);

  Input$BookRevisionUpdatecontentInput? get content =>
      (_$data['content'] as Input$BookRevisionUpdatecontentInput?);

  Input$DateTimeFieldUpdateOperationsInput? get createdAt =>
      (_$data['createdAt'] as Input$DateTimeFieldUpdateOperationsInput?);

  Input$BoolFieldUpdateOperationsInput? get isRaw =>
      (_$data['isRaw'] as Input$BoolFieldUpdateOperationsInput?);

  Input$NullableStringFieldUpdateOperationsInput? get model =>
      (_$data['model'] as Input$NullableStringFieldUpdateOperationsInput?);

  Input$NullableIntFieldUpdateOperationsInput? get promptTokens =>
      (_$data['promptTokens'] as Input$NullableIntFieldUpdateOperationsInput?);

  Input$NullableStringFieldUpdateOperationsInput? get raw =>
      (_$data['raw'] as Input$NullableStringFieldUpdateOperationsInput?);

  Input$NullableStringFieldUpdateOperationsInput? get requestId =>
      (_$data['requestId'] as Input$NullableStringFieldUpdateOperationsInput?);

  Input$NullableStringFieldUpdateOperationsInput? get systemPrompt =>
      (_$data['systemPrompt']
          as Input$NullableStringFieldUpdateOperationsInput?);

  Input$NullableIntFieldUpdateOperationsInput? get totalTokens =>
      (_$data['totalTokens'] as Input$NullableIntFieldUpdateOperationsInput?);

  Input$DateTimeFieldUpdateOperationsInput? get updatedAt =>
      (_$data['updatedAt'] as Input$DateTimeFieldUpdateOperationsInput?);

  Input$NullableStringFieldUpdateOperationsInput? get userPrompt =>
      (_$data['userPrompt'] as Input$NullableStringFieldUpdateOperationsInput?);

  Input$StringFieldUpdateOperationsInput? get uuid =>
      (_$data['uuid'] as Input$StringFieldUpdateOperationsInput?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('bookRaw')) {
      final l$bookRaw = bookRaw;
      result$data['bookRaw'] = l$bookRaw?.toJson();
    }
    if (_$data.containsKey('completionTokens')) {
      final l$completionTokens = completionTokens;
      result$data['completionTokens'] = l$completionTokens?.toJson();
    }
    if (_$data.containsKey('content')) {
      final l$content = content;
      result$data['content'] = l$content?.toJson();
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toJson();
    }
    if (_$data.containsKey('isRaw')) {
      final l$isRaw = isRaw;
      result$data['isRaw'] = l$isRaw?.toJson();
    }
    if (_$data.containsKey('model')) {
      final l$model = model;
      result$data['model'] = l$model?.toJson();
    }
    if (_$data.containsKey('promptTokens')) {
      final l$promptTokens = promptTokens;
      result$data['promptTokens'] = l$promptTokens?.toJson();
    }
    if (_$data.containsKey('raw')) {
      final l$raw = raw;
      result$data['raw'] = l$raw?.toJson();
    }
    if (_$data.containsKey('requestId')) {
      final l$requestId = requestId;
      result$data['requestId'] = l$requestId?.toJson();
    }
    if (_$data.containsKey('systemPrompt')) {
      final l$systemPrompt = systemPrompt;
      result$data['systemPrompt'] = l$systemPrompt?.toJson();
    }
    if (_$data.containsKey('totalTokens')) {
      final l$totalTokens = totalTokens;
      result$data['totalTokens'] = l$totalTokens?.toJson();
    }
    if (_$data.containsKey('updatedAt')) {
      final l$updatedAt = updatedAt;
      result$data['updatedAt'] = l$updatedAt?.toJson();
    }
    if (_$data.containsKey('userPrompt')) {
      final l$userPrompt = userPrompt;
      result$data['userPrompt'] = l$userPrompt?.toJson();
    }
    if (_$data.containsKey('uuid')) {
      final l$uuid = uuid;
      result$data['uuid'] = l$uuid?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$BookRevisionUpdateWithoutBookEditedInput<
          Input$BookRevisionUpdateWithoutBookEditedInput>
      get copyWith => CopyWith$Input$BookRevisionUpdateWithoutBookEditedInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$BookRevisionUpdateWithoutBookEditedInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$bookRaw = bookRaw;
    final lOther$bookRaw = other.bookRaw;
    if (_$data.containsKey('bookRaw') != other._$data.containsKey('bookRaw')) {
      return false;
    }
    if (l$bookRaw != lOther$bookRaw) {
      return false;
    }
    final l$completionTokens = completionTokens;
    final lOther$completionTokens = other.completionTokens;
    if (_$data.containsKey('completionTokens') !=
        other._$data.containsKey('completionTokens')) {
      return false;
    }
    if (l$completionTokens != lOther$completionTokens) {
      return false;
    }
    final l$content = content;
    final lOther$content = other.content;
    if (_$data.containsKey('content') != other._$data.containsKey('content')) {
      return false;
    }
    if (l$content != lOther$content) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$isRaw = isRaw;
    final lOther$isRaw = other.isRaw;
    if (_$data.containsKey('isRaw') != other._$data.containsKey('isRaw')) {
      return false;
    }
    if (l$isRaw != lOther$isRaw) {
      return false;
    }
    final l$model = model;
    final lOther$model = other.model;
    if (_$data.containsKey('model') != other._$data.containsKey('model')) {
      return false;
    }
    if (l$model != lOther$model) {
      return false;
    }
    final l$promptTokens = promptTokens;
    final lOther$promptTokens = other.promptTokens;
    if (_$data.containsKey('promptTokens') !=
        other._$data.containsKey('promptTokens')) {
      return false;
    }
    if (l$promptTokens != lOther$promptTokens) {
      return false;
    }
    final l$raw = raw;
    final lOther$raw = other.raw;
    if (_$data.containsKey('raw') != other._$data.containsKey('raw')) {
      return false;
    }
    if (l$raw != lOther$raw) {
      return false;
    }
    final l$requestId = requestId;
    final lOther$requestId = other.requestId;
    if (_$data.containsKey('requestId') !=
        other._$data.containsKey('requestId')) {
      return false;
    }
    if (l$requestId != lOther$requestId) {
      return false;
    }
    final l$systemPrompt = systemPrompt;
    final lOther$systemPrompt = other.systemPrompt;
    if (_$data.containsKey('systemPrompt') !=
        other._$data.containsKey('systemPrompt')) {
      return false;
    }
    if (l$systemPrompt != lOther$systemPrompt) {
      return false;
    }
    final l$totalTokens = totalTokens;
    final lOther$totalTokens = other.totalTokens;
    if (_$data.containsKey('totalTokens') !=
        other._$data.containsKey('totalTokens')) {
      return false;
    }
    if (l$totalTokens != lOther$totalTokens) {
      return false;
    }
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (_$data.containsKey('updatedAt') !=
        other._$data.containsKey('updatedAt')) {
      return false;
    }
    if (l$updatedAt != lOther$updatedAt) {
      return false;
    }
    final l$userPrompt = userPrompt;
    final lOther$userPrompt = other.userPrompt;
    if (_$data.containsKey('userPrompt') !=
        other._$data.containsKey('userPrompt')) {
      return false;
    }
    if (l$userPrompt != lOther$userPrompt) {
      return false;
    }
    final l$uuid = uuid;
    final lOther$uuid = other.uuid;
    if (_$data.containsKey('uuid') != other._$data.containsKey('uuid')) {
      return false;
    }
    if (l$uuid != lOther$uuid) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$bookRaw = bookRaw;
    final l$completionTokens = completionTokens;
    final l$content = content;
    final l$createdAt = createdAt;
    final l$isRaw = isRaw;
    final l$model = model;
    final l$promptTokens = promptTokens;
    final l$raw = raw;
    final l$requestId = requestId;
    final l$systemPrompt = systemPrompt;
    final l$totalTokens = totalTokens;
    final l$updatedAt = updatedAt;
    final l$userPrompt = userPrompt;
    final l$uuid = uuid;
    return Object.hashAll([
      _$data.containsKey('bookRaw') ? l$bookRaw : const {},
      _$data.containsKey('completionTokens') ? l$completionTokens : const {},
      _$data.containsKey('content') ? l$content : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('isRaw') ? l$isRaw : const {},
      _$data.containsKey('model') ? l$model : const {},
      _$data.containsKey('promptTokens') ? l$promptTokens : const {},
      _$data.containsKey('raw') ? l$raw : const {},
      _$data.containsKey('requestId') ? l$requestId : const {},
      _$data.containsKey('systemPrompt') ? l$systemPrompt : const {},
      _$data.containsKey('totalTokens') ? l$totalTokens : const {},
      _$data.containsKey('updatedAt') ? l$updatedAt : const {},
      _$data.containsKey('userPrompt') ? l$userPrompt : const {},
      _$data.containsKey('uuid') ? l$uuid : const {},
    ]);
  }
}

abstract class CopyWith$Input$BookRevisionUpdateWithoutBookEditedInput<TRes> {
  factory CopyWith$Input$BookRevisionUpdateWithoutBookEditedInput(
    Input$BookRevisionUpdateWithoutBookEditedInput instance,
    TRes Function(Input$BookRevisionUpdateWithoutBookEditedInput) then,
  ) = _CopyWithImpl$Input$BookRevisionUpdateWithoutBookEditedInput;

  factory CopyWith$Input$BookRevisionUpdateWithoutBookEditedInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$BookRevisionUpdateWithoutBookEditedInput;

  TRes call({
    Input$BookUpdateOneWithoutBookRawNestedInput? bookRaw,
    Input$NullableIntFieldUpdateOperationsInput? completionTokens,
    Input$BookRevisionUpdatecontentInput? content,
    Input$DateTimeFieldUpdateOperationsInput? createdAt,
    Input$BoolFieldUpdateOperationsInput? isRaw,
    Input$NullableStringFieldUpdateOperationsInput? model,
    Input$NullableIntFieldUpdateOperationsInput? promptTokens,
    Input$NullableStringFieldUpdateOperationsInput? raw,
    Input$NullableStringFieldUpdateOperationsInput? requestId,
    Input$NullableStringFieldUpdateOperationsInput? systemPrompt,
    Input$NullableIntFieldUpdateOperationsInput? totalTokens,
    Input$DateTimeFieldUpdateOperationsInput? updatedAt,
    Input$NullableStringFieldUpdateOperationsInput? userPrompt,
    Input$StringFieldUpdateOperationsInput? uuid,
  });
  CopyWith$Input$BookUpdateOneWithoutBookRawNestedInput<TRes> get bookRaw;
  CopyWith$Input$NullableIntFieldUpdateOperationsInput<TRes>
      get completionTokens;
  CopyWith$Input$BookRevisionUpdatecontentInput<TRes> get content;
  CopyWith$Input$DateTimeFieldUpdateOperationsInput<TRes> get createdAt;
  CopyWith$Input$BoolFieldUpdateOperationsInput<TRes> get isRaw;
  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get model;
  CopyWith$Input$NullableIntFieldUpdateOperationsInput<TRes> get promptTokens;
  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get raw;
  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get requestId;
  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes>
      get systemPrompt;
  CopyWith$Input$NullableIntFieldUpdateOperationsInput<TRes> get totalTokens;
  CopyWith$Input$DateTimeFieldUpdateOperationsInput<TRes> get updatedAt;
  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get userPrompt;
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get uuid;
}

class _CopyWithImpl$Input$BookRevisionUpdateWithoutBookEditedInput<TRes>
    implements CopyWith$Input$BookRevisionUpdateWithoutBookEditedInput<TRes> {
  _CopyWithImpl$Input$BookRevisionUpdateWithoutBookEditedInput(
    this._instance,
    this._then,
  );

  final Input$BookRevisionUpdateWithoutBookEditedInput _instance;

  final TRes Function(Input$BookRevisionUpdateWithoutBookEditedInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? bookRaw = _undefined,
    Object? completionTokens = _undefined,
    Object? content = _undefined,
    Object? createdAt = _undefined,
    Object? isRaw = _undefined,
    Object? model = _undefined,
    Object? promptTokens = _undefined,
    Object? raw = _undefined,
    Object? requestId = _undefined,
    Object? systemPrompt = _undefined,
    Object? totalTokens = _undefined,
    Object? updatedAt = _undefined,
    Object? userPrompt = _undefined,
    Object? uuid = _undefined,
  }) =>
      _then(Input$BookRevisionUpdateWithoutBookEditedInput._({
        ..._instance._$data,
        if (bookRaw != _undefined)
          'bookRaw': (bookRaw as Input$BookUpdateOneWithoutBookRawNestedInput?),
        if (completionTokens != _undefined)
          'completionTokens': (completionTokens
              as Input$NullableIntFieldUpdateOperationsInput?),
        if (content != _undefined)
          'content': (content as Input$BookRevisionUpdatecontentInput?),
        if (createdAt != _undefined)
          'createdAt': (createdAt as Input$DateTimeFieldUpdateOperationsInput?),
        if (isRaw != _undefined)
          'isRaw': (isRaw as Input$BoolFieldUpdateOperationsInput?),
        if (model != _undefined)
          'model': (model as Input$NullableStringFieldUpdateOperationsInput?),
        if (promptTokens != _undefined)
          'promptTokens':
              (promptTokens as Input$NullableIntFieldUpdateOperationsInput?),
        if (raw != _undefined)
          'raw': (raw as Input$NullableStringFieldUpdateOperationsInput?),
        if (requestId != _undefined)
          'requestId':
              (requestId as Input$NullableStringFieldUpdateOperationsInput?),
        if (systemPrompt != _undefined)
          'systemPrompt':
              (systemPrompt as Input$NullableStringFieldUpdateOperationsInput?),
        if (totalTokens != _undefined)
          'totalTokens':
              (totalTokens as Input$NullableIntFieldUpdateOperationsInput?),
        if (updatedAt != _undefined)
          'updatedAt': (updatedAt as Input$DateTimeFieldUpdateOperationsInput?),
        if (userPrompt != _undefined)
          'userPrompt':
              (userPrompt as Input$NullableStringFieldUpdateOperationsInput?),
        if (uuid != _undefined)
          'uuid': (uuid as Input$StringFieldUpdateOperationsInput?),
      }));

  CopyWith$Input$BookUpdateOneWithoutBookRawNestedInput<TRes> get bookRaw {
    final local$bookRaw = _instance.bookRaw;
    return local$bookRaw == null
        ? CopyWith$Input$BookUpdateOneWithoutBookRawNestedInput.stub(
            _then(_instance))
        : CopyWith$Input$BookUpdateOneWithoutBookRawNestedInput(
            local$bookRaw, (e) => call(bookRaw: e));
  }

  CopyWith$Input$NullableIntFieldUpdateOperationsInput<TRes>
      get completionTokens {
    final local$completionTokens = _instance.completionTokens;
    return local$completionTokens == null
        ? CopyWith$Input$NullableIntFieldUpdateOperationsInput.stub(
            _then(_instance))
        : CopyWith$Input$NullableIntFieldUpdateOperationsInput(
            local$completionTokens, (e) => call(completionTokens: e));
  }

  CopyWith$Input$BookRevisionUpdatecontentInput<TRes> get content {
    final local$content = _instance.content;
    return local$content == null
        ? CopyWith$Input$BookRevisionUpdatecontentInput.stub(_then(_instance))
        : CopyWith$Input$BookRevisionUpdatecontentInput(
            local$content, (e) => call(content: e));
  }

  CopyWith$Input$DateTimeFieldUpdateOperationsInput<TRes> get createdAt {
    final local$createdAt = _instance.createdAt;
    return local$createdAt == null
        ? CopyWith$Input$DateTimeFieldUpdateOperationsInput.stub(
            _then(_instance))
        : CopyWith$Input$DateTimeFieldUpdateOperationsInput(
            local$createdAt, (e) => call(createdAt: e));
  }

  CopyWith$Input$BoolFieldUpdateOperationsInput<TRes> get isRaw {
    final local$isRaw = _instance.isRaw;
    return local$isRaw == null
        ? CopyWith$Input$BoolFieldUpdateOperationsInput.stub(_then(_instance))
        : CopyWith$Input$BoolFieldUpdateOperationsInput(
            local$isRaw, (e) => call(isRaw: e));
  }

  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get model {
    final local$model = _instance.model;
    return local$model == null
        ? CopyWith$Input$NullableStringFieldUpdateOperationsInput.stub(
            _then(_instance))
        : CopyWith$Input$NullableStringFieldUpdateOperationsInput(
            local$model, (e) => call(model: e));
  }

  CopyWith$Input$NullableIntFieldUpdateOperationsInput<TRes> get promptTokens {
    final local$promptTokens = _instance.promptTokens;
    return local$promptTokens == null
        ? CopyWith$Input$NullableIntFieldUpdateOperationsInput.stub(
            _then(_instance))
        : CopyWith$Input$NullableIntFieldUpdateOperationsInput(
            local$promptTokens, (e) => call(promptTokens: e));
  }

  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get raw {
    final local$raw = _instance.raw;
    return local$raw == null
        ? CopyWith$Input$NullableStringFieldUpdateOperationsInput.stub(
            _then(_instance))
        : CopyWith$Input$NullableStringFieldUpdateOperationsInput(
            local$raw, (e) => call(raw: e));
  }

  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get requestId {
    final local$requestId = _instance.requestId;
    return local$requestId == null
        ? CopyWith$Input$NullableStringFieldUpdateOperationsInput.stub(
            _then(_instance))
        : CopyWith$Input$NullableStringFieldUpdateOperationsInput(
            local$requestId, (e) => call(requestId: e));
  }

  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes>
      get systemPrompt {
    final local$systemPrompt = _instance.systemPrompt;
    return local$systemPrompt == null
        ? CopyWith$Input$NullableStringFieldUpdateOperationsInput.stub(
            _then(_instance))
        : CopyWith$Input$NullableStringFieldUpdateOperationsInput(
            local$systemPrompt, (e) => call(systemPrompt: e));
  }

  CopyWith$Input$NullableIntFieldUpdateOperationsInput<TRes> get totalTokens {
    final local$totalTokens = _instance.totalTokens;
    return local$totalTokens == null
        ? CopyWith$Input$NullableIntFieldUpdateOperationsInput.stub(
            _then(_instance))
        : CopyWith$Input$NullableIntFieldUpdateOperationsInput(
            local$totalTokens, (e) => call(totalTokens: e));
  }

  CopyWith$Input$DateTimeFieldUpdateOperationsInput<TRes> get updatedAt {
    final local$updatedAt = _instance.updatedAt;
    return local$updatedAt == null
        ? CopyWith$Input$DateTimeFieldUpdateOperationsInput.stub(
            _then(_instance))
        : CopyWith$Input$DateTimeFieldUpdateOperationsInput(
            local$updatedAt, (e) => call(updatedAt: e));
  }

  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get userPrompt {
    final local$userPrompt = _instance.userPrompt;
    return local$userPrompt == null
        ? CopyWith$Input$NullableStringFieldUpdateOperationsInput.stub(
            _then(_instance))
        : CopyWith$Input$NullableStringFieldUpdateOperationsInput(
            local$userPrompt, (e) => call(userPrompt: e));
  }

  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get uuid {
    final local$uuid = _instance.uuid;
    return local$uuid == null
        ? CopyWith$Input$StringFieldUpdateOperationsInput.stub(_then(_instance))
        : CopyWith$Input$StringFieldUpdateOperationsInput(
            local$uuid, (e) => call(uuid: e));
  }
}

class _CopyWithStubImpl$Input$BookRevisionUpdateWithoutBookEditedInput<TRes>
    implements CopyWith$Input$BookRevisionUpdateWithoutBookEditedInput<TRes> {
  _CopyWithStubImpl$Input$BookRevisionUpdateWithoutBookEditedInput(this._res);

  TRes _res;

  call({
    Input$BookUpdateOneWithoutBookRawNestedInput? bookRaw,
    Input$NullableIntFieldUpdateOperationsInput? completionTokens,
    Input$BookRevisionUpdatecontentInput? content,
    Input$DateTimeFieldUpdateOperationsInput? createdAt,
    Input$BoolFieldUpdateOperationsInput? isRaw,
    Input$NullableStringFieldUpdateOperationsInput? model,
    Input$NullableIntFieldUpdateOperationsInput? promptTokens,
    Input$NullableStringFieldUpdateOperationsInput? raw,
    Input$NullableStringFieldUpdateOperationsInput? requestId,
    Input$NullableStringFieldUpdateOperationsInput? systemPrompt,
    Input$NullableIntFieldUpdateOperationsInput? totalTokens,
    Input$DateTimeFieldUpdateOperationsInput? updatedAt,
    Input$NullableStringFieldUpdateOperationsInput? userPrompt,
    Input$StringFieldUpdateOperationsInput? uuid,
  }) =>
      _res;

  CopyWith$Input$BookUpdateOneWithoutBookRawNestedInput<TRes> get bookRaw =>
      CopyWith$Input$BookUpdateOneWithoutBookRawNestedInput.stub(_res);

  CopyWith$Input$NullableIntFieldUpdateOperationsInput<TRes>
      get completionTokens =>
          CopyWith$Input$NullableIntFieldUpdateOperationsInput.stub(_res);

  CopyWith$Input$BookRevisionUpdatecontentInput<TRes> get content =>
      CopyWith$Input$BookRevisionUpdatecontentInput.stub(_res);

  CopyWith$Input$DateTimeFieldUpdateOperationsInput<TRes> get createdAt =>
      CopyWith$Input$DateTimeFieldUpdateOperationsInput.stub(_res);

  CopyWith$Input$BoolFieldUpdateOperationsInput<TRes> get isRaw =>
      CopyWith$Input$BoolFieldUpdateOperationsInput.stub(_res);

  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get model =>
      CopyWith$Input$NullableStringFieldUpdateOperationsInput.stub(_res);

  CopyWith$Input$NullableIntFieldUpdateOperationsInput<TRes> get promptTokens =>
      CopyWith$Input$NullableIntFieldUpdateOperationsInput.stub(_res);

  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get raw =>
      CopyWith$Input$NullableStringFieldUpdateOperationsInput.stub(_res);

  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get requestId =>
      CopyWith$Input$NullableStringFieldUpdateOperationsInput.stub(_res);

  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes>
      get systemPrompt =>
          CopyWith$Input$NullableStringFieldUpdateOperationsInput.stub(_res);

  CopyWith$Input$NullableIntFieldUpdateOperationsInput<TRes> get totalTokens =>
      CopyWith$Input$NullableIntFieldUpdateOperationsInput.stub(_res);

  CopyWith$Input$DateTimeFieldUpdateOperationsInput<TRes> get updatedAt =>
      CopyWith$Input$DateTimeFieldUpdateOperationsInput.stub(_res);

  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes>
      get userPrompt =>
          CopyWith$Input$NullableStringFieldUpdateOperationsInput.stub(_res);

  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get uuid =>
      CopyWith$Input$StringFieldUpdateOperationsInput.stub(_res);
}

class Input$BookRevisionUpdateWithoutBookRawInput {
  factory Input$BookRevisionUpdateWithoutBookRawInput({
    Input$BookUpdateOneWithoutBookEditedNestedInput? bookEdited,
    Input$NullableIntFieldUpdateOperationsInput? completionTokens,
    Input$BookRevisionUpdatecontentInput? content,
    Input$DateTimeFieldUpdateOperationsInput? createdAt,
    Input$BoolFieldUpdateOperationsInput? isRaw,
    Input$NullableStringFieldUpdateOperationsInput? model,
    Input$NullableIntFieldUpdateOperationsInput? promptTokens,
    Input$NullableStringFieldUpdateOperationsInput? raw,
    Input$NullableStringFieldUpdateOperationsInput? requestId,
    Input$NullableStringFieldUpdateOperationsInput? systemPrompt,
    Input$NullableIntFieldUpdateOperationsInput? totalTokens,
    Input$DateTimeFieldUpdateOperationsInput? updatedAt,
    Input$NullableStringFieldUpdateOperationsInput? userPrompt,
    Input$StringFieldUpdateOperationsInput? uuid,
  }) =>
      Input$BookRevisionUpdateWithoutBookRawInput._({
        if (bookEdited != null) r'bookEdited': bookEdited,
        if (completionTokens != null) r'completionTokens': completionTokens,
        if (content != null) r'content': content,
        if (createdAt != null) r'createdAt': createdAt,
        if (isRaw != null) r'isRaw': isRaw,
        if (model != null) r'model': model,
        if (promptTokens != null) r'promptTokens': promptTokens,
        if (raw != null) r'raw': raw,
        if (requestId != null) r'requestId': requestId,
        if (systemPrompt != null) r'systemPrompt': systemPrompt,
        if (totalTokens != null) r'totalTokens': totalTokens,
        if (updatedAt != null) r'updatedAt': updatedAt,
        if (userPrompt != null) r'userPrompt': userPrompt,
        if (uuid != null) r'uuid': uuid,
      });

  Input$BookRevisionUpdateWithoutBookRawInput._(this._$data);

  factory Input$BookRevisionUpdateWithoutBookRawInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('bookEdited')) {
      final l$bookEdited = data['bookEdited'];
      result$data['bookEdited'] = l$bookEdited == null
          ? null
          : Input$BookUpdateOneWithoutBookEditedNestedInput.fromJson(
              (l$bookEdited as Map<String, dynamic>));
    }
    if (data.containsKey('completionTokens')) {
      final l$completionTokens = data['completionTokens'];
      result$data['completionTokens'] = l$completionTokens == null
          ? null
          : Input$NullableIntFieldUpdateOperationsInput.fromJson(
              (l$completionTokens as Map<String, dynamic>));
    }
    if (data.containsKey('content')) {
      final l$content = data['content'];
      result$data['content'] = l$content == null
          ? null
          : Input$BookRevisionUpdatecontentInput.fromJson(
              (l$content as Map<String, dynamic>));
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : Input$DateTimeFieldUpdateOperationsInput.fromJson(
              (l$createdAt as Map<String, dynamic>));
    }
    if (data.containsKey('isRaw')) {
      final l$isRaw = data['isRaw'];
      result$data['isRaw'] = l$isRaw == null
          ? null
          : Input$BoolFieldUpdateOperationsInput.fromJson(
              (l$isRaw as Map<String, dynamic>));
    }
    if (data.containsKey('model')) {
      final l$model = data['model'];
      result$data['model'] = l$model == null
          ? null
          : Input$NullableStringFieldUpdateOperationsInput.fromJson(
              (l$model as Map<String, dynamic>));
    }
    if (data.containsKey('promptTokens')) {
      final l$promptTokens = data['promptTokens'];
      result$data['promptTokens'] = l$promptTokens == null
          ? null
          : Input$NullableIntFieldUpdateOperationsInput.fromJson(
              (l$promptTokens as Map<String, dynamic>));
    }
    if (data.containsKey('raw')) {
      final l$raw = data['raw'];
      result$data['raw'] = l$raw == null
          ? null
          : Input$NullableStringFieldUpdateOperationsInput.fromJson(
              (l$raw as Map<String, dynamic>));
    }
    if (data.containsKey('requestId')) {
      final l$requestId = data['requestId'];
      result$data['requestId'] = l$requestId == null
          ? null
          : Input$NullableStringFieldUpdateOperationsInput.fromJson(
              (l$requestId as Map<String, dynamic>));
    }
    if (data.containsKey('systemPrompt')) {
      final l$systemPrompt = data['systemPrompt'];
      result$data['systemPrompt'] = l$systemPrompt == null
          ? null
          : Input$NullableStringFieldUpdateOperationsInput.fromJson(
              (l$systemPrompt as Map<String, dynamic>));
    }
    if (data.containsKey('totalTokens')) {
      final l$totalTokens = data['totalTokens'];
      result$data['totalTokens'] = l$totalTokens == null
          ? null
          : Input$NullableIntFieldUpdateOperationsInput.fromJson(
              (l$totalTokens as Map<String, dynamic>));
    }
    if (data.containsKey('updatedAt')) {
      final l$updatedAt = data['updatedAt'];
      result$data['updatedAt'] = l$updatedAt == null
          ? null
          : Input$DateTimeFieldUpdateOperationsInput.fromJson(
              (l$updatedAt as Map<String, dynamic>));
    }
    if (data.containsKey('userPrompt')) {
      final l$userPrompt = data['userPrompt'];
      result$data['userPrompt'] = l$userPrompt == null
          ? null
          : Input$NullableStringFieldUpdateOperationsInput.fromJson(
              (l$userPrompt as Map<String, dynamic>));
    }
    if (data.containsKey('uuid')) {
      final l$uuid = data['uuid'];
      result$data['uuid'] = l$uuid == null
          ? null
          : Input$StringFieldUpdateOperationsInput.fromJson(
              (l$uuid as Map<String, dynamic>));
    }
    return Input$BookRevisionUpdateWithoutBookRawInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$BookUpdateOneWithoutBookEditedNestedInput? get bookEdited =>
      (_$data['bookEdited']
          as Input$BookUpdateOneWithoutBookEditedNestedInput?);

  Input$NullableIntFieldUpdateOperationsInput? get completionTokens =>
      (_$data['completionTokens']
          as Input$NullableIntFieldUpdateOperationsInput?);

  Input$BookRevisionUpdatecontentInput? get content =>
      (_$data['content'] as Input$BookRevisionUpdatecontentInput?);

  Input$DateTimeFieldUpdateOperationsInput? get createdAt =>
      (_$data['createdAt'] as Input$DateTimeFieldUpdateOperationsInput?);

  Input$BoolFieldUpdateOperationsInput? get isRaw =>
      (_$data['isRaw'] as Input$BoolFieldUpdateOperationsInput?);

  Input$NullableStringFieldUpdateOperationsInput? get model =>
      (_$data['model'] as Input$NullableStringFieldUpdateOperationsInput?);

  Input$NullableIntFieldUpdateOperationsInput? get promptTokens =>
      (_$data['promptTokens'] as Input$NullableIntFieldUpdateOperationsInput?);

  Input$NullableStringFieldUpdateOperationsInput? get raw =>
      (_$data['raw'] as Input$NullableStringFieldUpdateOperationsInput?);

  Input$NullableStringFieldUpdateOperationsInput? get requestId =>
      (_$data['requestId'] as Input$NullableStringFieldUpdateOperationsInput?);

  Input$NullableStringFieldUpdateOperationsInput? get systemPrompt =>
      (_$data['systemPrompt']
          as Input$NullableStringFieldUpdateOperationsInput?);

  Input$NullableIntFieldUpdateOperationsInput? get totalTokens =>
      (_$data['totalTokens'] as Input$NullableIntFieldUpdateOperationsInput?);

  Input$DateTimeFieldUpdateOperationsInput? get updatedAt =>
      (_$data['updatedAt'] as Input$DateTimeFieldUpdateOperationsInput?);

  Input$NullableStringFieldUpdateOperationsInput? get userPrompt =>
      (_$data['userPrompt'] as Input$NullableStringFieldUpdateOperationsInput?);

  Input$StringFieldUpdateOperationsInput? get uuid =>
      (_$data['uuid'] as Input$StringFieldUpdateOperationsInput?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('bookEdited')) {
      final l$bookEdited = bookEdited;
      result$data['bookEdited'] = l$bookEdited?.toJson();
    }
    if (_$data.containsKey('completionTokens')) {
      final l$completionTokens = completionTokens;
      result$data['completionTokens'] = l$completionTokens?.toJson();
    }
    if (_$data.containsKey('content')) {
      final l$content = content;
      result$data['content'] = l$content?.toJson();
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toJson();
    }
    if (_$data.containsKey('isRaw')) {
      final l$isRaw = isRaw;
      result$data['isRaw'] = l$isRaw?.toJson();
    }
    if (_$data.containsKey('model')) {
      final l$model = model;
      result$data['model'] = l$model?.toJson();
    }
    if (_$data.containsKey('promptTokens')) {
      final l$promptTokens = promptTokens;
      result$data['promptTokens'] = l$promptTokens?.toJson();
    }
    if (_$data.containsKey('raw')) {
      final l$raw = raw;
      result$data['raw'] = l$raw?.toJson();
    }
    if (_$data.containsKey('requestId')) {
      final l$requestId = requestId;
      result$data['requestId'] = l$requestId?.toJson();
    }
    if (_$data.containsKey('systemPrompt')) {
      final l$systemPrompt = systemPrompt;
      result$data['systemPrompt'] = l$systemPrompt?.toJson();
    }
    if (_$data.containsKey('totalTokens')) {
      final l$totalTokens = totalTokens;
      result$data['totalTokens'] = l$totalTokens?.toJson();
    }
    if (_$data.containsKey('updatedAt')) {
      final l$updatedAt = updatedAt;
      result$data['updatedAt'] = l$updatedAt?.toJson();
    }
    if (_$data.containsKey('userPrompt')) {
      final l$userPrompt = userPrompt;
      result$data['userPrompt'] = l$userPrompt?.toJson();
    }
    if (_$data.containsKey('uuid')) {
      final l$uuid = uuid;
      result$data['uuid'] = l$uuid?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$BookRevisionUpdateWithoutBookRawInput<
          Input$BookRevisionUpdateWithoutBookRawInput>
      get copyWith => CopyWith$Input$BookRevisionUpdateWithoutBookRawInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$BookRevisionUpdateWithoutBookRawInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$bookEdited = bookEdited;
    final lOther$bookEdited = other.bookEdited;
    if (_$data.containsKey('bookEdited') !=
        other._$data.containsKey('bookEdited')) {
      return false;
    }
    if (l$bookEdited != lOther$bookEdited) {
      return false;
    }
    final l$completionTokens = completionTokens;
    final lOther$completionTokens = other.completionTokens;
    if (_$data.containsKey('completionTokens') !=
        other._$data.containsKey('completionTokens')) {
      return false;
    }
    if (l$completionTokens != lOther$completionTokens) {
      return false;
    }
    final l$content = content;
    final lOther$content = other.content;
    if (_$data.containsKey('content') != other._$data.containsKey('content')) {
      return false;
    }
    if (l$content != lOther$content) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$isRaw = isRaw;
    final lOther$isRaw = other.isRaw;
    if (_$data.containsKey('isRaw') != other._$data.containsKey('isRaw')) {
      return false;
    }
    if (l$isRaw != lOther$isRaw) {
      return false;
    }
    final l$model = model;
    final lOther$model = other.model;
    if (_$data.containsKey('model') != other._$data.containsKey('model')) {
      return false;
    }
    if (l$model != lOther$model) {
      return false;
    }
    final l$promptTokens = promptTokens;
    final lOther$promptTokens = other.promptTokens;
    if (_$data.containsKey('promptTokens') !=
        other._$data.containsKey('promptTokens')) {
      return false;
    }
    if (l$promptTokens != lOther$promptTokens) {
      return false;
    }
    final l$raw = raw;
    final lOther$raw = other.raw;
    if (_$data.containsKey('raw') != other._$data.containsKey('raw')) {
      return false;
    }
    if (l$raw != lOther$raw) {
      return false;
    }
    final l$requestId = requestId;
    final lOther$requestId = other.requestId;
    if (_$data.containsKey('requestId') !=
        other._$data.containsKey('requestId')) {
      return false;
    }
    if (l$requestId != lOther$requestId) {
      return false;
    }
    final l$systemPrompt = systemPrompt;
    final lOther$systemPrompt = other.systemPrompt;
    if (_$data.containsKey('systemPrompt') !=
        other._$data.containsKey('systemPrompt')) {
      return false;
    }
    if (l$systemPrompt != lOther$systemPrompt) {
      return false;
    }
    final l$totalTokens = totalTokens;
    final lOther$totalTokens = other.totalTokens;
    if (_$data.containsKey('totalTokens') !=
        other._$data.containsKey('totalTokens')) {
      return false;
    }
    if (l$totalTokens != lOther$totalTokens) {
      return false;
    }
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (_$data.containsKey('updatedAt') !=
        other._$data.containsKey('updatedAt')) {
      return false;
    }
    if (l$updatedAt != lOther$updatedAt) {
      return false;
    }
    final l$userPrompt = userPrompt;
    final lOther$userPrompt = other.userPrompt;
    if (_$data.containsKey('userPrompt') !=
        other._$data.containsKey('userPrompt')) {
      return false;
    }
    if (l$userPrompt != lOther$userPrompt) {
      return false;
    }
    final l$uuid = uuid;
    final lOther$uuid = other.uuid;
    if (_$data.containsKey('uuid') != other._$data.containsKey('uuid')) {
      return false;
    }
    if (l$uuid != lOther$uuid) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$bookEdited = bookEdited;
    final l$completionTokens = completionTokens;
    final l$content = content;
    final l$createdAt = createdAt;
    final l$isRaw = isRaw;
    final l$model = model;
    final l$promptTokens = promptTokens;
    final l$raw = raw;
    final l$requestId = requestId;
    final l$systemPrompt = systemPrompt;
    final l$totalTokens = totalTokens;
    final l$updatedAt = updatedAt;
    final l$userPrompt = userPrompt;
    final l$uuid = uuid;
    return Object.hashAll([
      _$data.containsKey('bookEdited') ? l$bookEdited : const {},
      _$data.containsKey('completionTokens') ? l$completionTokens : const {},
      _$data.containsKey('content') ? l$content : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('isRaw') ? l$isRaw : const {},
      _$data.containsKey('model') ? l$model : const {},
      _$data.containsKey('promptTokens') ? l$promptTokens : const {},
      _$data.containsKey('raw') ? l$raw : const {},
      _$data.containsKey('requestId') ? l$requestId : const {},
      _$data.containsKey('systemPrompt') ? l$systemPrompt : const {},
      _$data.containsKey('totalTokens') ? l$totalTokens : const {},
      _$data.containsKey('updatedAt') ? l$updatedAt : const {},
      _$data.containsKey('userPrompt') ? l$userPrompt : const {},
      _$data.containsKey('uuid') ? l$uuid : const {},
    ]);
  }
}

abstract class CopyWith$Input$BookRevisionUpdateWithoutBookRawInput<TRes> {
  factory CopyWith$Input$BookRevisionUpdateWithoutBookRawInput(
    Input$BookRevisionUpdateWithoutBookRawInput instance,
    TRes Function(Input$BookRevisionUpdateWithoutBookRawInput) then,
  ) = _CopyWithImpl$Input$BookRevisionUpdateWithoutBookRawInput;

  factory CopyWith$Input$BookRevisionUpdateWithoutBookRawInput.stub(TRes res) =
      _CopyWithStubImpl$Input$BookRevisionUpdateWithoutBookRawInput;

  TRes call({
    Input$BookUpdateOneWithoutBookEditedNestedInput? bookEdited,
    Input$NullableIntFieldUpdateOperationsInput? completionTokens,
    Input$BookRevisionUpdatecontentInput? content,
    Input$DateTimeFieldUpdateOperationsInput? createdAt,
    Input$BoolFieldUpdateOperationsInput? isRaw,
    Input$NullableStringFieldUpdateOperationsInput? model,
    Input$NullableIntFieldUpdateOperationsInput? promptTokens,
    Input$NullableStringFieldUpdateOperationsInput? raw,
    Input$NullableStringFieldUpdateOperationsInput? requestId,
    Input$NullableStringFieldUpdateOperationsInput? systemPrompt,
    Input$NullableIntFieldUpdateOperationsInput? totalTokens,
    Input$DateTimeFieldUpdateOperationsInput? updatedAt,
    Input$NullableStringFieldUpdateOperationsInput? userPrompt,
    Input$StringFieldUpdateOperationsInput? uuid,
  });
  CopyWith$Input$BookUpdateOneWithoutBookEditedNestedInput<TRes> get bookEdited;
  CopyWith$Input$NullableIntFieldUpdateOperationsInput<TRes>
      get completionTokens;
  CopyWith$Input$BookRevisionUpdatecontentInput<TRes> get content;
  CopyWith$Input$DateTimeFieldUpdateOperationsInput<TRes> get createdAt;
  CopyWith$Input$BoolFieldUpdateOperationsInput<TRes> get isRaw;
  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get model;
  CopyWith$Input$NullableIntFieldUpdateOperationsInput<TRes> get promptTokens;
  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get raw;
  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get requestId;
  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes>
      get systemPrompt;
  CopyWith$Input$NullableIntFieldUpdateOperationsInput<TRes> get totalTokens;
  CopyWith$Input$DateTimeFieldUpdateOperationsInput<TRes> get updatedAt;
  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get userPrompt;
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get uuid;
}

class _CopyWithImpl$Input$BookRevisionUpdateWithoutBookRawInput<TRes>
    implements CopyWith$Input$BookRevisionUpdateWithoutBookRawInput<TRes> {
  _CopyWithImpl$Input$BookRevisionUpdateWithoutBookRawInput(
    this._instance,
    this._then,
  );

  final Input$BookRevisionUpdateWithoutBookRawInput _instance;

  final TRes Function(Input$BookRevisionUpdateWithoutBookRawInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? bookEdited = _undefined,
    Object? completionTokens = _undefined,
    Object? content = _undefined,
    Object? createdAt = _undefined,
    Object? isRaw = _undefined,
    Object? model = _undefined,
    Object? promptTokens = _undefined,
    Object? raw = _undefined,
    Object? requestId = _undefined,
    Object? systemPrompt = _undefined,
    Object? totalTokens = _undefined,
    Object? updatedAt = _undefined,
    Object? userPrompt = _undefined,
    Object? uuid = _undefined,
  }) =>
      _then(Input$BookRevisionUpdateWithoutBookRawInput._({
        ..._instance._$data,
        if (bookEdited != _undefined)
          'bookEdited':
              (bookEdited as Input$BookUpdateOneWithoutBookEditedNestedInput?),
        if (completionTokens != _undefined)
          'completionTokens': (completionTokens
              as Input$NullableIntFieldUpdateOperationsInput?),
        if (content != _undefined)
          'content': (content as Input$BookRevisionUpdatecontentInput?),
        if (createdAt != _undefined)
          'createdAt': (createdAt as Input$DateTimeFieldUpdateOperationsInput?),
        if (isRaw != _undefined)
          'isRaw': (isRaw as Input$BoolFieldUpdateOperationsInput?),
        if (model != _undefined)
          'model': (model as Input$NullableStringFieldUpdateOperationsInput?),
        if (promptTokens != _undefined)
          'promptTokens':
              (promptTokens as Input$NullableIntFieldUpdateOperationsInput?),
        if (raw != _undefined)
          'raw': (raw as Input$NullableStringFieldUpdateOperationsInput?),
        if (requestId != _undefined)
          'requestId':
              (requestId as Input$NullableStringFieldUpdateOperationsInput?),
        if (systemPrompt != _undefined)
          'systemPrompt':
              (systemPrompt as Input$NullableStringFieldUpdateOperationsInput?),
        if (totalTokens != _undefined)
          'totalTokens':
              (totalTokens as Input$NullableIntFieldUpdateOperationsInput?),
        if (updatedAt != _undefined)
          'updatedAt': (updatedAt as Input$DateTimeFieldUpdateOperationsInput?),
        if (userPrompt != _undefined)
          'userPrompt':
              (userPrompt as Input$NullableStringFieldUpdateOperationsInput?),
        if (uuid != _undefined)
          'uuid': (uuid as Input$StringFieldUpdateOperationsInput?),
      }));

  CopyWith$Input$BookUpdateOneWithoutBookEditedNestedInput<TRes>
      get bookEdited {
    final local$bookEdited = _instance.bookEdited;
    return local$bookEdited == null
        ? CopyWith$Input$BookUpdateOneWithoutBookEditedNestedInput.stub(
            _then(_instance))
        : CopyWith$Input$BookUpdateOneWithoutBookEditedNestedInput(
            local$bookEdited, (e) => call(bookEdited: e));
  }

  CopyWith$Input$NullableIntFieldUpdateOperationsInput<TRes>
      get completionTokens {
    final local$completionTokens = _instance.completionTokens;
    return local$completionTokens == null
        ? CopyWith$Input$NullableIntFieldUpdateOperationsInput.stub(
            _then(_instance))
        : CopyWith$Input$NullableIntFieldUpdateOperationsInput(
            local$completionTokens, (e) => call(completionTokens: e));
  }

  CopyWith$Input$BookRevisionUpdatecontentInput<TRes> get content {
    final local$content = _instance.content;
    return local$content == null
        ? CopyWith$Input$BookRevisionUpdatecontentInput.stub(_then(_instance))
        : CopyWith$Input$BookRevisionUpdatecontentInput(
            local$content, (e) => call(content: e));
  }

  CopyWith$Input$DateTimeFieldUpdateOperationsInput<TRes> get createdAt {
    final local$createdAt = _instance.createdAt;
    return local$createdAt == null
        ? CopyWith$Input$DateTimeFieldUpdateOperationsInput.stub(
            _then(_instance))
        : CopyWith$Input$DateTimeFieldUpdateOperationsInput(
            local$createdAt, (e) => call(createdAt: e));
  }

  CopyWith$Input$BoolFieldUpdateOperationsInput<TRes> get isRaw {
    final local$isRaw = _instance.isRaw;
    return local$isRaw == null
        ? CopyWith$Input$BoolFieldUpdateOperationsInput.stub(_then(_instance))
        : CopyWith$Input$BoolFieldUpdateOperationsInput(
            local$isRaw, (e) => call(isRaw: e));
  }

  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get model {
    final local$model = _instance.model;
    return local$model == null
        ? CopyWith$Input$NullableStringFieldUpdateOperationsInput.stub(
            _then(_instance))
        : CopyWith$Input$NullableStringFieldUpdateOperationsInput(
            local$model, (e) => call(model: e));
  }

  CopyWith$Input$NullableIntFieldUpdateOperationsInput<TRes> get promptTokens {
    final local$promptTokens = _instance.promptTokens;
    return local$promptTokens == null
        ? CopyWith$Input$NullableIntFieldUpdateOperationsInput.stub(
            _then(_instance))
        : CopyWith$Input$NullableIntFieldUpdateOperationsInput(
            local$promptTokens, (e) => call(promptTokens: e));
  }

  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get raw {
    final local$raw = _instance.raw;
    return local$raw == null
        ? CopyWith$Input$NullableStringFieldUpdateOperationsInput.stub(
            _then(_instance))
        : CopyWith$Input$NullableStringFieldUpdateOperationsInput(
            local$raw, (e) => call(raw: e));
  }

  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get requestId {
    final local$requestId = _instance.requestId;
    return local$requestId == null
        ? CopyWith$Input$NullableStringFieldUpdateOperationsInput.stub(
            _then(_instance))
        : CopyWith$Input$NullableStringFieldUpdateOperationsInput(
            local$requestId, (e) => call(requestId: e));
  }

  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes>
      get systemPrompt {
    final local$systemPrompt = _instance.systemPrompt;
    return local$systemPrompt == null
        ? CopyWith$Input$NullableStringFieldUpdateOperationsInput.stub(
            _then(_instance))
        : CopyWith$Input$NullableStringFieldUpdateOperationsInput(
            local$systemPrompt, (e) => call(systemPrompt: e));
  }

  CopyWith$Input$NullableIntFieldUpdateOperationsInput<TRes> get totalTokens {
    final local$totalTokens = _instance.totalTokens;
    return local$totalTokens == null
        ? CopyWith$Input$NullableIntFieldUpdateOperationsInput.stub(
            _then(_instance))
        : CopyWith$Input$NullableIntFieldUpdateOperationsInput(
            local$totalTokens, (e) => call(totalTokens: e));
  }

  CopyWith$Input$DateTimeFieldUpdateOperationsInput<TRes> get updatedAt {
    final local$updatedAt = _instance.updatedAt;
    return local$updatedAt == null
        ? CopyWith$Input$DateTimeFieldUpdateOperationsInput.stub(
            _then(_instance))
        : CopyWith$Input$DateTimeFieldUpdateOperationsInput(
            local$updatedAt, (e) => call(updatedAt: e));
  }

  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get userPrompt {
    final local$userPrompt = _instance.userPrompt;
    return local$userPrompt == null
        ? CopyWith$Input$NullableStringFieldUpdateOperationsInput.stub(
            _then(_instance))
        : CopyWith$Input$NullableStringFieldUpdateOperationsInput(
            local$userPrompt, (e) => call(userPrompt: e));
  }

  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get uuid {
    final local$uuid = _instance.uuid;
    return local$uuid == null
        ? CopyWith$Input$StringFieldUpdateOperationsInput.stub(_then(_instance))
        : CopyWith$Input$StringFieldUpdateOperationsInput(
            local$uuid, (e) => call(uuid: e));
  }
}

class _CopyWithStubImpl$Input$BookRevisionUpdateWithoutBookRawInput<TRes>
    implements CopyWith$Input$BookRevisionUpdateWithoutBookRawInput<TRes> {
  _CopyWithStubImpl$Input$BookRevisionUpdateWithoutBookRawInput(this._res);

  TRes _res;

  call({
    Input$BookUpdateOneWithoutBookEditedNestedInput? bookEdited,
    Input$NullableIntFieldUpdateOperationsInput? completionTokens,
    Input$BookRevisionUpdatecontentInput? content,
    Input$DateTimeFieldUpdateOperationsInput? createdAt,
    Input$BoolFieldUpdateOperationsInput? isRaw,
    Input$NullableStringFieldUpdateOperationsInput? model,
    Input$NullableIntFieldUpdateOperationsInput? promptTokens,
    Input$NullableStringFieldUpdateOperationsInput? raw,
    Input$NullableStringFieldUpdateOperationsInput? requestId,
    Input$NullableStringFieldUpdateOperationsInput? systemPrompt,
    Input$NullableIntFieldUpdateOperationsInput? totalTokens,
    Input$DateTimeFieldUpdateOperationsInput? updatedAt,
    Input$NullableStringFieldUpdateOperationsInput? userPrompt,
    Input$StringFieldUpdateOperationsInput? uuid,
  }) =>
      _res;

  CopyWith$Input$BookUpdateOneWithoutBookEditedNestedInput<TRes>
      get bookEdited =>
          CopyWith$Input$BookUpdateOneWithoutBookEditedNestedInput.stub(_res);

  CopyWith$Input$NullableIntFieldUpdateOperationsInput<TRes>
      get completionTokens =>
          CopyWith$Input$NullableIntFieldUpdateOperationsInput.stub(_res);

  CopyWith$Input$BookRevisionUpdatecontentInput<TRes> get content =>
      CopyWith$Input$BookRevisionUpdatecontentInput.stub(_res);

  CopyWith$Input$DateTimeFieldUpdateOperationsInput<TRes> get createdAt =>
      CopyWith$Input$DateTimeFieldUpdateOperationsInput.stub(_res);

  CopyWith$Input$BoolFieldUpdateOperationsInput<TRes> get isRaw =>
      CopyWith$Input$BoolFieldUpdateOperationsInput.stub(_res);

  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get model =>
      CopyWith$Input$NullableStringFieldUpdateOperationsInput.stub(_res);

  CopyWith$Input$NullableIntFieldUpdateOperationsInput<TRes> get promptTokens =>
      CopyWith$Input$NullableIntFieldUpdateOperationsInput.stub(_res);

  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get raw =>
      CopyWith$Input$NullableStringFieldUpdateOperationsInput.stub(_res);

  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get requestId =>
      CopyWith$Input$NullableStringFieldUpdateOperationsInput.stub(_res);

  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes>
      get systemPrompt =>
          CopyWith$Input$NullableStringFieldUpdateOperationsInput.stub(_res);

  CopyWith$Input$NullableIntFieldUpdateOperationsInput<TRes> get totalTokens =>
      CopyWith$Input$NullableIntFieldUpdateOperationsInput.stub(_res);

  CopyWith$Input$DateTimeFieldUpdateOperationsInput<TRes> get updatedAt =>
      CopyWith$Input$DateTimeFieldUpdateOperationsInput.stub(_res);

  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes>
      get userPrompt =>
          CopyWith$Input$NullableStringFieldUpdateOperationsInput.stub(_res);

  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get uuid =>
      CopyWith$Input$StringFieldUpdateOperationsInput.stub(_res);
}

class Input$BookRevisionUpdatecontentInput {
  factory Input$BookRevisionUpdatecontentInput({
    List<String>? push,
    List<String>? $set,
  }) =>
      Input$BookRevisionUpdatecontentInput._({
        if (push != null) r'push': push,
        if ($set != null) r'set': $set,
      });

  Input$BookRevisionUpdatecontentInput._(this._$data);

  factory Input$BookRevisionUpdatecontentInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('push')) {
      final l$push = data['push'];
      result$data['push'] =
          (l$push as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    if (data.containsKey('set')) {
      final l$$set = data['set'];
      result$data['set'] =
          (l$$set as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    return Input$BookRevisionUpdatecontentInput._(result$data);
  }

  Map<String, dynamic> _$data;

  List<String>? get push => (_$data['push'] as List<String>?);

  List<String>? get $set => (_$data['set'] as List<String>?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('push')) {
      final l$push = push;
      result$data['push'] = l$push?.map((e) => e).toList();
    }
    if (_$data.containsKey('set')) {
      final l$$set = $set;
      result$data['set'] = l$$set?.map((e) => e).toList();
    }
    return result$data;
  }

  CopyWith$Input$BookRevisionUpdatecontentInput<
          Input$BookRevisionUpdatecontentInput>
      get copyWith => CopyWith$Input$BookRevisionUpdatecontentInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$BookRevisionUpdatecontentInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$push = push;
    final lOther$push = other.push;
    if (_$data.containsKey('push') != other._$data.containsKey('push')) {
      return false;
    }
    if (l$push != null && lOther$push != null) {
      if (l$push.length != lOther$push.length) {
        return false;
      }
      for (int i = 0; i < l$push.length; i++) {
        final l$push$entry = l$push[i];
        final lOther$push$entry = lOther$push[i];
        if (l$push$entry != lOther$push$entry) {
          return false;
        }
      }
    } else if (l$push != lOther$push) {
      return false;
    }
    final l$$set = $set;
    final lOther$$set = other.$set;
    if (_$data.containsKey('set') != other._$data.containsKey('set')) {
      return false;
    }
    if (l$$set != null && lOther$$set != null) {
      if (l$$set.length != lOther$$set.length) {
        return false;
      }
      for (int i = 0; i < l$$set.length; i++) {
        final l$$set$entry = l$$set[i];
        final lOther$$set$entry = lOther$$set[i];
        if (l$$set$entry != lOther$$set$entry) {
          return false;
        }
      }
    } else if (l$$set != lOther$$set) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$push = push;
    final l$$set = $set;
    return Object.hashAll([
      _$data.containsKey('push')
          ? l$push == null
              ? null
              : Object.hashAll(l$push.map((v) => v))
          : const {},
      _$data.containsKey('set')
          ? l$$set == null
              ? null
              : Object.hashAll(l$$set.map((v) => v))
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$BookRevisionUpdatecontentInput<TRes> {
  factory CopyWith$Input$BookRevisionUpdatecontentInput(
    Input$BookRevisionUpdatecontentInput instance,
    TRes Function(Input$BookRevisionUpdatecontentInput) then,
  ) = _CopyWithImpl$Input$BookRevisionUpdatecontentInput;

  factory CopyWith$Input$BookRevisionUpdatecontentInput.stub(TRes res) =
      _CopyWithStubImpl$Input$BookRevisionUpdatecontentInput;

  TRes call({
    List<String>? push,
    List<String>? $set,
  });
}

class _CopyWithImpl$Input$BookRevisionUpdatecontentInput<TRes>
    implements CopyWith$Input$BookRevisionUpdatecontentInput<TRes> {
  _CopyWithImpl$Input$BookRevisionUpdatecontentInput(
    this._instance,
    this._then,
  );

  final Input$BookRevisionUpdatecontentInput _instance;

  final TRes Function(Input$BookRevisionUpdatecontentInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? push = _undefined,
    Object? $set = _undefined,
  }) =>
      _then(Input$BookRevisionUpdatecontentInput._({
        ..._instance._$data,
        if (push != _undefined) 'push': (push as List<String>?),
        if ($set != _undefined) 'set': ($set as List<String>?),
      }));
}

class _CopyWithStubImpl$Input$BookRevisionUpdatecontentInput<TRes>
    implements CopyWith$Input$BookRevisionUpdatecontentInput<TRes> {
  _CopyWithStubImpl$Input$BookRevisionUpdatecontentInput(this._res);

  TRes _res;

  call({
    List<String>? push,
    List<String>? $set,
  }) =>
      _res;
}

class Input$BookRevisionUpsertWithoutBookEditedInput {
  factory Input$BookRevisionUpsertWithoutBookEditedInput({
    required Input$BookRevisionCreateWithoutBookEditedInput create,
    required Input$BookRevisionUpdateWithoutBookEditedInput update,
    Input$BookRevisionWhereInput? where,
  }) =>
      Input$BookRevisionUpsertWithoutBookEditedInput._({
        r'create': create,
        r'update': update,
        if (where != null) r'where': where,
      });

  Input$BookRevisionUpsertWithoutBookEditedInput._(this._$data);

  factory Input$BookRevisionUpsertWithoutBookEditedInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$create = data['create'];
    result$data['create'] =
        Input$BookRevisionCreateWithoutBookEditedInput.fromJson(
            (l$create as Map<String, dynamic>));
    final l$update = data['update'];
    result$data['update'] =
        Input$BookRevisionUpdateWithoutBookEditedInput.fromJson(
            (l$update as Map<String, dynamic>));
    if (data.containsKey('where')) {
      final l$where = data['where'];
      result$data['where'] = l$where == null
          ? null
          : Input$BookRevisionWhereInput.fromJson(
              (l$where as Map<String, dynamic>));
    }
    return Input$BookRevisionUpsertWithoutBookEditedInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$BookRevisionCreateWithoutBookEditedInput get create =>
      (_$data['create'] as Input$BookRevisionCreateWithoutBookEditedInput);

  Input$BookRevisionUpdateWithoutBookEditedInput get update =>
      (_$data['update'] as Input$BookRevisionUpdateWithoutBookEditedInput);

  Input$BookRevisionWhereInput? get where =>
      (_$data['where'] as Input$BookRevisionWhereInput?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$create = create;
    result$data['create'] = l$create.toJson();
    final l$update = update;
    result$data['update'] = l$update.toJson();
    if (_$data.containsKey('where')) {
      final l$where = where;
      result$data['where'] = l$where?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$BookRevisionUpsertWithoutBookEditedInput<
          Input$BookRevisionUpsertWithoutBookEditedInput>
      get copyWith => CopyWith$Input$BookRevisionUpsertWithoutBookEditedInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$BookRevisionUpsertWithoutBookEditedInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != lOther$create) {
      return false;
    }
    final l$update = update;
    final lOther$update = other.update;
    if (l$update != lOther$update) {
      return false;
    }
    final l$where = where;
    final lOther$where = other.where;
    if (_$data.containsKey('where') != other._$data.containsKey('where')) {
      return false;
    }
    if (l$where != lOther$where) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$create = create;
    final l$update = update;
    final l$where = where;
    return Object.hashAll([
      l$create,
      l$update,
      _$data.containsKey('where') ? l$where : const {},
    ]);
  }
}

abstract class CopyWith$Input$BookRevisionUpsertWithoutBookEditedInput<TRes> {
  factory CopyWith$Input$BookRevisionUpsertWithoutBookEditedInput(
    Input$BookRevisionUpsertWithoutBookEditedInput instance,
    TRes Function(Input$BookRevisionUpsertWithoutBookEditedInput) then,
  ) = _CopyWithImpl$Input$BookRevisionUpsertWithoutBookEditedInput;

  factory CopyWith$Input$BookRevisionUpsertWithoutBookEditedInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$BookRevisionUpsertWithoutBookEditedInput;

  TRes call({
    Input$BookRevisionCreateWithoutBookEditedInput? create,
    Input$BookRevisionUpdateWithoutBookEditedInput? update,
    Input$BookRevisionWhereInput? where,
  });
  CopyWith$Input$BookRevisionCreateWithoutBookEditedInput<TRes> get create;
  CopyWith$Input$BookRevisionUpdateWithoutBookEditedInput<TRes> get update;
  CopyWith$Input$BookRevisionWhereInput<TRes> get where;
}

class _CopyWithImpl$Input$BookRevisionUpsertWithoutBookEditedInput<TRes>
    implements CopyWith$Input$BookRevisionUpsertWithoutBookEditedInput<TRes> {
  _CopyWithImpl$Input$BookRevisionUpsertWithoutBookEditedInput(
    this._instance,
    this._then,
  );

  final Input$BookRevisionUpsertWithoutBookEditedInput _instance;

  final TRes Function(Input$BookRevisionUpsertWithoutBookEditedInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? create = _undefined,
    Object? update = _undefined,
    Object? where = _undefined,
  }) =>
      _then(Input$BookRevisionUpsertWithoutBookEditedInput._({
        ..._instance._$data,
        if (create != _undefined && create != null)
          'create': (create as Input$BookRevisionCreateWithoutBookEditedInput),
        if (update != _undefined && update != null)
          'update': (update as Input$BookRevisionUpdateWithoutBookEditedInput),
        if (where != _undefined)
          'where': (where as Input$BookRevisionWhereInput?),
      }));

  CopyWith$Input$BookRevisionCreateWithoutBookEditedInput<TRes> get create {
    final local$create = _instance.create;
    return CopyWith$Input$BookRevisionCreateWithoutBookEditedInput(
        local$create, (e) => call(create: e));
  }

  CopyWith$Input$BookRevisionUpdateWithoutBookEditedInput<TRes> get update {
    final local$update = _instance.update;
    return CopyWith$Input$BookRevisionUpdateWithoutBookEditedInput(
        local$update, (e) => call(update: e));
  }

  CopyWith$Input$BookRevisionWhereInput<TRes> get where {
    final local$where = _instance.where;
    return local$where == null
        ? CopyWith$Input$BookRevisionWhereInput.stub(_then(_instance))
        : CopyWith$Input$BookRevisionWhereInput(
            local$where, (e) => call(where: e));
  }
}

class _CopyWithStubImpl$Input$BookRevisionUpsertWithoutBookEditedInput<TRes>
    implements CopyWith$Input$BookRevisionUpsertWithoutBookEditedInput<TRes> {
  _CopyWithStubImpl$Input$BookRevisionUpsertWithoutBookEditedInput(this._res);

  TRes _res;

  call({
    Input$BookRevisionCreateWithoutBookEditedInput? create,
    Input$BookRevisionUpdateWithoutBookEditedInput? update,
    Input$BookRevisionWhereInput? where,
  }) =>
      _res;

  CopyWith$Input$BookRevisionCreateWithoutBookEditedInput<TRes> get create =>
      CopyWith$Input$BookRevisionCreateWithoutBookEditedInput.stub(_res);

  CopyWith$Input$BookRevisionUpdateWithoutBookEditedInput<TRes> get update =>
      CopyWith$Input$BookRevisionUpdateWithoutBookEditedInput.stub(_res);

  CopyWith$Input$BookRevisionWhereInput<TRes> get where =>
      CopyWith$Input$BookRevisionWhereInput.stub(_res);
}

class Input$BookRevisionUpsertWithoutBookRawInput {
  factory Input$BookRevisionUpsertWithoutBookRawInput({
    required Input$BookRevisionCreateWithoutBookRawInput create,
    required Input$BookRevisionUpdateWithoutBookRawInput update,
    Input$BookRevisionWhereInput? where,
  }) =>
      Input$BookRevisionUpsertWithoutBookRawInput._({
        r'create': create,
        r'update': update,
        if (where != null) r'where': where,
      });

  Input$BookRevisionUpsertWithoutBookRawInput._(this._$data);

  factory Input$BookRevisionUpsertWithoutBookRawInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$create = data['create'];
    result$data['create'] =
        Input$BookRevisionCreateWithoutBookRawInput.fromJson(
            (l$create as Map<String, dynamic>));
    final l$update = data['update'];
    result$data['update'] =
        Input$BookRevisionUpdateWithoutBookRawInput.fromJson(
            (l$update as Map<String, dynamic>));
    if (data.containsKey('where')) {
      final l$where = data['where'];
      result$data['where'] = l$where == null
          ? null
          : Input$BookRevisionWhereInput.fromJson(
              (l$where as Map<String, dynamic>));
    }
    return Input$BookRevisionUpsertWithoutBookRawInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$BookRevisionCreateWithoutBookRawInput get create =>
      (_$data['create'] as Input$BookRevisionCreateWithoutBookRawInput);

  Input$BookRevisionUpdateWithoutBookRawInput get update =>
      (_$data['update'] as Input$BookRevisionUpdateWithoutBookRawInput);

  Input$BookRevisionWhereInput? get where =>
      (_$data['where'] as Input$BookRevisionWhereInput?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$create = create;
    result$data['create'] = l$create.toJson();
    final l$update = update;
    result$data['update'] = l$update.toJson();
    if (_$data.containsKey('where')) {
      final l$where = where;
      result$data['where'] = l$where?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$BookRevisionUpsertWithoutBookRawInput<
          Input$BookRevisionUpsertWithoutBookRawInput>
      get copyWith => CopyWith$Input$BookRevisionUpsertWithoutBookRawInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$BookRevisionUpsertWithoutBookRawInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != lOther$create) {
      return false;
    }
    final l$update = update;
    final lOther$update = other.update;
    if (l$update != lOther$update) {
      return false;
    }
    final l$where = where;
    final lOther$where = other.where;
    if (_$data.containsKey('where') != other._$data.containsKey('where')) {
      return false;
    }
    if (l$where != lOther$where) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$create = create;
    final l$update = update;
    final l$where = where;
    return Object.hashAll([
      l$create,
      l$update,
      _$data.containsKey('where') ? l$where : const {},
    ]);
  }
}

abstract class CopyWith$Input$BookRevisionUpsertWithoutBookRawInput<TRes> {
  factory CopyWith$Input$BookRevisionUpsertWithoutBookRawInput(
    Input$BookRevisionUpsertWithoutBookRawInput instance,
    TRes Function(Input$BookRevisionUpsertWithoutBookRawInput) then,
  ) = _CopyWithImpl$Input$BookRevisionUpsertWithoutBookRawInput;

  factory CopyWith$Input$BookRevisionUpsertWithoutBookRawInput.stub(TRes res) =
      _CopyWithStubImpl$Input$BookRevisionUpsertWithoutBookRawInput;

  TRes call({
    Input$BookRevisionCreateWithoutBookRawInput? create,
    Input$BookRevisionUpdateWithoutBookRawInput? update,
    Input$BookRevisionWhereInput? where,
  });
  CopyWith$Input$BookRevisionCreateWithoutBookRawInput<TRes> get create;
  CopyWith$Input$BookRevisionUpdateWithoutBookRawInput<TRes> get update;
  CopyWith$Input$BookRevisionWhereInput<TRes> get where;
}

class _CopyWithImpl$Input$BookRevisionUpsertWithoutBookRawInput<TRes>
    implements CopyWith$Input$BookRevisionUpsertWithoutBookRawInput<TRes> {
  _CopyWithImpl$Input$BookRevisionUpsertWithoutBookRawInput(
    this._instance,
    this._then,
  );

  final Input$BookRevisionUpsertWithoutBookRawInput _instance;

  final TRes Function(Input$BookRevisionUpsertWithoutBookRawInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? create = _undefined,
    Object? update = _undefined,
    Object? where = _undefined,
  }) =>
      _then(Input$BookRevisionUpsertWithoutBookRawInput._({
        ..._instance._$data,
        if (create != _undefined && create != null)
          'create': (create as Input$BookRevisionCreateWithoutBookRawInput),
        if (update != _undefined && update != null)
          'update': (update as Input$BookRevisionUpdateWithoutBookRawInput),
        if (where != _undefined)
          'where': (where as Input$BookRevisionWhereInput?),
      }));

  CopyWith$Input$BookRevisionCreateWithoutBookRawInput<TRes> get create {
    final local$create = _instance.create;
    return CopyWith$Input$BookRevisionCreateWithoutBookRawInput(
        local$create, (e) => call(create: e));
  }

  CopyWith$Input$BookRevisionUpdateWithoutBookRawInput<TRes> get update {
    final local$update = _instance.update;
    return CopyWith$Input$BookRevisionUpdateWithoutBookRawInput(
        local$update, (e) => call(update: e));
  }

  CopyWith$Input$BookRevisionWhereInput<TRes> get where {
    final local$where = _instance.where;
    return local$where == null
        ? CopyWith$Input$BookRevisionWhereInput.stub(_then(_instance))
        : CopyWith$Input$BookRevisionWhereInput(
            local$where, (e) => call(where: e));
  }
}

class _CopyWithStubImpl$Input$BookRevisionUpsertWithoutBookRawInput<TRes>
    implements CopyWith$Input$BookRevisionUpsertWithoutBookRawInput<TRes> {
  _CopyWithStubImpl$Input$BookRevisionUpsertWithoutBookRawInput(this._res);

  TRes _res;

  call({
    Input$BookRevisionCreateWithoutBookRawInput? create,
    Input$BookRevisionUpdateWithoutBookRawInput? update,
    Input$BookRevisionWhereInput? where,
  }) =>
      _res;

  CopyWith$Input$BookRevisionCreateWithoutBookRawInput<TRes> get create =>
      CopyWith$Input$BookRevisionCreateWithoutBookRawInput.stub(_res);

  CopyWith$Input$BookRevisionUpdateWithoutBookRawInput<TRes> get update =>
      CopyWith$Input$BookRevisionUpdateWithoutBookRawInput.stub(_res);

  CopyWith$Input$BookRevisionWhereInput<TRes> get where =>
      CopyWith$Input$BookRevisionWhereInput.stub(_res);
}

class Input$BookRevisionWhereInput {
  factory Input$BookRevisionWhereInput({
    List<Input$BookRevisionWhereInput>? AND,
    List<Input$BookRevisionWhereInput>? NOT,
    List<Input$BookRevisionWhereInput>? OR,
    Input$BookNullableRelationFilter? bookEdited,
    Input$UuidNullableFilter? bookEditedId,
    Input$BookNullableRelationFilter? bookRaw,
    Input$UuidNullableFilter? bookRawId,
    Input$IntNullableFilter? completionTokens,
    Input$StringNullableListFilter? content,
    Input$DateTimeFilter? createdAt,
    Input$BoolFilter? isRaw,
    Input$StringNullableFilter? model,
    Input$IntNullableFilter? promptTokens,
    Input$StringNullableFilter? raw,
    Input$StringNullableFilter? requestId,
    Input$StringNullableFilter? systemPrompt,
    Input$IntNullableFilter? totalTokens,
    Input$DateTimeFilter? updatedAt,
    Input$StringNullableFilter? userPrompt,
    Input$UuidFilter? uuid,
  }) =>
      Input$BookRevisionWhereInput._({
        if (AND != null) r'AND': AND,
        if (NOT != null) r'NOT': NOT,
        if (OR != null) r'OR': OR,
        if (bookEdited != null) r'bookEdited': bookEdited,
        if (bookEditedId != null) r'bookEditedId': bookEditedId,
        if (bookRaw != null) r'bookRaw': bookRaw,
        if (bookRawId != null) r'bookRawId': bookRawId,
        if (completionTokens != null) r'completionTokens': completionTokens,
        if (content != null) r'content': content,
        if (createdAt != null) r'createdAt': createdAt,
        if (isRaw != null) r'isRaw': isRaw,
        if (model != null) r'model': model,
        if (promptTokens != null) r'promptTokens': promptTokens,
        if (raw != null) r'raw': raw,
        if (requestId != null) r'requestId': requestId,
        if (systemPrompt != null) r'systemPrompt': systemPrompt,
        if (totalTokens != null) r'totalTokens': totalTokens,
        if (updatedAt != null) r'updatedAt': updatedAt,
        if (userPrompt != null) r'userPrompt': userPrompt,
        if (uuid != null) r'uuid': uuid,
      });

  Input$BookRevisionWhereInput._(this._$data);

  factory Input$BookRevisionWhereInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('AND')) {
      final l$AND = data['AND'];
      result$data['AND'] = (l$AND as List<dynamic>?)
          ?.map((e) => Input$BookRevisionWhereInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('NOT')) {
      final l$NOT = data['NOT'];
      result$data['NOT'] = (l$NOT as List<dynamic>?)
          ?.map((e) => Input$BookRevisionWhereInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('OR')) {
      final l$OR = data['OR'];
      result$data['OR'] = (l$OR as List<dynamic>?)
          ?.map((e) => Input$BookRevisionWhereInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('bookEdited')) {
      final l$bookEdited = data['bookEdited'];
      result$data['bookEdited'] = l$bookEdited == null
          ? null
          : Input$BookNullableRelationFilter.fromJson(
              (l$bookEdited as Map<String, dynamic>));
    }
    if (data.containsKey('bookEditedId')) {
      final l$bookEditedId = data['bookEditedId'];
      result$data['bookEditedId'] = l$bookEditedId == null
          ? null
          : Input$UuidNullableFilter.fromJson(
              (l$bookEditedId as Map<String, dynamic>));
    }
    if (data.containsKey('bookRaw')) {
      final l$bookRaw = data['bookRaw'];
      result$data['bookRaw'] = l$bookRaw == null
          ? null
          : Input$BookNullableRelationFilter.fromJson(
              (l$bookRaw as Map<String, dynamic>));
    }
    if (data.containsKey('bookRawId')) {
      final l$bookRawId = data['bookRawId'];
      result$data['bookRawId'] = l$bookRawId == null
          ? null
          : Input$UuidNullableFilter.fromJson(
              (l$bookRawId as Map<String, dynamic>));
    }
    if (data.containsKey('completionTokens')) {
      final l$completionTokens = data['completionTokens'];
      result$data['completionTokens'] = l$completionTokens == null
          ? null
          : Input$IntNullableFilter.fromJson(
              (l$completionTokens as Map<String, dynamic>));
    }
    if (data.containsKey('content')) {
      final l$content = data['content'];
      result$data['content'] = l$content == null
          ? null
          : Input$StringNullableListFilter.fromJson(
              (l$content as Map<String, dynamic>));
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : Input$DateTimeFilter.fromJson(
              (l$createdAt as Map<String, dynamic>));
    }
    if (data.containsKey('isRaw')) {
      final l$isRaw = data['isRaw'];
      result$data['isRaw'] = l$isRaw == null
          ? null
          : Input$BoolFilter.fromJson((l$isRaw as Map<String, dynamic>));
    }
    if (data.containsKey('model')) {
      final l$model = data['model'];
      result$data['model'] = l$model == null
          ? null
          : Input$StringNullableFilter.fromJson(
              (l$model as Map<String, dynamic>));
    }
    if (data.containsKey('promptTokens')) {
      final l$promptTokens = data['promptTokens'];
      result$data['promptTokens'] = l$promptTokens == null
          ? null
          : Input$IntNullableFilter.fromJson(
              (l$promptTokens as Map<String, dynamic>));
    }
    if (data.containsKey('raw')) {
      final l$raw = data['raw'];
      result$data['raw'] = l$raw == null
          ? null
          : Input$StringNullableFilter.fromJson(
              (l$raw as Map<String, dynamic>));
    }
    if (data.containsKey('requestId')) {
      final l$requestId = data['requestId'];
      result$data['requestId'] = l$requestId == null
          ? null
          : Input$StringNullableFilter.fromJson(
              (l$requestId as Map<String, dynamic>));
    }
    if (data.containsKey('systemPrompt')) {
      final l$systemPrompt = data['systemPrompt'];
      result$data['systemPrompt'] = l$systemPrompt == null
          ? null
          : Input$StringNullableFilter.fromJson(
              (l$systemPrompt as Map<String, dynamic>));
    }
    if (data.containsKey('totalTokens')) {
      final l$totalTokens = data['totalTokens'];
      result$data['totalTokens'] = l$totalTokens == null
          ? null
          : Input$IntNullableFilter.fromJson(
              (l$totalTokens as Map<String, dynamic>));
    }
    if (data.containsKey('updatedAt')) {
      final l$updatedAt = data['updatedAt'];
      result$data['updatedAt'] = l$updatedAt == null
          ? null
          : Input$DateTimeFilter.fromJson(
              (l$updatedAt as Map<String, dynamic>));
    }
    if (data.containsKey('userPrompt')) {
      final l$userPrompt = data['userPrompt'];
      result$data['userPrompt'] = l$userPrompt == null
          ? null
          : Input$StringNullableFilter.fromJson(
              (l$userPrompt as Map<String, dynamic>));
    }
    if (data.containsKey('uuid')) {
      final l$uuid = data['uuid'];
      result$data['uuid'] = l$uuid == null
          ? null
          : Input$UuidFilter.fromJson((l$uuid as Map<String, dynamic>));
    }
    return Input$BookRevisionWhereInput._(result$data);
  }

  Map<String, dynamic> _$data;

  List<Input$BookRevisionWhereInput>? get AND =>
      (_$data['AND'] as List<Input$BookRevisionWhereInput>?);

  List<Input$BookRevisionWhereInput>? get NOT =>
      (_$data['NOT'] as List<Input$BookRevisionWhereInput>?);

  List<Input$BookRevisionWhereInput>? get OR =>
      (_$data['OR'] as List<Input$BookRevisionWhereInput>?);

  Input$BookNullableRelationFilter? get bookEdited =>
      (_$data['bookEdited'] as Input$BookNullableRelationFilter?);

  Input$UuidNullableFilter? get bookEditedId =>
      (_$data['bookEditedId'] as Input$UuidNullableFilter?);

  Input$BookNullableRelationFilter? get bookRaw =>
      (_$data['bookRaw'] as Input$BookNullableRelationFilter?);

  Input$UuidNullableFilter? get bookRawId =>
      (_$data['bookRawId'] as Input$UuidNullableFilter?);

  Input$IntNullableFilter? get completionTokens =>
      (_$data['completionTokens'] as Input$IntNullableFilter?);

  Input$StringNullableListFilter? get content =>
      (_$data['content'] as Input$StringNullableListFilter?);

  Input$DateTimeFilter? get createdAt =>
      (_$data['createdAt'] as Input$DateTimeFilter?);

  Input$BoolFilter? get isRaw => (_$data['isRaw'] as Input$BoolFilter?);

  Input$StringNullableFilter? get model =>
      (_$data['model'] as Input$StringNullableFilter?);

  Input$IntNullableFilter? get promptTokens =>
      (_$data['promptTokens'] as Input$IntNullableFilter?);

  Input$StringNullableFilter? get raw =>
      (_$data['raw'] as Input$StringNullableFilter?);

  Input$StringNullableFilter? get requestId =>
      (_$data['requestId'] as Input$StringNullableFilter?);

  Input$StringNullableFilter? get systemPrompt =>
      (_$data['systemPrompt'] as Input$StringNullableFilter?);

  Input$IntNullableFilter? get totalTokens =>
      (_$data['totalTokens'] as Input$IntNullableFilter?);

  Input$DateTimeFilter? get updatedAt =>
      (_$data['updatedAt'] as Input$DateTimeFilter?);

  Input$StringNullableFilter? get userPrompt =>
      (_$data['userPrompt'] as Input$StringNullableFilter?);

  Input$UuidFilter? get uuid => (_$data['uuid'] as Input$UuidFilter?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('AND')) {
      final l$AND = AND;
      result$data['AND'] = l$AND?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('NOT')) {
      final l$NOT = NOT;
      result$data['NOT'] = l$NOT?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('OR')) {
      final l$OR = OR;
      result$data['OR'] = l$OR?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('bookEdited')) {
      final l$bookEdited = bookEdited;
      result$data['bookEdited'] = l$bookEdited?.toJson();
    }
    if (_$data.containsKey('bookEditedId')) {
      final l$bookEditedId = bookEditedId;
      result$data['bookEditedId'] = l$bookEditedId?.toJson();
    }
    if (_$data.containsKey('bookRaw')) {
      final l$bookRaw = bookRaw;
      result$data['bookRaw'] = l$bookRaw?.toJson();
    }
    if (_$data.containsKey('bookRawId')) {
      final l$bookRawId = bookRawId;
      result$data['bookRawId'] = l$bookRawId?.toJson();
    }
    if (_$data.containsKey('completionTokens')) {
      final l$completionTokens = completionTokens;
      result$data['completionTokens'] = l$completionTokens?.toJson();
    }
    if (_$data.containsKey('content')) {
      final l$content = content;
      result$data['content'] = l$content?.toJson();
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toJson();
    }
    if (_$data.containsKey('isRaw')) {
      final l$isRaw = isRaw;
      result$data['isRaw'] = l$isRaw?.toJson();
    }
    if (_$data.containsKey('model')) {
      final l$model = model;
      result$data['model'] = l$model?.toJson();
    }
    if (_$data.containsKey('promptTokens')) {
      final l$promptTokens = promptTokens;
      result$data['promptTokens'] = l$promptTokens?.toJson();
    }
    if (_$data.containsKey('raw')) {
      final l$raw = raw;
      result$data['raw'] = l$raw?.toJson();
    }
    if (_$data.containsKey('requestId')) {
      final l$requestId = requestId;
      result$data['requestId'] = l$requestId?.toJson();
    }
    if (_$data.containsKey('systemPrompt')) {
      final l$systemPrompt = systemPrompt;
      result$data['systemPrompt'] = l$systemPrompt?.toJson();
    }
    if (_$data.containsKey('totalTokens')) {
      final l$totalTokens = totalTokens;
      result$data['totalTokens'] = l$totalTokens?.toJson();
    }
    if (_$data.containsKey('updatedAt')) {
      final l$updatedAt = updatedAt;
      result$data['updatedAt'] = l$updatedAt?.toJson();
    }
    if (_$data.containsKey('userPrompt')) {
      final l$userPrompt = userPrompt;
      result$data['userPrompt'] = l$userPrompt?.toJson();
    }
    if (_$data.containsKey('uuid')) {
      final l$uuid = uuid;
      result$data['uuid'] = l$uuid?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$BookRevisionWhereInput<Input$BookRevisionWhereInput>
      get copyWith => CopyWith$Input$BookRevisionWhereInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$BookRevisionWhereInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$AND = AND;
    final lOther$AND = other.AND;
    if (_$data.containsKey('AND') != other._$data.containsKey('AND')) {
      return false;
    }
    if (l$AND != null && lOther$AND != null) {
      if (l$AND.length != lOther$AND.length) {
        return false;
      }
      for (int i = 0; i < l$AND.length; i++) {
        final l$AND$entry = l$AND[i];
        final lOther$AND$entry = lOther$AND[i];
        if (l$AND$entry != lOther$AND$entry) {
          return false;
        }
      }
    } else if (l$AND != lOther$AND) {
      return false;
    }
    final l$NOT = NOT;
    final lOther$NOT = other.NOT;
    if (_$data.containsKey('NOT') != other._$data.containsKey('NOT')) {
      return false;
    }
    if (l$NOT != null && lOther$NOT != null) {
      if (l$NOT.length != lOther$NOT.length) {
        return false;
      }
      for (int i = 0; i < l$NOT.length; i++) {
        final l$NOT$entry = l$NOT[i];
        final lOther$NOT$entry = lOther$NOT[i];
        if (l$NOT$entry != lOther$NOT$entry) {
          return false;
        }
      }
    } else if (l$NOT != lOther$NOT) {
      return false;
    }
    final l$OR = OR;
    final lOther$OR = other.OR;
    if (_$data.containsKey('OR') != other._$data.containsKey('OR')) {
      return false;
    }
    if (l$OR != null && lOther$OR != null) {
      if (l$OR.length != lOther$OR.length) {
        return false;
      }
      for (int i = 0; i < l$OR.length; i++) {
        final l$OR$entry = l$OR[i];
        final lOther$OR$entry = lOther$OR[i];
        if (l$OR$entry != lOther$OR$entry) {
          return false;
        }
      }
    } else if (l$OR != lOther$OR) {
      return false;
    }
    final l$bookEdited = bookEdited;
    final lOther$bookEdited = other.bookEdited;
    if (_$data.containsKey('bookEdited') !=
        other._$data.containsKey('bookEdited')) {
      return false;
    }
    if (l$bookEdited != lOther$bookEdited) {
      return false;
    }
    final l$bookEditedId = bookEditedId;
    final lOther$bookEditedId = other.bookEditedId;
    if (_$data.containsKey('bookEditedId') !=
        other._$data.containsKey('bookEditedId')) {
      return false;
    }
    if (l$bookEditedId != lOther$bookEditedId) {
      return false;
    }
    final l$bookRaw = bookRaw;
    final lOther$bookRaw = other.bookRaw;
    if (_$data.containsKey('bookRaw') != other._$data.containsKey('bookRaw')) {
      return false;
    }
    if (l$bookRaw != lOther$bookRaw) {
      return false;
    }
    final l$bookRawId = bookRawId;
    final lOther$bookRawId = other.bookRawId;
    if (_$data.containsKey('bookRawId') !=
        other._$data.containsKey('bookRawId')) {
      return false;
    }
    if (l$bookRawId != lOther$bookRawId) {
      return false;
    }
    final l$completionTokens = completionTokens;
    final lOther$completionTokens = other.completionTokens;
    if (_$data.containsKey('completionTokens') !=
        other._$data.containsKey('completionTokens')) {
      return false;
    }
    if (l$completionTokens != lOther$completionTokens) {
      return false;
    }
    final l$content = content;
    final lOther$content = other.content;
    if (_$data.containsKey('content') != other._$data.containsKey('content')) {
      return false;
    }
    if (l$content != lOther$content) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$isRaw = isRaw;
    final lOther$isRaw = other.isRaw;
    if (_$data.containsKey('isRaw') != other._$data.containsKey('isRaw')) {
      return false;
    }
    if (l$isRaw != lOther$isRaw) {
      return false;
    }
    final l$model = model;
    final lOther$model = other.model;
    if (_$data.containsKey('model') != other._$data.containsKey('model')) {
      return false;
    }
    if (l$model != lOther$model) {
      return false;
    }
    final l$promptTokens = promptTokens;
    final lOther$promptTokens = other.promptTokens;
    if (_$data.containsKey('promptTokens') !=
        other._$data.containsKey('promptTokens')) {
      return false;
    }
    if (l$promptTokens != lOther$promptTokens) {
      return false;
    }
    final l$raw = raw;
    final lOther$raw = other.raw;
    if (_$data.containsKey('raw') != other._$data.containsKey('raw')) {
      return false;
    }
    if (l$raw != lOther$raw) {
      return false;
    }
    final l$requestId = requestId;
    final lOther$requestId = other.requestId;
    if (_$data.containsKey('requestId') !=
        other._$data.containsKey('requestId')) {
      return false;
    }
    if (l$requestId != lOther$requestId) {
      return false;
    }
    final l$systemPrompt = systemPrompt;
    final lOther$systemPrompt = other.systemPrompt;
    if (_$data.containsKey('systemPrompt') !=
        other._$data.containsKey('systemPrompt')) {
      return false;
    }
    if (l$systemPrompt != lOther$systemPrompt) {
      return false;
    }
    final l$totalTokens = totalTokens;
    final lOther$totalTokens = other.totalTokens;
    if (_$data.containsKey('totalTokens') !=
        other._$data.containsKey('totalTokens')) {
      return false;
    }
    if (l$totalTokens != lOther$totalTokens) {
      return false;
    }
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (_$data.containsKey('updatedAt') !=
        other._$data.containsKey('updatedAt')) {
      return false;
    }
    if (l$updatedAt != lOther$updatedAt) {
      return false;
    }
    final l$userPrompt = userPrompt;
    final lOther$userPrompt = other.userPrompt;
    if (_$data.containsKey('userPrompt') !=
        other._$data.containsKey('userPrompt')) {
      return false;
    }
    if (l$userPrompt != lOther$userPrompt) {
      return false;
    }
    final l$uuid = uuid;
    final lOther$uuid = other.uuid;
    if (_$data.containsKey('uuid') != other._$data.containsKey('uuid')) {
      return false;
    }
    if (l$uuid != lOther$uuid) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$AND = AND;
    final l$NOT = NOT;
    final l$OR = OR;
    final l$bookEdited = bookEdited;
    final l$bookEditedId = bookEditedId;
    final l$bookRaw = bookRaw;
    final l$bookRawId = bookRawId;
    final l$completionTokens = completionTokens;
    final l$content = content;
    final l$createdAt = createdAt;
    final l$isRaw = isRaw;
    final l$model = model;
    final l$promptTokens = promptTokens;
    final l$raw = raw;
    final l$requestId = requestId;
    final l$systemPrompt = systemPrompt;
    final l$totalTokens = totalTokens;
    final l$updatedAt = updatedAt;
    final l$userPrompt = userPrompt;
    final l$uuid = uuid;
    return Object.hashAll([
      _$data.containsKey('AND')
          ? l$AND == null
              ? null
              : Object.hashAll(l$AND.map((v) => v))
          : const {},
      _$data.containsKey('NOT')
          ? l$NOT == null
              ? null
              : Object.hashAll(l$NOT.map((v) => v))
          : const {},
      _$data.containsKey('OR')
          ? l$OR == null
              ? null
              : Object.hashAll(l$OR.map((v) => v))
          : const {},
      _$data.containsKey('bookEdited') ? l$bookEdited : const {},
      _$data.containsKey('bookEditedId') ? l$bookEditedId : const {},
      _$data.containsKey('bookRaw') ? l$bookRaw : const {},
      _$data.containsKey('bookRawId') ? l$bookRawId : const {},
      _$data.containsKey('completionTokens') ? l$completionTokens : const {},
      _$data.containsKey('content') ? l$content : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('isRaw') ? l$isRaw : const {},
      _$data.containsKey('model') ? l$model : const {},
      _$data.containsKey('promptTokens') ? l$promptTokens : const {},
      _$data.containsKey('raw') ? l$raw : const {},
      _$data.containsKey('requestId') ? l$requestId : const {},
      _$data.containsKey('systemPrompt') ? l$systemPrompt : const {},
      _$data.containsKey('totalTokens') ? l$totalTokens : const {},
      _$data.containsKey('updatedAt') ? l$updatedAt : const {},
      _$data.containsKey('userPrompt') ? l$userPrompt : const {},
      _$data.containsKey('uuid') ? l$uuid : const {},
    ]);
  }
}

abstract class CopyWith$Input$BookRevisionWhereInput<TRes> {
  factory CopyWith$Input$BookRevisionWhereInput(
    Input$BookRevisionWhereInput instance,
    TRes Function(Input$BookRevisionWhereInput) then,
  ) = _CopyWithImpl$Input$BookRevisionWhereInput;

  factory CopyWith$Input$BookRevisionWhereInput.stub(TRes res) =
      _CopyWithStubImpl$Input$BookRevisionWhereInput;

  TRes call({
    List<Input$BookRevisionWhereInput>? AND,
    List<Input$BookRevisionWhereInput>? NOT,
    List<Input$BookRevisionWhereInput>? OR,
    Input$BookNullableRelationFilter? bookEdited,
    Input$UuidNullableFilter? bookEditedId,
    Input$BookNullableRelationFilter? bookRaw,
    Input$UuidNullableFilter? bookRawId,
    Input$IntNullableFilter? completionTokens,
    Input$StringNullableListFilter? content,
    Input$DateTimeFilter? createdAt,
    Input$BoolFilter? isRaw,
    Input$StringNullableFilter? model,
    Input$IntNullableFilter? promptTokens,
    Input$StringNullableFilter? raw,
    Input$StringNullableFilter? requestId,
    Input$StringNullableFilter? systemPrompt,
    Input$IntNullableFilter? totalTokens,
    Input$DateTimeFilter? updatedAt,
    Input$StringNullableFilter? userPrompt,
    Input$UuidFilter? uuid,
  });
  TRes AND(
      Iterable<Input$BookRevisionWhereInput>? Function(
              Iterable<
                  CopyWith$Input$BookRevisionWhereInput<
                      Input$BookRevisionWhereInput>>?)
          _fn);
  TRes NOT(
      Iterable<Input$BookRevisionWhereInput>? Function(
              Iterable<
                  CopyWith$Input$BookRevisionWhereInput<
                      Input$BookRevisionWhereInput>>?)
          _fn);
  TRes OR(
      Iterable<Input$BookRevisionWhereInput>? Function(
              Iterable<
                  CopyWith$Input$BookRevisionWhereInput<
                      Input$BookRevisionWhereInput>>?)
          _fn);
  CopyWith$Input$BookNullableRelationFilter<TRes> get bookEdited;
  CopyWith$Input$UuidNullableFilter<TRes> get bookEditedId;
  CopyWith$Input$BookNullableRelationFilter<TRes> get bookRaw;
  CopyWith$Input$UuidNullableFilter<TRes> get bookRawId;
  CopyWith$Input$IntNullableFilter<TRes> get completionTokens;
  CopyWith$Input$StringNullableListFilter<TRes> get content;
  CopyWith$Input$DateTimeFilter<TRes> get createdAt;
  CopyWith$Input$BoolFilter<TRes> get isRaw;
  CopyWith$Input$StringNullableFilter<TRes> get model;
  CopyWith$Input$IntNullableFilter<TRes> get promptTokens;
  CopyWith$Input$StringNullableFilter<TRes> get raw;
  CopyWith$Input$StringNullableFilter<TRes> get requestId;
  CopyWith$Input$StringNullableFilter<TRes> get systemPrompt;
  CopyWith$Input$IntNullableFilter<TRes> get totalTokens;
  CopyWith$Input$DateTimeFilter<TRes> get updatedAt;
  CopyWith$Input$StringNullableFilter<TRes> get userPrompt;
  CopyWith$Input$UuidFilter<TRes> get uuid;
}

class _CopyWithImpl$Input$BookRevisionWhereInput<TRes>
    implements CopyWith$Input$BookRevisionWhereInput<TRes> {
  _CopyWithImpl$Input$BookRevisionWhereInput(
    this._instance,
    this._then,
  );

  final Input$BookRevisionWhereInput _instance;

  final TRes Function(Input$BookRevisionWhereInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? AND = _undefined,
    Object? NOT = _undefined,
    Object? OR = _undefined,
    Object? bookEdited = _undefined,
    Object? bookEditedId = _undefined,
    Object? bookRaw = _undefined,
    Object? bookRawId = _undefined,
    Object? completionTokens = _undefined,
    Object? content = _undefined,
    Object? createdAt = _undefined,
    Object? isRaw = _undefined,
    Object? model = _undefined,
    Object? promptTokens = _undefined,
    Object? raw = _undefined,
    Object? requestId = _undefined,
    Object? systemPrompt = _undefined,
    Object? totalTokens = _undefined,
    Object? updatedAt = _undefined,
    Object? userPrompt = _undefined,
    Object? uuid = _undefined,
  }) =>
      _then(Input$BookRevisionWhereInput._({
        ..._instance._$data,
        if (AND != _undefined)
          'AND': (AND as List<Input$BookRevisionWhereInput>?),
        if (NOT != _undefined)
          'NOT': (NOT as List<Input$BookRevisionWhereInput>?),
        if (OR != _undefined) 'OR': (OR as List<Input$BookRevisionWhereInput>?),
        if (bookEdited != _undefined)
          'bookEdited': (bookEdited as Input$BookNullableRelationFilter?),
        if (bookEditedId != _undefined)
          'bookEditedId': (bookEditedId as Input$UuidNullableFilter?),
        if (bookRaw != _undefined)
          'bookRaw': (bookRaw as Input$BookNullableRelationFilter?),
        if (bookRawId != _undefined)
          'bookRawId': (bookRawId as Input$UuidNullableFilter?),
        if (completionTokens != _undefined)
          'completionTokens': (completionTokens as Input$IntNullableFilter?),
        if (content != _undefined)
          'content': (content as Input$StringNullableListFilter?),
        if (createdAt != _undefined)
          'createdAt': (createdAt as Input$DateTimeFilter?),
        if (isRaw != _undefined) 'isRaw': (isRaw as Input$BoolFilter?),
        if (model != _undefined)
          'model': (model as Input$StringNullableFilter?),
        if (promptTokens != _undefined)
          'promptTokens': (promptTokens as Input$IntNullableFilter?),
        if (raw != _undefined) 'raw': (raw as Input$StringNullableFilter?),
        if (requestId != _undefined)
          'requestId': (requestId as Input$StringNullableFilter?),
        if (systemPrompt != _undefined)
          'systemPrompt': (systemPrompt as Input$StringNullableFilter?),
        if (totalTokens != _undefined)
          'totalTokens': (totalTokens as Input$IntNullableFilter?),
        if (updatedAt != _undefined)
          'updatedAt': (updatedAt as Input$DateTimeFilter?),
        if (userPrompt != _undefined)
          'userPrompt': (userPrompt as Input$StringNullableFilter?),
        if (uuid != _undefined) 'uuid': (uuid as Input$UuidFilter?),
      }));

  TRes AND(
          Iterable<Input$BookRevisionWhereInput>? Function(
                  Iterable<
                      CopyWith$Input$BookRevisionWhereInput<
                          Input$BookRevisionWhereInput>>?)
              _fn) =>
      call(
          AND: _fn(
              _instance.AND?.map((e) => CopyWith$Input$BookRevisionWhereInput(
                    e,
                    (i) => i,
                  )))?.toList());

  TRes NOT(
          Iterable<Input$BookRevisionWhereInput>? Function(
                  Iterable<
                      CopyWith$Input$BookRevisionWhereInput<
                          Input$BookRevisionWhereInput>>?)
              _fn) =>
      call(
          NOT: _fn(
              _instance.NOT?.map((e) => CopyWith$Input$BookRevisionWhereInput(
                    e,
                    (i) => i,
                  )))?.toList());

  TRes OR(
          Iterable<Input$BookRevisionWhereInput>? Function(
                  Iterable<
                      CopyWith$Input$BookRevisionWhereInput<
                          Input$BookRevisionWhereInput>>?)
              _fn) =>
      call(
          OR: _fn(
              _instance.OR?.map((e) => CopyWith$Input$BookRevisionWhereInput(
                    e,
                    (i) => i,
                  )))?.toList());

  CopyWith$Input$BookNullableRelationFilter<TRes> get bookEdited {
    final local$bookEdited = _instance.bookEdited;
    return local$bookEdited == null
        ? CopyWith$Input$BookNullableRelationFilter.stub(_then(_instance))
        : CopyWith$Input$BookNullableRelationFilter(
            local$bookEdited, (e) => call(bookEdited: e));
  }

  CopyWith$Input$UuidNullableFilter<TRes> get bookEditedId {
    final local$bookEditedId = _instance.bookEditedId;
    return local$bookEditedId == null
        ? CopyWith$Input$UuidNullableFilter.stub(_then(_instance))
        : CopyWith$Input$UuidNullableFilter(
            local$bookEditedId, (e) => call(bookEditedId: e));
  }

  CopyWith$Input$BookNullableRelationFilter<TRes> get bookRaw {
    final local$bookRaw = _instance.bookRaw;
    return local$bookRaw == null
        ? CopyWith$Input$BookNullableRelationFilter.stub(_then(_instance))
        : CopyWith$Input$BookNullableRelationFilter(
            local$bookRaw, (e) => call(bookRaw: e));
  }

  CopyWith$Input$UuidNullableFilter<TRes> get bookRawId {
    final local$bookRawId = _instance.bookRawId;
    return local$bookRawId == null
        ? CopyWith$Input$UuidNullableFilter.stub(_then(_instance))
        : CopyWith$Input$UuidNullableFilter(
            local$bookRawId, (e) => call(bookRawId: e));
  }

  CopyWith$Input$IntNullableFilter<TRes> get completionTokens {
    final local$completionTokens = _instance.completionTokens;
    return local$completionTokens == null
        ? CopyWith$Input$IntNullableFilter.stub(_then(_instance))
        : CopyWith$Input$IntNullableFilter(
            local$completionTokens, (e) => call(completionTokens: e));
  }

  CopyWith$Input$StringNullableListFilter<TRes> get content {
    final local$content = _instance.content;
    return local$content == null
        ? CopyWith$Input$StringNullableListFilter.stub(_then(_instance))
        : CopyWith$Input$StringNullableListFilter(
            local$content, (e) => call(content: e));
  }

  CopyWith$Input$DateTimeFilter<TRes> get createdAt {
    final local$createdAt = _instance.createdAt;
    return local$createdAt == null
        ? CopyWith$Input$DateTimeFilter.stub(_then(_instance))
        : CopyWith$Input$DateTimeFilter(
            local$createdAt, (e) => call(createdAt: e));
  }

  CopyWith$Input$BoolFilter<TRes> get isRaw {
    final local$isRaw = _instance.isRaw;
    return local$isRaw == null
        ? CopyWith$Input$BoolFilter.stub(_then(_instance))
        : CopyWith$Input$BoolFilter(local$isRaw, (e) => call(isRaw: e));
  }

  CopyWith$Input$StringNullableFilter<TRes> get model {
    final local$model = _instance.model;
    return local$model == null
        ? CopyWith$Input$StringNullableFilter.stub(_then(_instance))
        : CopyWith$Input$StringNullableFilter(
            local$model, (e) => call(model: e));
  }

  CopyWith$Input$IntNullableFilter<TRes> get promptTokens {
    final local$promptTokens = _instance.promptTokens;
    return local$promptTokens == null
        ? CopyWith$Input$IntNullableFilter.stub(_then(_instance))
        : CopyWith$Input$IntNullableFilter(
            local$promptTokens, (e) => call(promptTokens: e));
  }

  CopyWith$Input$StringNullableFilter<TRes> get raw {
    final local$raw = _instance.raw;
    return local$raw == null
        ? CopyWith$Input$StringNullableFilter.stub(_then(_instance))
        : CopyWith$Input$StringNullableFilter(local$raw, (e) => call(raw: e));
  }

  CopyWith$Input$StringNullableFilter<TRes> get requestId {
    final local$requestId = _instance.requestId;
    return local$requestId == null
        ? CopyWith$Input$StringNullableFilter.stub(_then(_instance))
        : CopyWith$Input$StringNullableFilter(
            local$requestId, (e) => call(requestId: e));
  }

  CopyWith$Input$StringNullableFilter<TRes> get systemPrompt {
    final local$systemPrompt = _instance.systemPrompt;
    return local$systemPrompt == null
        ? CopyWith$Input$StringNullableFilter.stub(_then(_instance))
        : CopyWith$Input$StringNullableFilter(
            local$systemPrompt, (e) => call(systemPrompt: e));
  }

  CopyWith$Input$IntNullableFilter<TRes> get totalTokens {
    final local$totalTokens = _instance.totalTokens;
    return local$totalTokens == null
        ? CopyWith$Input$IntNullableFilter.stub(_then(_instance))
        : CopyWith$Input$IntNullableFilter(
            local$totalTokens, (e) => call(totalTokens: e));
  }

  CopyWith$Input$DateTimeFilter<TRes> get updatedAt {
    final local$updatedAt = _instance.updatedAt;
    return local$updatedAt == null
        ? CopyWith$Input$DateTimeFilter.stub(_then(_instance))
        : CopyWith$Input$DateTimeFilter(
            local$updatedAt, (e) => call(updatedAt: e));
  }

  CopyWith$Input$StringNullableFilter<TRes> get userPrompt {
    final local$userPrompt = _instance.userPrompt;
    return local$userPrompt == null
        ? CopyWith$Input$StringNullableFilter.stub(_then(_instance))
        : CopyWith$Input$StringNullableFilter(
            local$userPrompt, (e) => call(userPrompt: e));
  }

  CopyWith$Input$UuidFilter<TRes> get uuid {
    final local$uuid = _instance.uuid;
    return local$uuid == null
        ? CopyWith$Input$UuidFilter.stub(_then(_instance))
        : CopyWith$Input$UuidFilter(local$uuid, (e) => call(uuid: e));
  }
}

class _CopyWithStubImpl$Input$BookRevisionWhereInput<TRes>
    implements CopyWith$Input$BookRevisionWhereInput<TRes> {
  _CopyWithStubImpl$Input$BookRevisionWhereInput(this._res);

  TRes _res;

  call({
    List<Input$BookRevisionWhereInput>? AND,
    List<Input$BookRevisionWhereInput>? NOT,
    List<Input$BookRevisionWhereInput>? OR,
    Input$BookNullableRelationFilter? bookEdited,
    Input$UuidNullableFilter? bookEditedId,
    Input$BookNullableRelationFilter? bookRaw,
    Input$UuidNullableFilter? bookRawId,
    Input$IntNullableFilter? completionTokens,
    Input$StringNullableListFilter? content,
    Input$DateTimeFilter? createdAt,
    Input$BoolFilter? isRaw,
    Input$StringNullableFilter? model,
    Input$IntNullableFilter? promptTokens,
    Input$StringNullableFilter? raw,
    Input$StringNullableFilter? requestId,
    Input$StringNullableFilter? systemPrompt,
    Input$IntNullableFilter? totalTokens,
    Input$DateTimeFilter? updatedAt,
    Input$StringNullableFilter? userPrompt,
    Input$UuidFilter? uuid,
  }) =>
      _res;

  AND(_fn) => _res;

  NOT(_fn) => _res;

  OR(_fn) => _res;

  CopyWith$Input$BookNullableRelationFilter<TRes> get bookEdited =>
      CopyWith$Input$BookNullableRelationFilter.stub(_res);

  CopyWith$Input$UuidNullableFilter<TRes> get bookEditedId =>
      CopyWith$Input$UuidNullableFilter.stub(_res);

  CopyWith$Input$BookNullableRelationFilter<TRes> get bookRaw =>
      CopyWith$Input$BookNullableRelationFilter.stub(_res);

  CopyWith$Input$UuidNullableFilter<TRes> get bookRawId =>
      CopyWith$Input$UuidNullableFilter.stub(_res);

  CopyWith$Input$IntNullableFilter<TRes> get completionTokens =>
      CopyWith$Input$IntNullableFilter.stub(_res);

  CopyWith$Input$StringNullableListFilter<TRes> get content =>
      CopyWith$Input$StringNullableListFilter.stub(_res);

  CopyWith$Input$DateTimeFilter<TRes> get createdAt =>
      CopyWith$Input$DateTimeFilter.stub(_res);

  CopyWith$Input$BoolFilter<TRes> get isRaw =>
      CopyWith$Input$BoolFilter.stub(_res);

  CopyWith$Input$StringNullableFilter<TRes> get model =>
      CopyWith$Input$StringNullableFilter.stub(_res);

  CopyWith$Input$IntNullableFilter<TRes> get promptTokens =>
      CopyWith$Input$IntNullableFilter.stub(_res);

  CopyWith$Input$StringNullableFilter<TRes> get raw =>
      CopyWith$Input$StringNullableFilter.stub(_res);

  CopyWith$Input$StringNullableFilter<TRes> get requestId =>
      CopyWith$Input$StringNullableFilter.stub(_res);

  CopyWith$Input$StringNullableFilter<TRes> get systemPrompt =>
      CopyWith$Input$StringNullableFilter.stub(_res);

  CopyWith$Input$IntNullableFilter<TRes> get totalTokens =>
      CopyWith$Input$IntNullableFilter.stub(_res);

  CopyWith$Input$DateTimeFilter<TRes> get updatedAt =>
      CopyWith$Input$DateTimeFilter.stub(_res);

  CopyWith$Input$StringNullableFilter<TRes> get userPrompt =>
      CopyWith$Input$StringNullableFilter.stub(_res);

  CopyWith$Input$UuidFilter<TRes> get uuid =>
      CopyWith$Input$UuidFilter.stub(_res);
}

class Input$BookRevisionWhereUniqueInput {
  factory Input$BookRevisionWhereUniqueInput({
    List<Input$BookRevisionWhereInput>? AND,
    List<Input$BookRevisionWhereInput>? NOT,
    List<Input$BookRevisionWhereInput>? OR,
    Input$BookNullableRelationFilter? bookEdited,
    String? bookEditedId,
    Input$BookNullableRelationFilter? bookRaw,
    String? bookRawId,
    Input$IntNullableFilter? completionTokens,
    Input$StringNullableListFilter? content,
    Input$DateTimeFilter? createdAt,
    Input$BoolFilter? isRaw,
    Input$StringNullableFilter? model,
    Input$IntNullableFilter? promptTokens,
    Input$StringNullableFilter? raw,
    Input$StringNullableFilter? requestId,
    Input$StringNullableFilter? systemPrompt,
    Input$IntNullableFilter? totalTokens,
    Input$DateTimeFilter? updatedAt,
    Input$StringNullableFilter? userPrompt,
    String? uuid,
  }) =>
      Input$BookRevisionWhereUniqueInput._({
        if (AND != null) r'AND': AND,
        if (NOT != null) r'NOT': NOT,
        if (OR != null) r'OR': OR,
        if (bookEdited != null) r'bookEdited': bookEdited,
        if (bookEditedId != null) r'bookEditedId': bookEditedId,
        if (bookRaw != null) r'bookRaw': bookRaw,
        if (bookRawId != null) r'bookRawId': bookRawId,
        if (completionTokens != null) r'completionTokens': completionTokens,
        if (content != null) r'content': content,
        if (createdAt != null) r'createdAt': createdAt,
        if (isRaw != null) r'isRaw': isRaw,
        if (model != null) r'model': model,
        if (promptTokens != null) r'promptTokens': promptTokens,
        if (raw != null) r'raw': raw,
        if (requestId != null) r'requestId': requestId,
        if (systemPrompt != null) r'systemPrompt': systemPrompt,
        if (totalTokens != null) r'totalTokens': totalTokens,
        if (updatedAt != null) r'updatedAt': updatedAt,
        if (userPrompt != null) r'userPrompt': userPrompt,
        if (uuid != null) r'uuid': uuid,
      });

  Input$BookRevisionWhereUniqueInput._(this._$data);

  factory Input$BookRevisionWhereUniqueInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('AND')) {
      final l$AND = data['AND'];
      result$data['AND'] = (l$AND as List<dynamic>?)
          ?.map((e) => Input$BookRevisionWhereInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('NOT')) {
      final l$NOT = data['NOT'];
      result$data['NOT'] = (l$NOT as List<dynamic>?)
          ?.map((e) => Input$BookRevisionWhereInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('OR')) {
      final l$OR = data['OR'];
      result$data['OR'] = (l$OR as List<dynamic>?)
          ?.map((e) => Input$BookRevisionWhereInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('bookEdited')) {
      final l$bookEdited = data['bookEdited'];
      result$data['bookEdited'] = l$bookEdited == null
          ? null
          : Input$BookNullableRelationFilter.fromJson(
              (l$bookEdited as Map<String, dynamic>));
    }
    if (data.containsKey('bookEditedId')) {
      final l$bookEditedId = data['bookEditedId'];
      result$data['bookEditedId'] = (l$bookEditedId as String?);
    }
    if (data.containsKey('bookRaw')) {
      final l$bookRaw = data['bookRaw'];
      result$data['bookRaw'] = l$bookRaw == null
          ? null
          : Input$BookNullableRelationFilter.fromJson(
              (l$bookRaw as Map<String, dynamic>));
    }
    if (data.containsKey('bookRawId')) {
      final l$bookRawId = data['bookRawId'];
      result$data['bookRawId'] = (l$bookRawId as String?);
    }
    if (data.containsKey('completionTokens')) {
      final l$completionTokens = data['completionTokens'];
      result$data['completionTokens'] = l$completionTokens == null
          ? null
          : Input$IntNullableFilter.fromJson(
              (l$completionTokens as Map<String, dynamic>));
    }
    if (data.containsKey('content')) {
      final l$content = data['content'];
      result$data['content'] = l$content == null
          ? null
          : Input$StringNullableListFilter.fromJson(
              (l$content as Map<String, dynamic>));
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : Input$DateTimeFilter.fromJson(
              (l$createdAt as Map<String, dynamic>));
    }
    if (data.containsKey('isRaw')) {
      final l$isRaw = data['isRaw'];
      result$data['isRaw'] = l$isRaw == null
          ? null
          : Input$BoolFilter.fromJson((l$isRaw as Map<String, dynamic>));
    }
    if (data.containsKey('model')) {
      final l$model = data['model'];
      result$data['model'] = l$model == null
          ? null
          : Input$StringNullableFilter.fromJson(
              (l$model as Map<String, dynamic>));
    }
    if (data.containsKey('promptTokens')) {
      final l$promptTokens = data['promptTokens'];
      result$data['promptTokens'] = l$promptTokens == null
          ? null
          : Input$IntNullableFilter.fromJson(
              (l$promptTokens as Map<String, dynamic>));
    }
    if (data.containsKey('raw')) {
      final l$raw = data['raw'];
      result$data['raw'] = l$raw == null
          ? null
          : Input$StringNullableFilter.fromJson(
              (l$raw as Map<String, dynamic>));
    }
    if (data.containsKey('requestId')) {
      final l$requestId = data['requestId'];
      result$data['requestId'] = l$requestId == null
          ? null
          : Input$StringNullableFilter.fromJson(
              (l$requestId as Map<String, dynamic>));
    }
    if (data.containsKey('systemPrompt')) {
      final l$systemPrompt = data['systemPrompt'];
      result$data['systemPrompt'] = l$systemPrompt == null
          ? null
          : Input$StringNullableFilter.fromJson(
              (l$systemPrompt as Map<String, dynamic>));
    }
    if (data.containsKey('totalTokens')) {
      final l$totalTokens = data['totalTokens'];
      result$data['totalTokens'] = l$totalTokens == null
          ? null
          : Input$IntNullableFilter.fromJson(
              (l$totalTokens as Map<String, dynamic>));
    }
    if (data.containsKey('updatedAt')) {
      final l$updatedAt = data['updatedAt'];
      result$data['updatedAt'] = l$updatedAt == null
          ? null
          : Input$DateTimeFilter.fromJson(
              (l$updatedAt as Map<String, dynamic>));
    }
    if (data.containsKey('userPrompt')) {
      final l$userPrompt = data['userPrompt'];
      result$data['userPrompt'] = l$userPrompt == null
          ? null
          : Input$StringNullableFilter.fromJson(
              (l$userPrompt as Map<String, dynamic>));
    }
    if (data.containsKey('uuid')) {
      final l$uuid = data['uuid'];
      result$data['uuid'] = (l$uuid as String?);
    }
    return Input$BookRevisionWhereUniqueInput._(result$data);
  }

  Map<String, dynamic> _$data;

  List<Input$BookRevisionWhereInput>? get AND =>
      (_$data['AND'] as List<Input$BookRevisionWhereInput>?);

  List<Input$BookRevisionWhereInput>? get NOT =>
      (_$data['NOT'] as List<Input$BookRevisionWhereInput>?);

  List<Input$BookRevisionWhereInput>? get OR =>
      (_$data['OR'] as List<Input$BookRevisionWhereInput>?);

  Input$BookNullableRelationFilter? get bookEdited =>
      (_$data['bookEdited'] as Input$BookNullableRelationFilter?);

  String? get bookEditedId => (_$data['bookEditedId'] as String?);

  Input$BookNullableRelationFilter? get bookRaw =>
      (_$data['bookRaw'] as Input$BookNullableRelationFilter?);

  String? get bookRawId => (_$data['bookRawId'] as String?);

  Input$IntNullableFilter? get completionTokens =>
      (_$data['completionTokens'] as Input$IntNullableFilter?);

  Input$StringNullableListFilter? get content =>
      (_$data['content'] as Input$StringNullableListFilter?);

  Input$DateTimeFilter? get createdAt =>
      (_$data['createdAt'] as Input$DateTimeFilter?);

  Input$BoolFilter? get isRaw => (_$data['isRaw'] as Input$BoolFilter?);

  Input$StringNullableFilter? get model =>
      (_$data['model'] as Input$StringNullableFilter?);

  Input$IntNullableFilter? get promptTokens =>
      (_$data['promptTokens'] as Input$IntNullableFilter?);

  Input$StringNullableFilter? get raw =>
      (_$data['raw'] as Input$StringNullableFilter?);

  Input$StringNullableFilter? get requestId =>
      (_$data['requestId'] as Input$StringNullableFilter?);

  Input$StringNullableFilter? get systemPrompt =>
      (_$data['systemPrompt'] as Input$StringNullableFilter?);

  Input$IntNullableFilter? get totalTokens =>
      (_$data['totalTokens'] as Input$IntNullableFilter?);

  Input$DateTimeFilter? get updatedAt =>
      (_$data['updatedAt'] as Input$DateTimeFilter?);

  Input$StringNullableFilter? get userPrompt =>
      (_$data['userPrompt'] as Input$StringNullableFilter?);

  String? get uuid => (_$data['uuid'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('AND')) {
      final l$AND = AND;
      result$data['AND'] = l$AND?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('NOT')) {
      final l$NOT = NOT;
      result$data['NOT'] = l$NOT?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('OR')) {
      final l$OR = OR;
      result$data['OR'] = l$OR?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('bookEdited')) {
      final l$bookEdited = bookEdited;
      result$data['bookEdited'] = l$bookEdited?.toJson();
    }
    if (_$data.containsKey('bookEditedId')) {
      final l$bookEditedId = bookEditedId;
      result$data['bookEditedId'] = l$bookEditedId;
    }
    if (_$data.containsKey('bookRaw')) {
      final l$bookRaw = bookRaw;
      result$data['bookRaw'] = l$bookRaw?.toJson();
    }
    if (_$data.containsKey('bookRawId')) {
      final l$bookRawId = bookRawId;
      result$data['bookRawId'] = l$bookRawId;
    }
    if (_$data.containsKey('completionTokens')) {
      final l$completionTokens = completionTokens;
      result$data['completionTokens'] = l$completionTokens?.toJson();
    }
    if (_$data.containsKey('content')) {
      final l$content = content;
      result$data['content'] = l$content?.toJson();
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toJson();
    }
    if (_$data.containsKey('isRaw')) {
      final l$isRaw = isRaw;
      result$data['isRaw'] = l$isRaw?.toJson();
    }
    if (_$data.containsKey('model')) {
      final l$model = model;
      result$data['model'] = l$model?.toJson();
    }
    if (_$data.containsKey('promptTokens')) {
      final l$promptTokens = promptTokens;
      result$data['promptTokens'] = l$promptTokens?.toJson();
    }
    if (_$data.containsKey('raw')) {
      final l$raw = raw;
      result$data['raw'] = l$raw?.toJson();
    }
    if (_$data.containsKey('requestId')) {
      final l$requestId = requestId;
      result$data['requestId'] = l$requestId?.toJson();
    }
    if (_$data.containsKey('systemPrompt')) {
      final l$systemPrompt = systemPrompt;
      result$data['systemPrompt'] = l$systemPrompt?.toJson();
    }
    if (_$data.containsKey('totalTokens')) {
      final l$totalTokens = totalTokens;
      result$data['totalTokens'] = l$totalTokens?.toJson();
    }
    if (_$data.containsKey('updatedAt')) {
      final l$updatedAt = updatedAt;
      result$data['updatedAt'] = l$updatedAt?.toJson();
    }
    if (_$data.containsKey('userPrompt')) {
      final l$userPrompt = userPrompt;
      result$data['userPrompt'] = l$userPrompt?.toJson();
    }
    if (_$data.containsKey('uuid')) {
      final l$uuid = uuid;
      result$data['uuid'] = l$uuid;
    }
    return result$data;
  }

  CopyWith$Input$BookRevisionWhereUniqueInput<
          Input$BookRevisionWhereUniqueInput>
      get copyWith => CopyWith$Input$BookRevisionWhereUniqueInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$BookRevisionWhereUniqueInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$AND = AND;
    final lOther$AND = other.AND;
    if (_$data.containsKey('AND') != other._$data.containsKey('AND')) {
      return false;
    }
    if (l$AND != null && lOther$AND != null) {
      if (l$AND.length != lOther$AND.length) {
        return false;
      }
      for (int i = 0; i < l$AND.length; i++) {
        final l$AND$entry = l$AND[i];
        final lOther$AND$entry = lOther$AND[i];
        if (l$AND$entry != lOther$AND$entry) {
          return false;
        }
      }
    } else if (l$AND != lOther$AND) {
      return false;
    }
    final l$NOT = NOT;
    final lOther$NOT = other.NOT;
    if (_$data.containsKey('NOT') != other._$data.containsKey('NOT')) {
      return false;
    }
    if (l$NOT != null && lOther$NOT != null) {
      if (l$NOT.length != lOther$NOT.length) {
        return false;
      }
      for (int i = 0; i < l$NOT.length; i++) {
        final l$NOT$entry = l$NOT[i];
        final lOther$NOT$entry = lOther$NOT[i];
        if (l$NOT$entry != lOther$NOT$entry) {
          return false;
        }
      }
    } else if (l$NOT != lOther$NOT) {
      return false;
    }
    final l$OR = OR;
    final lOther$OR = other.OR;
    if (_$data.containsKey('OR') != other._$data.containsKey('OR')) {
      return false;
    }
    if (l$OR != null && lOther$OR != null) {
      if (l$OR.length != lOther$OR.length) {
        return false;
      }
      for (int i = 0; i < l$OR.length; i++) {
        final l$OR$entry = l$OR[i];
        final lOther$OR$entry = lOther$OR[i];
        if (l$OR$entry != lOther$OR$entry) {
          return false;
        }
      }
    } else if (l$OR != lOther$OR) {
      return false;
    }
    final l$bookEdited = bookEdited;
    final lOther$bookEdited = other.bookEdited;
    if (_$data.containsKey('bookEdited') !=
        other._$data.containsKey('bookEdited')) {
      return false;
    }
    if (l$bookEdited != lOther$bookEdited) {
      return false;
    }
    final l$bookEditedId = bookEditedId;
    final lOther$bookEditedId = other.bookEditedId;
    if (_$data.containsKey('bookEditedId') !=
        other._$data.containsKey('bookEditedId')) {
      return false;
    }
    if (l$bookEditedId != lOther$bookEditedId) {
      return false;
    }
    final l$bookRaw = bookRaw;
    final lOther$bookRaw = other.bookRaw;
    if (_$data.containsKey('bookRaw') != other._$data.containsKey('bookRaw')) {
      return false;
    }
    if (l$bookRaw != lOther$bookRaw) {
      return false;
    }
    final l$bookRawId = bookRawId;
    final lOther$bookRawId = other.bookRawId;
    if (_$data.containsKey('bookRawId') !=
        other._$data.containsKey('bookRawId')) {
      return false;
    }
    if (l$bookRawId != lOther$bookRawId) {
      return false;
    }
    final l$completionTokens = completionTokens;
    final lOther$completionTokens = other.completionTokens;
    if (_$data.containsKey('completionTokens') !=
        other._$data.containsKey('completionTokens')) {
      return false;
    }
    if (l$completionTokens != lOther$completionTokens) {
      return false;
    }
    final l$content = content;
    final lOther$content = other.content;
    if (_$data.containsKey('content') != other._$data.containsKey('content')) {
      return false;
    }
    if (l$content != lOther$content) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$isRaw = isRaw;
    final lOther$isRaw = other.isRaw;
    if (_$data.containsKey('isRaw') != other._$data.containsKey('isRaw')) {
      return false;
    }
    if (l$isRaw != lOther$isRaw) {
      return false;
    }
    final l$model = model;
    final lOther$model = other.model;
    if (_$data.containsKey('model') != other._$data.containsKey('model')) {
      return false;
    }
    if (l$model != lOther$model) {
      return false;
    }
    final l$promptTokens = promptTokens;
    final lOther$promptTokens = other.promptTokens;
    if (_$data.containsKey('promptTokens') !=
        other._$data.containsKey('promptTokens')) {
      return false;
    }
    if (l$promptTokens != lOther$promptTokens) {
      return false;
    }
    final l$raw = raw;
    final lOther$raw = other.raw;
    if (_$data.containsKey('raw') != other._$data.containsKey('raw')) {
      return false;
    }
    if (l$raw != lOther$raw) {
      return false;
    }
    final l$requestId = requestId;
    final lOther$requestId = other.requestId;
    if (_$data.containsKey('requestId') !=
        other._$data.containsKey('requestId')) {
      return false;
    }
    if (l$requestId != lOther$requestId) {
      return false;
    }
    final l$systemPrompt = systemPrompt;
    final lOther$systemPrompt = other.systemPrompt;
    if (_$data.containsKey('systemPrompt') !=
        other._$data.containsKey('systemPrompt')) {
      return false;
    }
    if (l$systemPrompt != lOther$systemPrompt) {
      return false;
    }
    final l$totalTokens = totalTokens;
    final lOther$totalTokens = other.totalTokens;
    if (_$data.containsKey('totalTokens') !=
        other._$data.containsKey('totalTokens')) {
      return false;
    }
    if (l$totalTokens != lOther$totalTokens) {
      return false;
    }
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (_$data.containsKey('updatedAt') !=
        other._$data.containsKey('updatedAt')) {
      return false;
    }
    if (l$updatedAt != lOther$updatedAt) {
      return false;
    }
    final l$userPrompt = userPrompt;
    final lOther$userPrompt = other.userPrompt;
    if (_$data.containsKey('userPrompt') !=
        other._$data.containsKey('userPrompt')) {
      return false;
    }
    if (l$userPrompt != lOther$userPrompt) {
      return false;
    }
    final l$uuid = uuid;
    final lOther$uuid = other.uuid;
    if (_$data.containsKey('uuid') != other._$data.containsKey('uuid')) {
      return false;
    }
    if (l$uuid != lOther$uuid) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$AND = AND;
    final l$NOT = NOT;
    final l$OR = OR;
    final l$bookEdited = bookEdited;
    final l$bookEditedId = bookEditedId;
    final l$bookRaw = bookRaw;
    final l$bookRawId = bookRawId;
    final l$completionTokens = completionTokens;
    final l$content = content;
    final l$createdAt = createdAt;
    final l$isRaw = isRaw;
    final l$model = model;
    final l$promptTokens = promptTokens;
    final l$raw = raw;
    final l$requestId = requestId;
    final l$systemPrompt = systemPrompt;
    final l$totalTokens = totalTokens;
    final l$updatedAt = updatedAt;
    final l$userPrompt = userPrompt;
    final l$uuid = uuid;
    return Object.hashAll([
      _$data.containsKey('AND')
          ? l$AND == null
              ? null
              : Object.hashAll(l$AND.map((v) => v))
          : const {},
      _$data.containsKey('NOT')
          ? l$NOT == null
              ? null
              : Object.hashAll(l$NOT.map((v) => v))
          : const {},
      _$data.containsKey('OR')
          ? l$OR == null
              ? null
              : Object.hashAll(l$OR.map((v) => v))
          : const {},
      _$data.containsKey('bookEdited') ? l$bookEdited : const {},
      _$data.containsKey('bookEditedId') ? l$bookEditedId : const {},
      _$data.containsKey('bookRaw') ? l$bookRaw : const {},
      _$data.containsKey('bookRawId') ? l$bookRawId : const {},
      _$data.containsKey('completionTokens') ? l$completionTokens : const {},
      _$data.containsKey('content') ? l$content : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('isRaw') ? l$isRaw : const {},
      _$data.containsKey('model') ? l$model : const {},
      _$data.containsKey('promptTokens') ? l$promptTokens : const {},
      _$data.containsKey('raw') ? l$raw : const {},
      _$data.containsKey('requestId') ? l$requestId : const {},
      _$data.containsKey('systemPrompt') ? l$systemPrompt : const {},
      _$data.containsKey('totalTokens') ? l$totalTokens : const {},
      _$data.containsKey('updatedAt') ? l$updatedAt : const {},
      _$data.containsKey('userPrompt') ? l$userPrompt : const {},
      _$data.containsKey('uuid') ? l$uuid : const {},
    ]);
  }
}

abstract class CopyWith$Input$BookRevisionWhereUniqueInput<TRes> {
  factory CopyWith$Input$BookRevisionWhereUniqueInput(
    Input$BookRevisionWhereUniqueInput instance,
    TRes Function(Input$BookRevisionWhereUniqueInput) then,
  ) = _CopyWithImpl$Input$BookRevisionWhereUniqueInput;

  factory CopyWith$Input$BookRevisionWhereUniqueInput.stub(TRes res) =
      _CopyWithStubImpl$Input$BookRevisionWhereUniqueInput;

  TRes call({
    List<Input$BookRevisionWhereInput>? AND,
    List<Input$BookRevisionWhereInput>? NOT,
    List<Input$BookRevisionWhereInput>? OR,
    Input$BookNullableRelationFilter? bookEdited,
    String? bookEditedId,
    Input$BookNullableRelationFilter? bookRaw,
    String? bookRawId,
    Input$IntNullableFilter? completionTokens,
    Input$StringNullableListFilter? content,
    Input$DateTimeFilter? createdAt,
    Input$BoolFilter? isRaw,
    Input$StringNullableFilter? model,
    Input$IntNullableFilter? promptTokens,
    Input$StringNullableFilter? raw,
    Input$StringNullableFilter? requestId,
    Input$StringNullableFilter? systemPrompt,
    Input$IntNullableFilter? totalTokens,
    Input$DateTimeFilter? updatedAt,
    Input$StringNullableFilter? userPrompt,
    String? uuid,
  });
  TRes AND(
      Iterable<Input$BookRevisionWhereInput>? Function(
              Iterable<
                  CopyWith$Input$BookRevisionWhereInput<
                      Input$BookRevisionWhereInput>>?)
          _fn);
  TRes NOT(
      Iterable<Input$BookRevisionWhereInput>? Function(
              Iterable<
                  CopyWith$Input$BookRevisionWhereInput<
                      Input$BookRevisionWhereInput>>?)
          _fn);
  TRes OR(
      Iterable<Input$BookRevisionWhereInput>? Function(
              Iterable<
                  CopyWith$Input$BookRevisionWhereInput<
                      Input$BookRevisionWhereInput>>?)
          _fn);
  CopyWith$Input$BookNullableRelationFilter<TRes> get bookEdited;
  CopyWith$Input$BookNullableRelationFilter<TRes> get bookRaw;
  CopyWith$Input$IntNullableFilter<TRes> get completionTokens;
  CopyWith$Input$StringNullableListFilter<TRes> get content;
  CopyWith$Input$DateTimeFilter<TRes> get createdAt;
  CopyWith$Input$BoolFilter<TRes> get isRaw;
  CopyWith$Input$StringNullableFilter<TRes> get model;
  CopyWith$Input$IntNullableFilter<TRes> get promptTokens;
  CopyWith$Input$StringNullableFilter<TRes> get raw;
  CopyWith$Input$StringNullableFilter<TRes> get requestId;
  CopyWith$Input$StringNullableFilter<TRes> get systemPrompt;
  CopyWith$Input$IntNullableFilter<TRes> get totalTokens;
  CopyWith$Input$DateTimeFilter<TRes> get updatedAt;
  CopyWith$Input$StringNullableFilter<TRes> get userPrompt;
}

class _CopyWithImpl$Input$BookRevisionWhereUniqueInput<TRes>
    implements CopyWith$Input$BookRevisionWhereUniqueInput<TRes> {
  _CopyWithImpl$Input$BookRevisionWhereUniqueInput(
    this._instance,
    this._then,
  );

  final Input$BookRevisionWhereUniqueInput _instance;

  final TRes Function(Input$BookRevisionWhereUniqueInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? AND = _undefined,
    Object? NOT = _undefined,
    Object? OR = _undefined,
    Object? bookEdited = _undefined,
    Object? bookEditedId = _undefined,
    Object? bookRaw = _undefined,
    Object? bookRawId = _undefined,
    Object? completionTokens = _undefined,
    Object? content = _undefined,
    Object? createdAt = _undefined,
    Object? isRaw = _undefined,
    Object? model = _undefined,
    Object? promptTokens = _undefined,
    Object? raw = _undefined,
    Object? requestId = _undefined,
    Object? systemPrompt = _undefined,
    Object? totalTokens = _undefined,
    Object? updatedAt = _undefined,
    Object? userPrompt = _undefined,
    Object? uuid = _undefined,
  }) =>
      _then(Input$BookRevisionWhereUniqueInput._({
        ..._instance._$data,
        if (AND != _undefined)
          'AND': (AND as List<Input$BookRevisionWhereInput>?),
        if (NOT != _undefined)
          'NOT': (NOT as List<Input$BookRevisionWhereInput>?),
        if (OR != _undefined) 'OR': (OR as List<Input$BookRevisionWhereInput>?),
        if (bookEdited != _undefined)
          'bookEdited': (bookEdited as Input$BookNullableRelationFilter?),
        if (bookEditedId != _undefined)
          'bookEditedId': (bookEditedId as String?),
        if (bookRaw != _undefined)
          'bookRaw': (bookRaw as Input$BookNullableRelationFilter?),
        if (bookRawId != _undefined) 'bookRawId': (bookRawId as String?),
        if (completionTokens != _undefined)
          'completionTokens': (completionTokens as Input$IntNullableFilter?),
        if (content != _undefined)
          'content': (content as Input$StringNullableListFilter?),
        if (createdAt != _undefined)
          'createdAt': (createdAt as Input$DateTimeFilter?),
        if (isRaw != _undefined) 'isRaw': (isRaw as Input$BoolFilter?),
        if (model != _undefined)
          'model': (model as Input$StringNullableFilter?),
        if (promptTokens != _undefined)
          'promptTokens': (promptTokens as Input$IntNullableFilter?),
        if (raw != _undefined) 'raw': (raw as Input$StringNullableFilter?),
        if (requestId != _undefined)
          'requestId': (requestId as Input$StringNullableFilter?),
        if (systemPrompt != _undefined)
          'systemPrompt': (systemPrompt as Input$StringNullableFilter?),
        if (totalTokens != _undefined)
          'totalTokens': (totalTokens as Input$IntNullableFilter?),
        if (updatedAt != _undefined)
          'updatedAt': (updatedAt as Input$DateTimeFilter?),
        if (userPrompt != _undefined)
          'userPrompt': (userPrompt as Input$StringNullableFilter?),
        if (uuid != _undefined) 'uuid': (uuid as String?),
      }));

  TRes AND(
          Iterable<Input$BookRevisionWhereInput>? Function(
                  Iterable<
                      CopyWith$Input$BookRevisionWhereInput<
                          Input$BookRevisionWhereInput>>?)
              _fn) =>
      call(
          AND: _fn(
              _instance.AND?.map((e) => CopyWith$Input$BookRevisionWhereInput(
                    e,
                    (i) => i,
                  )))?.toList());

  TRes NOT(
          Iterable<Input$BookRevisionWhereInput>? Function(
                  Iterable<
                      CopyWith$Input$BookRevisionWhereInput<
                          Input$BookRevisionWhereInput>>?)
              _fn) =>
      call(
          NOT: _fn(
              _instance.NOT?.map((e) => CopyWith$Input$BookRevisionWhereInput(
                    e,
                    (i) => i,
                  )))?.toList());

  TRes OR(
          Iterable<Input$BookRevisionWhereInput>? Function(
                  Iterable<
                      CopyWith$Input$BookRevisionWhereInput<
                          Input$BookRevisionWhereInput>>?)
              _fn) =>
      call(
          OR: _fn(
              _instance.OR?.map((e) => CopyWith$Input$BookRevisionWhereInput(
                    e,
                    (i) => i,
                  )))?.toList());

  CopyWith$Input$BookNullableRelationFilter<TRes> get bookEdited {
    final local$bookEdited = _instance.bookEdited;
    return local$bookEdited == null
        ? CopyWith$Input$BookNullableRelationFilter.stub(_then(_instance))
        : CopyWith$Input$BookNullableRelationFilter(
            local$bookEdited, (e) => call(bookEdited: e));
  }

  CopyWith$Input$BookNullableRelationFilter<TRes> get bookRaw {
    final local$bookRaw = _instance.bookRaw;
    return local$bookRaw == null
        ? CopyWith$Input$BookNullableRelationFilter.stub(_then(_instance))
        : CopyWith$Input$BookNullableRelationFilter(
            local$bookRaw, (e) => call(bookRaw: e));
  }

  CopyWith$Input$IntNullableFilter<TRes> get completionTokens {
    final local$completionTokens = _instance.completionTokens;
    return local$completionTokens == null
        ? CopyWith$Input$IntNullableFilter.stub(_then(_instance))
        : CopyWith$Input$IntNullableFilter(
            local$completionTokens, (e) => call(completionTokens: e));
  }

  CopyWith$Input$StringNullableListFilter<TRes> get content {
    final local$content = _instance.content;
    return local$content == null
        ? CopyWith$Input$StringNullableListFilter.stub(_then(_instance))
        : CopyWith$Input$StringNullableListFilter(
            local$content, (e) => call(content: e));
  }

  CopyWith$Input$DateTimeFilter<TRes> get createdAt {
    final local$createdAt = _instance.createdAt;
    return local$createdAt == null
        ? CopyWith$Input$DateTimeFilter.stub(_then(_instance))
        : CopyWith$Input$DateTimeFilter(
            local$createdAt, (e) => call(createdAt: e));
  }

  CopyWith$Input$BoolFilter<TRes> get isRaw {
    final local$isRaw = _instance.isRaw;
    return local$isRaw == null
        ? CopyWith$Input$BoolFilter.stub(_then(_instance))
        : CopyWith$Input$BoolFilter(local$isRaw, (e) => call(isRaw: e));
  }

  CopyWith$Input$StringNullableFilter<TRes> get model {
    final local$model = _instance.model;
    return local$model == null
        ? CopyWith$Input$StringNullableFilter.stub(_then(_instance))
        : CopyWith$Input$StringNullableFilter(
            local$model, (e) => call(model: e));
  }

  CopyWith$Input$IntNullableFilter<TRes> get promptTokens {
    final local$promptTokens = _instance.promptTokens;
    return local$promptTokens == null
        ? CopyWith$Input$IntNullableFilter.stub(_then(_instance))
        : CopyWith$Input$IntNullableFilter(
            local$promptTokens, (e) => call(promptTokens: e));
  }

  CopyWith$Input$StringNullableFilter<TRes> get raw {
    final local$raw = _instance.raw;
    return local$raw == null
        ? CopyWith$Input$StringNullableFilter.stub(_then(_instance))
        : CopyWith$Input$StringNullableFilter(local$raw, (e) => call(raw: e));
  }

  CopyWith$Input$StringNullableFilter<TRes> get requestId {
    final local$requestId = _instance.requestId;
    return local$requestId == null
        ? CopyWith$Input$StringNullableFilter.stub(_then(_instance))
        : CopyWith$Input$StringNullableFilter(
            local$requestId, (e) => call(requestId: e));
  }

  CopyWith$Input$StringNullableFilter<TRes> get systemPrompt {
    final local$systemPrompt = _instance.systemPrompt;
    return local$systemPrompt == null
        ? CopyWith$Input$StringNullableFilter.stub(_then(_instance))
        : CopyWith$Input$StringNullableFilter(
            local$systemPrompt, (e) => call(systemPrompt: e));
  }

  CopyWith$Input$IntNullableFilter<TRes> get totalTokens {
    final local$totalTokens = _instance.totalTokens;
    return local$totalTokens == null
        ? CopyWith$Input$IntNullableFilter.stub(_then(_instance))
        : CopyWith$Input$IntNullableFilter(
            local$totalTokens, (e) => call(totalTokens: e));
  }

  CopyWith$Input$DateTimeFilter<TRes> get updatedAt {
    final local$updatedAt = _instance.updatedAt;
    return local$updatedAt == null
        ? CopyWith$Input$DateTimeFilter.stub(_then(_instance))
        : CopyWith$Input$DateTimeFilter(
            local$updatedAt, (e) => call(updatedAt: e));
  }

  CopyWith$Input$StringNullableFilter<TRes> get userPrompt {
    final local$userPrompt = _instance.userPrompt;
    return local$userPrompt == null
        ? CopyWith$Input$StringNullableFilter.stub(_then(_instance))
        : CopyWith$Input$StringNullableFilter(
            local$userPrompt, (e) => call(userPrompt: e));
  }
}

class _CopyWithStubImpl$Input$BookRevisionWhereUniqueInput<TRes>
    implements CopyWith$Input$BookRevisionWhereUniqueInput<TRes> {
  _CopyWithStubImpl$Input$BookRevisionWhereUniqueInput(this._res);

  TRes _res;

  call({
    List<Input$BookRevisionWhereInput>? AND,
    List<Input$BookRevisionWhereInput>? NOT,
    List<Input$BookRevisionWhereInput>? OR,
    Input$BookNullableRelationFilter? bookEdited,
    String? bookEditedId,
    Input$BookNullableRelationFilter? bookRaw,
    String? bookRawId,
    Input$IntNullableFilter? completionTokens,
    Input$StringNullableListFilter? content,
    Input$DateTimeFilter? createdAt,
    Input$BoolFilter? isRaw,
    Input$StringNullableFilter? model,
    Input$IntNullableFilter? promptTokens,
    Input$StringNullableFilter? raw,
    Input$StringNullableFilter? requestId,
    Input$StringNullableFilter? systemPrompt,
    Input$IntNullableFilter? totalTokens,
    Input$DateTimeFilter? updatedAt,
    Input$StringNullableFilter? userPrompt,
    String? uuid,
  }) =>
      _res;

  AND(_fn) => _res;

  NOT(_fn) => _res;

  OR(_fn) => _res;

  CopyWith$Input$BookNullableRelationFilter<TRes> get bookEdited =>
      CopyWith$Input$BookNullableRelationFilter.stub(_res);

  CopyWith$Input$BookNullableRelationFilter<TRes> get bookRaw =>
      CopyWith$Input$BookNullableRelationFilter.stub(_res);

  CopyWith$Input$IntNullableFilter<TRes> get completionTokens =>
      CopyWith$Input$IntNullableFilter.stub(_res);

  CopyWith$Input$StringNullableListFilter<TRes> get content =>
      CopyWith$Input$StringNullableListFilter.stub(_res);

  CopyWith$Input$DateTimeFilter<TRes> get createdAt =>
      CopyWith$Input$DateTimeFilter.stub(_res);

  CopyWith$Input$BoolFilter<TRes> get isRaw =>
      CopyWith$Input$BoolFilter.stub(_res);

  CopyWith$Input$StringNullableFilter<TRes> get model =>
      CopyWith$Input$StringNullableFilter.stub(_res);

  CopyWith$Input$IntNullableFilter<TRes> get promptTokens =>
      CopyWith$Input$IntNullableFilter.stub(_res);

  CopyWith$Input$StringNullableFilter<TRes> get raw =>
      CopyWith$Input$StringNullableFilter.stub(_res);

  CopyWith$Input$StringNullableFilter<TRes> get requestId =>
      CopyWith$Input$StringNullableFilter.stub(_res);

  CopyWith$Input$StringNullableFilter<TRes> get systemPrompt =>
      CopyWith$Input$StringNullableFilter.stub(_res);

  CopyWith$Input$IntNullableFilter<TRes> get totalTokens =>
      CopyWith$Input$IntNullableFilter.stub(_res);

  CopyWith$Input$DateTimeFilter<TRes> get updatedAt =>
      CopyWith$Input$DateTimeFilter.stub(_res);

  CopyWith$Input$StringNullableFilter<TRes> get userPrompt =>
      CopyWith$Input$StringNullableFilter.stub(_res);
}

class Input$BookScalarWhereWithAggregatesInput {
  factory Input$BookScalarWhereWithAggregatesInput({
    List<Input$BookScalarWhereWithAggregatesInput>? AND,
    List<Input$BookScalarWhereWithAggregatesInput>? NOT,
    List<Input$BookScalarWhereWithAggregatesInput>? OR,
    Input$DateTimeWithAggregatesFilter? createdAt,
    Input$StringWithAggregatesFilter? title,
    Input$DateTimeWithAggregatesFilter? updatedAt,
    Input$UuidWithAggregatesFilter? uuid,
  }) =>
      Input$BookScalarWhereWithAggregatesInput._({
        if (AND != null) r'AND': AND,
        if (NOT != null) r'NOT': NOT,
        if (OR != null) r'OR': OR,
        if (createdAt != null) r'createdAt': createdAt,
        if (title != null) r'title': title,
        if (updatedAt != null) r'updatedAt': updatedAt,
        if (uuid != null) r'uuid': uuid,
      });

  Input$BookScalarWhereWithAggregatesInput._(this._$data);

  factory Input$BookScalarWhereWithAggregatesInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('AND')) {
      final l$AND = data['AND'];
      result$data['AND'] = (l$AND as List<dynamic>?)
          ?.map((e) => Input$BookScalarWhereWithAggregatesInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('NOT')) {
      final l$NOT = data['NOT'];
      result$data['NOT'] = (l$NOT as List<dynamic>?)
          ?.map((e) => Input$BookScalarWhereWithAggregatesInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('OR')) {
      final l$OR = data['OR'];
      result$data['OR'] = (l$OR as List<dynamic>?)
          ?.map((e) => Input$BookScalarWhereWithAggregatesInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : Input$DateTimeWithAggregatesFilter.fromJson(
              (l$createdAt as Map<String, dynamic>));
    }
    if (data.containsKey('title')) {
      final l$title = data['title'];
      result$data['title'] = l$title == null
          ? null
          : Input$StringWithAggregatesFilter.fromJson(
              (l$title as Map<String, dynamic>));
    }
    if (data.containsKey('updatedAt')) {
      final l$updatedAt = data['updatedAt'];
      result$data['updatedAt'] = l$updatedAt == null
          ? null
          : Input$DateTimeWithAggregatesFilter.fromJson(
              (l$updatedAt as Map<String, dynamic>));
    }
    if (data.containsKey('uuid')) {
      final l$uuid = data['uuid'];
      result$data['uuid'] = l$uuid == null
          ? null
          : Input$UuidWithAggregatesFilter.fromJson(
              (l$uuid as Map<String, dynamic>));
    }
    return Input$BookScalarWhereWithAggregatesInput._(result$data);
  }

  Map<String, dynamic> _$data;

  List<Input$BookScalarWhereWithAggregatesInput>? get AND =>
      (_$data['AND'] as List<Input$BookScalarWhereWithAggregatesInput>?);

  List<Input$BookScalarWhereWithAggregatesInput>? get NOT =>
      (_$data['NOT'] as List<Input$BookScalarWhereWithAggregatesInput>?);

  List<Input$BookScalarWhereWithAggregatesInput>? get OR =>
      (_$data['OR'] as List<Input$BookScalarWhereWithAggregatesInput>?);

  Input$DateTimeWithAggregatesFilter? get createdAt =>
      (_$data['createdAt'] as Input$DateTimeWithAggregatesFilter?);

  Input$StringWithAggregatesFilter? get title =>
      (_$data['title'] as Input$StringWithAggregatesFilter?);

  Input$DateTimeWithAggregatesFilter? get updatedAt =>
      (_$data['updatedAt'] as Input$DateTimeWithAggregatesFilter?);

  Input$UuidWithAggregatesFilter? get uuid =>
      (_$data['uuid'] as Input$UuidWithAggregatesFilter?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('AND')) {
      final l$AND = AND;
      result$data['AND'] = l$AND?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('NOT')) {
      final l$NOT = NOT;
      result$data['NOT'] = l$NOT?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('OR')) {
      final l$OR = OR;
      result$data['OR'] = l$OR?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toJson();
    }
    if (_$data.containsKey('title')) {
      final l$title = title;
      result$data['title'] = l$title?.toJson();
    }
    if (_$data.containsKey('updatedAt')) {
      final l$updatedAt = updatedAt;
      result$data['updatedAt'] = l$updatedAt?.toJson();
    }
    if (_$data.containsKey('uuid')) {
      final l$uuid = uuid;
      result$data['uuid'] = l$uuid?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$BookScalarWhereWithAggregatesInput<
          Input$BookScalarWhereWithAggregatesInput>
      get copyWith => CopyWith$Input$BookScalarWhereWithAggregatesInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$BookScalarWhereWithAggregatesInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$AND = AND;
    final lOther$AND = other.AND;
    if (_$data.containsKey('AND') != other._$data.containsKey('AND')) {
      return false;
    }
    if (l$AND != null && lOther$AND != null) {
      if (l$AND.length != lOther$AND.length) {
        return false;
      }
      for (int i = 0; i < l$AND.length; i++) {
        final l$AND$entry = l$AND[i];
        final lOther$AND$entry = lOther$AND[i];
        if (l$AND$entry != lOther$AND$entry) {
          return false;
        }
      }
    } else if (l$AND != lOther$AND) {
      return false;
    }
    final l$NOT = NOT;
    final lOther$NOT = other.NOT;
    if (_$data.containsKey('NOT') != other._$data.containsKey('NOT')) {
      return false;
    }
    if (l$NOT != null && lOther$NOT != null) {
      if (l$NOT.length != lOther$NOT.length) {
        return false;
      }
      for (int i = 0; i < l$NOT.length; i++) {
        final l$NOT$entry = l$NOT[i];
        final lOther$NOT$entry = lOther$NOT[i];
        if (l$NOT$entry != lOther$NOT$entry) {
          return false;
        }
      }
    } else if (l$NOT != lOther$NOT) {
      return false;
    }
    final l$OR = OR;
    final lOther$OR = other.OR;
    if (_$data.containsKey('OR') != other._$data.containsKey('OR')) {
      return false;
    }
    if (l$OR != null && lOther$OR != null) {
      if (l$OR.length != lOther$OR.length) {
        return false;
      }
      for (int i = 0; i < l$OR.length; i++) {
        final l$OR$entry = l$OR[i];
        final lOther$OR$entry = lOther$OR[i];
        if (l$OR$entry != lOther$OR$entry) {
          return false;
        }
      }
    } else if (l$OR != lOther$OR) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$title = title;
    final lOther$title = other.title;
    if (_$data.containsKey('title') != other._$data.containsKey('title')) {
      return false;
    }
    if (l$title != lOther$title) {
      return false;
    }
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (_$data.containsKey('updatedAt') !=
        other._$data.containsKey('updatedAt')) {
      return false;
    }
    if (l$updatedAt != lOther$updatedAt) {
      return false;
    }
    final l$uuid = uuid;
    final lOther$uuid = other.uuid;
    if (_$data.containsKey('uuid') != other._$data.containsKey('uuid')) {
      return false;
    }
    if (l$uuid != lOther$uuid) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$AND = AND;
    final l$NOT = NOT;
    final l$OR = OR;
    final l$createdAt = createdAt;
    final l$title = title;
    final l$updatedAt = updatedAt;
    final l$uuid = uuid;
    return Object.hashAll([
      _$data.containsKey('AND')
          ? l$AND == null
              ? null
              : Object.hashAll(l$AND.map((v) => v))
          : const {},
      _$data.containsKey('NOT')
          ? l$NOT == null
              ? null
              : Object.hashAll(l$NOT.map((v) => v))
          : const {},
      _$data.containsKey('OR')
          ? l$OR == null
              ? null
              : Object.hashAll(l$OR.map((v) => v))
          : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('title') ? l$title : const {},
      _$data.containsKey('updatedAt') ? l$updatedAt : const {},
      _$data.containsKey('uuid') ? l$uuid : const {},
    ]);
  }
}

abstract class CopyWith$Input$BookScalarWhereWithAggregatesInput<TRes> {
  factory CopyWith$Input$BookScalarWhereWithAggregatesInput(
    Input$BookScalarWhereWithAggregatesInput instance,
    TRes Function(Input$BookScalarWhereWithAggregatesInput) then,
  ) = _CopyWithImpl$Input$BookScalarWhereWithAggregatesInput;

  factory CopyWith$Input$BookScalarWhereWithAggregatesInput.stub(TRes res) =
      _CopyWithStubImpl$Input$BookScalarWhereWithAggregatesInput;

  TRes call({
    List<Input$BookScalarWhereWithAggregatesInput>? AND,
    List<Input$BookScalarWhereWithAggregatesInput>? NOT,
    List<Input$BookScalarWhereWithAggregatesInput>? OR,
    Input$DateTimeWithAggregatesFilter? createdAt,
    Input$StringWithAggregatesFilter? title,
    Input$DateTimeWithAggregatesFilter? updatedAt,
    Input$UuidWithAggregatesFilter? uuid,
  });
  TRes AND(
      Iterable<Input$BookScalarWhereWithAggregatesInput>? Function(
              Iterable<
                  CopyWith$Input$BookScalarWhereWithAggregatesInput<
                      Input$BookScalarWhereWithAggregatesInput>>?)
          _fn);
  TRes NOT(
      Iterable<Input$BookScalarWhereWithAggregatesInput>? Function(
              Iterable<
                  CopyWith$Input$BookScalarWhereWithAggregatesInput<
                      Input$BookScalarWhereWithAggregatesInput>>?)
          _fn);
  TRes OR(
      Iterable<Input$BookScalarWhereWithAggregatesInput>? Function(
              Iterable<
                  CopyWith$Input$BookScalarWhereWithAggregatesInput<
                      Input$BookScalarWhereWithAggregatesInput>>?)
          _fn);
  CopyWith$Input$DateTimeWithAggregatesFilter<TRes> get createdAt;
  CopyWith$Input$StringWithAggregatesFilter<TRes> get title;
  CopyWith$Input$DateTimeWithAggregatesFilter<TRes> get updatedAt;
  CopyWith$Input$UuidWithAggregatesFilter<TRes> get uuid;
}

class _CopyWithImpl$Input$BookScalarWhereWithAggregatesInput<TRes>
    implements CopyWith$Input$BookScalarWhereWithAggregatesInput<TRes> {
  _CopyWithImpl$Input$BookScalarWhereWithAggregatesInput(
    this._instance,
    this._then,
  );

  final Input$BookScalarWhereWithAggregatesInput _instance;

  final TRes Function(Input$BookScalarWhereWithAggregatesInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? AND = _undefined,
    Object? NOT = _undefined,
    Object? OR = _undefined,
    Object? createdAt = _undefined,
    Object? title = _undefined,
    Object? updatedAt = _undefined,
    Object? uuid = _undefined,
  }) =>
      _then(Input$BookScalarWhereWithAggregatesInput._({
        ..._instance._$data,
        if (AND != _undefined)
          'AND': (AND as List<Input$BookScalarWhereWithAggregatesInput>?),
        if (NOT != _undefined)
          'NOT': (NOT as List<Input$BookScalarWhereWithAggregatesInput>?),
        if (OR != _undefined)
          'OR': (OR as List<Input$BookScalarWhereWithAggregatesInput>?),
        if (createdAt != _undefined)
          'createdAt': (createdAt as Input$DateTimeWithAggregatesFilter?),
        if (title != _undefined)
          'title': (title as Input$StringWithAggregatesFilter?),
        if (updatedAt != _undefined)
          'updatedAt': (updatedAt as Input$DateTimeWithAggregatesFilter?),
        if (uuid != _undefined)
          'uuid': (uuid as Input$UuidWithAggregatesFilter?),
      }));

  TRes AND(
          Iterable<Input$BookScalarWhereWithAggregatesInput>? Function(
                  Iterable<
                      CopyWith$Input$BookScalarWhereWithAggregatesInput<
                          Input$BookScalarWhereWithAggregatesInput>>?)
              _fn) =>
      call(
          AND: _fn(_instance.AND
              ?.map((e) => CopyWith$Input$BookScalarWhereWithAggregatesInput(
                    e,
                    (i) => i,
                  )))?.toList());

  TRes NOT(
          Iterable<Input$BookScalarWhereWithAggregatesInput>? Function(
                  Iterable<
                      CopyWith$Input$BookScalarWhereWithAggregatesInput<
                          Input$BookScalarWhereWithAggregatesInput>>?)
              _fn) =>
      call(
          NOT: _fn(_instance.NOT
              ?.map((e) => CopyWith$Input$BookScalarWhereWithAggregatesInput(
                    e,
                    (i) => i,
                  )))?.toList());

  TRes OR(
          Iterable<Input$BookScalarWhereWithAggregatesInput>? Function(
                  Iterable<
                      CopyWith$Input$BookScalarWhereWithAggregatesInput<
                          Input$BookScalarWhereWithAggregatesInput>>?)
              _fn) =>
      call(
          OR: _fn(_instance.OR
              ?.map((e) => CopyWith$Input$BookScalarWhereWithAggregatesInput(
                    e,
                    (i) => i,
                  )))?.toList());

  CopyWith$Input$DateTimeWithAggregatesFilter<TRes> get createdAt {
    final local$createdAt = _instance.createdAt;
    return local$createdAt == null
        ? CopyWith$Input$DateTimeWithAggregatesFilter.stub(_then(_instance))
        : CopyWith$Input$DateTimeWithAggregatesFilter(
            local$createdAt, (e) => call(createdAt: e));
  }

  CopyWith$Input$StringWithAggregatesFilter<TRes> get title {
    final local$title = _instance.title;
    return local$title == null
        ? CopyWith$Input$StringWithAggregatesFilter.stub(_then(_instance))
        : CopyWith$Input$StringWithAggregatesFilter(
            local$title, (e) => call(title: e));
  }

  CopyWith$Input$DateTimeWithAggregatesFilter<TRes> get updatedAt {
    final local$updatedAt = _instance.updatedAt;
    return local$updatedAt == null
        ? CopyWith$Input$DateTimeWithAggregatesFilter.stub(_then(_instance))
        : CopyWith$Input$DateTimeWithAggregatesFilter(
            local$updatedAt, (e) => call(updatedAt: e));
  }

  CopyWith$Input$UuidWithAggregatesFilter<TRes> get uuid {
    final local$uuid = _instance.uuid;
    return local$uuid == null
        ? CopyWith$Input$UuidWithAggregatesFilter.stub(_then(_instance))
        : CopyWith$Input$UuidWithAggregatesFilter(
            local$uuid, (e) => call(uuid: e));
  }
}

class _CopyWithStubImpl$Input$BookScalarWhereWithAggregatesInput<TRes>
    implements CopyWith$Input$BookScalarWhereWithAggregatesInput<TRes> {
  _CopyWithStubImpl$Input$BookScalarWhereWithAggregatesInput(this._res);

  TRes _res;

  call({
    List<Input$BookScalarWhereWithAggregatesInput>? AND,
    List<Input$BookScalarWhereWithAggregatesInput>? NOT,
    List<Input$BookScalarWhereWithAggregatesInput>? OR,
    Input$DateTimeWithAggregatesFilter? createdAt,
    Input$StringWithAggregatesFilter? title,
    Input$DateTimeWithAggregatesFilter? updatedAt,
    Input$UuidWithAggregatesFilter? uuid,
  }) =>
      _res;

  AND(_fn) => _res;

  NOT(_fn) => _res;

  OR(_fn) => _res;

  CopyWith$Input$DateTimeWithAggregatesFilter<TRes> get createdAt =>
      CopyWith$Input$DateTimeWithAggregatesFilter.stub(_res);

  CopyWith$Input$StringWithAggregatesFilter<TRes> get title =>
      CopyWith$Input$StringWithAggregatesFilter.stub(_res);

  CopyWith$Input$DateTimeWithAggregatesFilter<TRes> get updatedAt =>
      CopyWith$Input$DateTimeWithAggregatesFilter.stub(_res);

  CopyWith$Input$UuidWithAggregatesFilter<TRes> get uuid =>
      CopyWith$Input$UuidWithAggregatesFilter.stub(_res);
}

class Input$BookUpdateInput {
  factory Input$BookUpdateInput({
    Input$BookRevisionUpdateOneWithoutBookEditedNestedInput? bookEdited,
    Input$BookRevisionUpdateOneWithoutBookRawNestedInput? bookRaw,
    Input$DateTimeFieldUpdateOperationsInput? createdAt,
    Input$StringFieldUpdateOperationsInput? title,
    Input$DateTimeFieldUpdateOperationsInput? updatedAt,
    Input$StringFieldUpdateOperationsInput? uuid,
  }) =>
      Input$BookUpdateInput._({
        if (bookEdited != null) r'bookEdited': bookEdited,
        if (bookRaw != null) r'bookRaw': bookRaw,
        if (createdAt != null) r'createdAt': createdAt,
        if (title != null) r'title': title,
        if (updatedAt != null) r'updatedAt': updatedAt,
        if (uuid != null) r'uuid': uuid,
      });

  Input$BookUpdateInput._(this._$data);

  factory Input$BookUpdateInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('bookEdited')) {
      final l$bookEdited = data['bookEdited'];
      result$data['bookEdited'] = l$bookEdited == null
          ? null
          : Input$BookRevisionUpdateOneWithoutBookEditedNestedInput.fromJson(
              (l$bookEdited as Map<String, dynamic>));
    }
    if (data.containsKey('bookRaw')) {
      final l$bookRaw = data['bookRaw'];
      result$data['bookRaw'] = l$bookRaw == null
          ? null
          : Input$BookRevisionUpdateOneWithoutBookRawNestedInput.fromJson(
              (l$bookRaw as Map<String, dynamic>));
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : Input$DateTimeFieldUpdateOperationsInput.fromJson(
              (l$createdAt as Map<String, dynamic>));
    }
    if (data.containsKey('title')) {
      final l$title = data['title'];
      result$data['title'] = l$title == null
          ? null
          : Input$StringFieldUpdateOperationsInput.fromJson(
              (l$title as Map<String, dynamic>));
    }
    if (data.containsKey('updatedAt')) {
      final l$updatedAt = data['updatedAt'];
      result$data['updatedAt'] = l$updatedAt == null
          ? null
          : Input$DateTimeFieldUpdateOperationsInput.fromJson(
              (l$updatedAt as Map<String, dynamic>));
    }
    if (data.containsKey('uuid')) {
      final l$uuid = data['uuid'];
      result$data['uuid'] = l$uuid == null
          ? null
          : Input$StringFieldUpdateOperationsInput.fromJson(
              (l$uuid as Map<String, dynamic>));
    }
    return Input$BookUpdateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$BookRevisionUpdateOneWithoutBookEditedNestedInput? get bookEdited =>
      (_$data['bookEdited']
          as Input$BookRevisionUpdateOneWithoutBookEditedNestedInput?);

  Input$BookRevisionUpdateOneWithoutBookRawNestedInput? get bookRaw =>
      (_$data['bookRaw']
          as Input$BookRevisionUpdateOneWithoutBookRawNestedInput?);

  Input$DateTimeFieldUpdateOperationsInput? get createdAt =>
      (_$data['createdAt'] as Input$DateTimeFieldUpdateOperationsInput?);

  Input$StringFieldUpdateOperationsInput? get title =>
      (_$data['title'] as Input$StringFieldUpdateOperationsInput?);

  Input$DateTimeFieldUpdateOperationsInput? get updatedAt =>
      (_$data['updatedAt'] as Input$DateTimeFieldUpdateOperationsInput?);

  Input$StringFieldUpdateOperationsInput? get uuid =>
      (_$data['uuid'] as Input$StringFieldUpdateOperationsInput?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('bookEdited')) {
      final l$bookEdited = bookEdited;
      result$data['bookEdited'] = l$bookEdited?.toJson();
    }
    if (_$data.containsKey('bookRaw')) {
      final l$bookRaw = bookRaw;
      result$data['bookRaw'] = l$bookRaw?.toJson();
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toJson();
    }
    if (_$data.containsKey('title')) {
      final l$title = title;
      result$data['title'] = l$title?.toJson();
    }
    if (_$data.containsKey('updatedAt')) {
      final l$updatedAt = updatedAt;
      result$data['updatedAt'] = l$updatedAt?.toJson();
    }
    if (_$data.containsKey('uuid')) {
      final l$uuid = uuid;
      result$data['uuid'] = l$uuid?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$BookUpdateInput<Input$BookUpdateInput> get copyWith =>
      CopyWith$Input$BookUpdateInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$BookUpdateInput) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$bookEdited = bookEdited;
    final lOther$bookEdited = other.bookEdited;
    if (_$data.containsKey('bookEdited') !=
        other._$data.containsKey('bookEdited')) {
      return false;
    }
    if (l$bookEdited != lOther$bookEdited) {
      return false;
    }
    final l$bookRaw = bookRaw;
    final lOther$bookRaw = other.bookRaw;
    if (_$data.containsKey('bookRaw') != other._$data.containsKey('bookRaw')) {
      return false;
    }
    if (l$bookRaw != lOther$bookRaw) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$title = title;
    final lOther$title = other.title;
    if (_$data.containsKey('title') != other._$data.containsKey('title')) {
      return false;
    }
    if (l$title != lOther$title) {
      return false;
    }
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (_$data.containsKey('updatedAt') !=
        other._$data.containsKey('updatedAt')) {
      return false;
    }
    if (l$updatedAt != lOther$updatedAt) {
      return false;
    }
    final l$uuid = uuid;
    final lOther$uuid = other.uuid;
    if (_$data.containsKey('uuid') != other._$data.containsKey('uuid')) {
      return false;
    }
    if (l$uuid != lOther$uuid) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$bookEdited = bookEdited;
    final l$bookRaw = bookRaw;
    final l$createdAt = createdAt;
    final l$title = title;
    final l$updatedAt = updatedAt;
    final l$uuid = uuid;
    return Object.hashAll([
      _$data.containsKey('bookEdited') ? l$bookEdited : const {},
      _$data.containsKey('bookRaw') ? l$bookRaw : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('title') ? l$title : const {},
      _$data.containsKey('updatedAt') ? l$updatedAt : const {},
      _$data.containsKey('uuid') ? l$uuid : const {},
    ]);
  }
}

abstract class CopyWith$Input$BookUpdateInput<TRes> {
  factory CopyWith$Input$BookUpdateInput(
    Input$BookUpdateInput instance,
    TRes Function(Input$BookUpdateInput) then,
  ) = _CopyWithImpl$Input$BookUpdateInput;

  factory CopyWith$Input$BookUpdateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$BookUpdateInput;

  TRes call({
    Input$BookRevisionUpdateOneWithoutBookEditedNestedInput? bookEdited,
    Input$BookRevisionUpdateOneWithoutBookRawNestedInput? bookRaw,
    Input$DateTimeFieldUpdateOperationsInput? createdAt,
    Input$StringFieldUpdateOperationsInput? title,
    Input$DateTimeFieldUpdateOperationsInput? updatedAt,
    Input$StringFieldUpdateOperationsInput? uuid,
  });
  CopyWith$Input$BookRevisionUpdateOneWithoutBookEditedNestedInput<TRes>
      get bookEdited;
  CopyWith$Input$BookRevisionUpdateOneWithoutBookRawNestedInput<TRes>
      get bookRaw;
  CopyWith$Input$DateTimeFieldUpdateOperationsInput<TRes> get createdAt;
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get title;
  CopyWith$Input$DateTimeFieldUpdateOperationsInput<TRes> get updatedAt;
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get uuid;
}

class _CopyWithImpl$Input$BookUpdateInput<TRes>
    implements CopyWith$Input$BookUpdateInput<TRes> {
  _CopyWithImpl$Input$BookUpdateInput(
    this._instance,
    this._then,
  );

  final Input$BookUpdateInput _instance;

  final TRes Function(Input$BookUpdateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? bookEdited = _undefined,
    Object? bookRaw = _undefined,
    Object? createdAt = _undefined,
    Object? title = _undefined,
    Object? updatedAt = _undefined,
    Object? uuid = _undefined,
  }) =>
      _then(Input$BookUpdateInput._({
        ..._instance._$data,
        if (bookEdited != _undefined)
          'bookEdited': (bookEdited
              as Input$BookRevisionUpdateOneWithoutBookEditedNestedInput?),
        if (bookRaw != _undefined)
          'bookRaw': (bookRaw
              as Input$BookRevisionUpdateOneWithoutBookRawNestedInput?),
        if (createdAt != _undefined)
          'createdAt': (createdAt as Input$DateTimeFieldUpdateOperationsInput?),
        if (title != _undefined)
          'title': (title as Input$StringFieldUpdateOperationsInput?),
        if (updatedAt != _undefined)
          'updatedAt': (updatedAt as Input$DateTimeFieldUpdateOperationsInput?),
        if (uuid != _undefined)
          'uuid': (uuid as Input$StringFieldUpdateOperationsInput?),
      }));

  CopyWith$Input$BookRevisionUpdateOneWithoutBookEditedNestedInput<TRes>
      get bookEdited {
    final local$bookEdited = _instance.bookEdited;
    return local$bookEdited == null
        ? CopyWith$Input$BookRevisionUpdateOneWithoutBookEditedNestedInput.stub(
            _then(_instance))
        : CopyWith$Input$BookRevisionUpdateOneWithoutBookEditedNestedInput(
            local$bookEdited, (e) => call(bookEdited: e));
  }

  CopyWith$Input$BookRevisionUpdateOneWithoutBookRawNestedInput<TRes>
      get bookRaw {
    final local$bookRaw = _instance.bookRaw;
    return local$bookRaw == null
        ? CopyWith$Input$BookRevisionUpdateOneWithoutBookRawNestedInput.stub(
            _then(_instance))
        : CopyWith$Input$BookRevisionUpdateOneWithoutBookRawNestedInput(
            local$bookRaw, (e) => call(bookRaw: e));
  }

  CopyWith$Input$DateTimeFieldUpdateOperationsInput<TRes> get createdAt {
    final local$createdAt = _instance.createdAt;
    return local$createdAt == null
        ? CopyWith$Input$DateTimeFieldUpdateOperationsInput.stub(
            _then(_instance))
        : CopyWith$Input$DateTimeFieldUpdateOperationsInput(
            local$createdAt, (e) => call(createdAt: e));
  }

  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get title {
    final local$title = _instance.title;
    return local$title == null
        ? CopyWith$Input$StringFieldUpdateOperationsInput.stub(_then(_instance))
        : CopyWith$Input$StringFieldUpdateOperationsInput(
            local$title, (e) => call(title: e));
  }

  CopyWith$Input$DateTimeFieldUpdateOperationsInput<TRes> get updatedAt {
    final local$updatedAt = _instance.updatedAt;
    return local$updatedAt == null
        ? CopyWith$Input$DateTimeFieldUpdateOperationsInput.stub(
            _then(_instance))
        : CopyWith$Input$DateTimeFieldUpdateOperationsInput(
            local$updatedAt, (e) => call(updatedAt: e));
  }

  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get uuid {
    final local$uuid = _instance.uuid;
    return local$uuid == null
        ? CopyWith$Input$StringFieldUpdateOperationsInput.stub(_then(_instance))
        : CopyWith$Input$StringFieldUpdateOperationsInput(
            local$uuid, (e) => call(uuid: e));
  }
}

class _CopyWithStubImpl$Input$BookUpdateInput<TRes>
    implements CopyWith$Input$BookUpdateInput<TRes> {
  _CopyWithStubImpl$Input$BookUpdateInput(this._res);

  TRes _res;

  call({
    Input$BookRevisionUpdateOneWithoutBookEditedNestedInput? bookEdited,
    Input$BookRevisionUpdateOneWithoutBookRawNestedInput? bookRaw,
    Input$DateTimeFieldUpdateOperationsInput? createdAt,
    Input$StringFieldUpdateOperationsInput? title,
    Input$DateTimeFieldUpdateOperationsInput? updatedAt,
    Input$StringFieldUpdateOperationsInput? uuid,
  }) =>
      _res;

  CopyWith$Input$BookRevisionUpdateOneWithoutBookEditedNestedInput<TRes>
      get bookEdited =>
          CopyWith$Input$BookRevisionUpdateOneWithoutBookEditedNestedInput.stub(
              _res);

  CopyWith$Input$BookRevisionUpdateOneWithoutBookRawNestedInput<TRes>
      get bookRaw =>
          CopyWith$Input$BookRevisionUpdateOneWithoutBookRawNestedInput.stub(
              _res);

  CopyWith$Input$DateTimeFieldUpdateOperationsInput<TRes> get createdAt =>
      CopyWith$Input$DateTimeFieldUpdateOperationsInput.stub(_res);

  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get title =>
      CopyWith$Input$StringFieldUpdateOperationsInput.stub(_res);

  CopyWith$Input$DateTimeFieldUpdateOperationsInput<TRes> get updatedAt =>
      CopyWith$Input$DateTimeFieldUpdateOperationsInput.stub(_res);

  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get uuid =>
      CopyWith$Input$StringFieldUpdateOperationsInput.stub(_res);
}

class Input$BookUpdateManyMutationInput {
  factory Input$BookUpdateManyMutationInput({
    Input$DateTimeFieldUpdateOperationsInput? createdAt,
    Input$StringFieldUpdateOperationsInput? title,
    Input$DateTimeFieldUpdateOperationsInput? updatedAt,
    Input$StringFieldUpdateOperationsInput? uuid,
  }) =>
      Input$BookUpdateManyMutationInput._({
        if (createdAt != null) r'createdAt': createdAt,
        if (title != null) r'title': title,
        if (updatedAt != null) r'updatedAt': updatedAt,
        if (uuid != null) r'uuid': uuid,
      });

  Input$BookUpdateManyMutationInput._(this._$data);

  factory Input$BookUpdateManyMutationInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : Input$DateTimeFieldUpdateOperationsInput.fromJson(
              (l$createdAt as Map<String, dynamic>));
    }
    if (data.containsKey('title')) {
      final l$title = data['title'];
      result$data['title'] = l$title == null
          ? null
          : Input$StringFieldUpdateOperationsInput.fromJson(
              (l$title as Map<String, dynamic>));
    }
    if (data.containsKey('updatedAt')) {
      final l$updatedAt = data['updatedAt'];
      result$data['updatedAt'] = l$updatedAt == null
          ? null
          : Input$DateTimeFieldUpdateOperationsInput.fromJson(
              (l$updatedAt as Map<String, dynamic>));
    }
    if (data.containsKey('uuid')) {
      final l$uuid = data['uuid'];
      result$data['uuid'] = l$uuid == null
          ? null
          : Input$StringFieldUpdateOperationsInput.fromJson(
              (l$uuid as Map<String, dynamic>));
    }
    return Input$BookUpdateManyMutationInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$DateTimeFieldUpdateOperationsInput? get createdAt =>
      (_$data['createdAt'] as Input$DateTimeFieldUpdateOperationsInput?);

  Input$StringFieldUpdateOperationsInput? get title =>
      (_$data['title'] as Input$StringFieldUpdateOperationsInput?);

  Input$DateTimeFieldUpdateOperationsInput? get updatedAt =>
      (_$data['updatedAt'] as Input$DateTimeFieldUpdateOperationsInput?);

  Input$StringFieldUpdateOperationsInput? get uuid =>
      (_$data['uuid'] as Input$StringFieldUpdateOperationsInput?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toJson();
    }
    if (_$data.containsKey('title')) {
      final l$title = title;
      result$data['title'] = l$title?.toJson();
    }
    if (_$data.containsKey('updatedAt')) {
      final l$updatedAt = updatedAt;
      result$data['updatedAt'] = l$updatedAt?.toJson();
    }
    if (_$data.containsKey('uuid')) {
      final l$uuid = uuid;
      result$data['uuid'] = l$uuid?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$BookUpdateManyMutationInput<Input$BookUpdateManyMutationInput>
      get copyWith => CopyWith$Input$BookUpdateManyMutationInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$BookUpdateManyMutationInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$title = title;
    final lOther$title = other.title;
    if (_$data.containsKey('title') != other._$data.containsKey('title')) {
      return false;
    }
    if (l$title != lOther$title) {
      return false;
    }
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (_$data.containsKey('updatedAt') !=
        other._$data.containsKey('updatedAt')) {
      return false;
    }
    if (l$updatedAt != lOther$updatedAt) {
      return false;
    }
    final l$uuid = uuid;
    final lOther$uuid = other.uuid;
    if (_$data.containsKey('uuid') != other._$data.containsKey('uuid')) {
      return false;
    }
    if (l$uuid != lOther$uuid) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$createdAt = createdAt;
    final l$title = title;
    final l$updatedAt = updatedAt;
    final l$uuid = uuid;
    return Object.hashAll([
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('title') ? l$title : const {},
      _$data.containsKey('updatedAt') ? l$updatedAt : const {},
      _$data.containsKey('uuid') ? l$uuid : const {},
    ]);
  }
}

abstract class CopyWith$Input$BookUpdateManyMutationInput<TRes> {
  factory CopyWith$Input$BookUpdateManyMutationInput(
    Input$BookUpdateManyMutationInput instance,
    TRes Function(Input$BookUpdateManyMutationInput) then,
  ) = _CopyWithImpl$Input$BookUpdateManyMutationInput;

  factory CopyWith$Input$BookUpdateManyMutationInput.stub(TRes res) =
      _CopyWithStubImpl$Input$BookUpdateManyMutationInput;

  TRes call({
    Input$DateTimeFieldUpdateOperationsInput? createdAt,
    Input$StringFieldUpdateOperationsInput? title,
    Input$DateTimeFieldUpdateOperationsInput? updatedAt,
    Input$StringFieldUpdateOperationsInput? uuid,
  });
  CopyWith$Input$DateTimeFieldUpdateOperationsInput<TRes> get createdAt;
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get title;
  CopyWith$Input$DateTimeFieldUpdateOperationsInput<TRes> get updatedAt;
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get uuid;
}

class _CopyWithImpl$Input$BookUpdateManyMutationInput<TRes>
    implements CopyWith$Input$BookUpdateManyMutationInput<TRes> {
  _CopyWithImpl$Input$BookUpdateManyMutationInput(
    this._instance,
    this._then,
  );

  final Input$BookUpdateManyMutationInput _instance;

  final TRes Function(Input$BookUpdateManyMutationInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? createdAt = _undefined,
    Object? title = _undefined,
    Object? updatedAt = _undefined,
    Object? uuid = _undefined,
  }) =>
      _then(Input$BookUpdateManyMutationInput._({
        ..._instance._$data,
        if (createdAt != _undefined)
          'createdAt': (createdAt as Input$DateTimeFieldUpdateOperationsInput?),
        if (title != _undefined)
          'title': (title as Input$StringFieldUpdateOperationsInput?),
        if (updatedAt != _undefined)
          'updatedAt': (updatedAt as Input$DateTimeFieldUpdateOperationsInput?),
        if (uuid != _undefined)
          'uuid': (uuid as Input$StringFieldUpdateOperationsInput?),
      }));

  CopyWith$Input$DateTimeFieldUpdateOperationsInput<TRes> get createdAt {
    final local$createdAt = _instance.createdAt;
    return local$createdAt == null
        ? CopyWith$Input$DateTimeFieldUpdateOperationsInput.stub(
            _then(_instance))
        : CopyWith$Input$DateTimeFieldUpdateOperationsInput(
            local$createdAt, (e) => call(createdAt: e));
  }

  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get title {
    final local$title = _instance.title;
    return local$title == null
        ? CopyWith$Input$StringFieldUpdateOperationsInput.stub(_then(_instance))
        : CopyWith$Input$StringFieldUpdateOperationsInput(
            local$title, (e) => call(title: e));
  }

  CopyWith$Input$DateTimeFieldUpdateOperationsInput<TRes> get updatedAt {
    final local$updatedAt = _instance.updatedAt;
    return local$updatedAt == null
        ? CopyWith$Input$DateTimeFieldUpdateOperationsInput.stub(
            _then(_instance))
        : CopyWith$Input$DateTimeFieldUpdateOperationsInput(
            local$updatedAt, (e) => call(updatedAt: e));
  }

  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get uuid {
    final local$uuid = _instance.uuid;
    return local$uuid == null
        ? CopyWith$Input$StringFieldUpdateOperationsInput.stub(_then(_instance))
        : CopyWith$Input$StringFieldUpdateOperationsInput(
            local$uuid, (e) => call(uuid: e));
  }
}

class _CopyWithStubImpl$Input$BookUpdateManyMutationInput<TRes>
    implements CopyWith$Input$BookUpdateManyMutationInput<TRes> {
  _CopyWithStubImpl$Input$BookUpdateManyMutationInput(this._res);

  TRes _res;

  call({
    Input$DateTimeFieldUpdateOperationsInput? createdAt,
    Input$StringFieldUpdateOperationsInput? title,
    Input$DateTimeFieldUpdateOperationsInput? updatedAt,
    Input$StringFieldUpdateOperationsInput? uuid,
  }) =>
      _res;

  CopyWith$Input$DateTimeFieldUpdateOperationsInput<TRes> get createdAt =>
      CopyWith$Input$DateTimeFieldUpdateOperationsInput.stub(_res);

  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get title =>
      CopyWith$Input$StringFieldUpdateOperationsInput.stub(_res);

  CopyWith$Input$DateTimeFieldUpdateOperationsInput<TRes> get updatedAt =>
      CopyWith$Input$DateTimeFieldUpdateOperationsInput.stub(_res);

  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get uuid =>
      CopyWith$Input$StringFieldUpdateOperationsInput.stub(_res);
}

class Input$BookUpdateOneWithoutBookEditedNestedInput {
  factory Input$BookUpdateOneWithoutBookEditedNestedInput({
    Input$BookWhereUniqueInput? connect,
    Input$BookCreateOrConnectWithoutBookEditedInput? connectOrCreate,
    Input$BookCreateWithoutBookEditedInput? create,
    Input$BookWhereInput? delete,
    Input$BookWhereInput? disconnect,
    Input$BookUpdateToOneWithWhereWithoutBookEditedInput? update,
    Input$BookUpsertWithoutBookEditedInput? upsert,
  }) =>
      Input$BookUpdateOneWithoutBookEditedNestedInput._({
        if (connect != null) r'connect': connect,
        if (connectOrCreate != null) r'connectOrCreate': connectOrCreate,
        if (create != null) r'create': create,
        if (delete != null) r'delete': delete,
        if (disconnect != null) r'disconnect': disconnect,
        if (update != null) r'update': update,
        if (upsert != null) r'upsert': upsert,
      });

  Input$BookUpdateOneWithoutBookEditedNestedInput._(this._$data);

  factory Input$BookUpdateOneWithoutBookEditedNestedInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('connect')) {
      final l$connect = data['connect'];
      result$data['connect'] = l$connect == null
          ? null
          : Input$BookWhereUniqueInput.fromJson(
              (l$connect as Map<String, dynamic>));
    }
    if (data.containsKey('connectOrCreate')) {
      final l$connectOrCreate = data['connectOrCreate'];
      result$data['connectOrCreate'] = l$connectOrCreate == null
          ? null
          : Input$BookCreateOrConnectWithoutBookEditedInput.fromJson(
              (l$connectOrCreate as Map<String, dynamic>));
    }
    if (data.containsKey('create')) {
      final l$create = data['create'];
      result$data['create'] = l$create == null
          ? null
          : Input$BookCreateWithoutBookEditedInput.fromJson(
              (l$create as Map<String, dynamic>));
    }
    if (data.containsKey('delete')) {
      final l$delete = data['delete'];
      result$data['delete'] = l$delete == null
          ? null
          : Input$BookWhereInput.fromJson((l$delete as Map<String, dynamic>));
    }
    if (data.containsKey('disconnect')) {
      final l$disconnect = data['disconnect'];
      result$data['disconnect'] = l$disconnect == null
          ? null
          : Input$BookWhereInput.fromJson(
              (l$disconnect as Map<String, dynamic>));
    }
    if (data.containsKey('update')) {
      final l$update = data['update'];
      result$data['update'] = l$update == null
          ? null
          : Input$BookUpdateToOneWithWhereWithoutBookEditedInput.fromJson(
              (l$update as Map<String, dynamic>));
    }
    if (data.containsKey('upsert')) {
      final l$upsert = data['upsert'];
      result$data['upsert'] = l$upsert == null
          ? null
          : Input$BookUpsertWithoutBookEditedInput.fromJson(
              (l$upsert as Map<String, dynamic>));
    }
    return Input$BookUpdateOneWithoutBookEditedNestedInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$BookWhereUniqueInput? get connect =>
      (_$data['connect'] as Input$BookWhereUniqueInput?);

  Input$BookCreateOrConnectWithoutBookEditedInput? get connectOrCreate =>
      (_$data['connectOrCreate']
          as Input$BookCreateOrConnectWithoutBookEditedInput?);

  Input$BookCreateWithoutBookEditedInput? get create =>
      (_$data['create'] as Input$BookCreateWithoutBookEditedInput?);

  Input$BookWhereInput? get delete =>
      (_$data['delete'] as Input$BookWhereInput?);

  Input$BookWhereInput? get disconnect =>
      (_$data['disconnect'] as Input$BookWhereInput?);

  Input$BookUpdateToOneWithWhereWithoutBookEditedInput? get update =>
      (_$data['update']
          as Input$BookUpdateToOneWithWhereWithoutBookEditedInput?);

  Input$BookUpsertWithoutBookEditedInput? get upsert =>
      (_$data['upsert'] as Input$BookUpsertWithoutBookEditedInput?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('connect')) {
      final l$connect = connect;
      result$data['connect'] = l$connect?.toJson();
    }
    if (_$data.containsKey('connectOrCreate')) {
      final l$connectOrCreate = connectOrCreate;
      result$data['connectOrCreate'] = l$connectOrCreate?.toJson();
    }
    if (_$data.containsKey('create')) {
      final l$create = create;
      result$data['create'] = l$create?.toJson();
    }
    if (_$data.containsKey('delete')) {
      final l$delete = delete;
      result$data['delete'] = l$delete?.toJson();
    }
    if (_$data.containsKey('disconnect')) {
      final l$disconnect = disconnect;
      result$data['disconnect'] = l$disconnect?.toJson();
    }
    if (_$data.containsKey('update')) {
      final l$update = update;
      result$data['update'] = l$update?.toJson();
    }
    if (_$data.containsKey('upsert')) {
      final l$upsert = upsert;
      result$data['upsert'] = l$upsert?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$BookUpdateOneWithoutBookEditedNestedInput<
          Input$BookUpdateOneWithoutBookEditedNestedInput>
      get copyWith => CopyWith$Input$BookUpdateOneWithoutBookEditedNestedInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$BookUpdateOneWithoutBookEditedNestedInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$connect = connect;
    final lOther$connect = other.connect;
    if (_$data.containsKey('connect') != other._$data.containsKey('connect')) {
      return false;
    }
    if (l$connect != lOther$connect) {
      return false;
    }
    final l$connectOrCreate = connectOrCreate;
    final lOther$connectOrCreate = other.connectOrCreate;
    if (_$data.containsKey('connectOrCreate') !=
        other._$data.containsKey('connectOrCreate')) {
      return false;
    }
    if (l$connectOrCreate != lOther$connectOrCreate) {
      return false;
    }
    final l$create = create;
    final lOther$create = other.create;
    if (_$data.containsKey('create') != other._$data.containsKey('create')) {
      return false;
    }
    if (l$create != lOther$create) {
      return false;
    }
    final l$delete = delete;
    final lOther$delete = other.delete;
    if (_$data.containsKey('delete') != other._$data.containsKey('delete')) {
      return false;
    }
    if (l$delete != lOther$delete) {
      return false;
    }
    final l$disconnect = disconnect;
    final lOther$disconnect = other.disconnect;
    if (_$data.containsKey('disconnect') !=
        other._$data.containsKey('disconnect')) {
      return false;
    }
    if (l$disconnect != lOther$disconnect) {
      return false;
    }
    final l$update = update;
    final lOther$update = other.update;
    if (_$data.containsKey('update') != other._$data.containsKey('update')) {
      return false;
    }
    if (l$update != lOther$update) {
      return false;
    }
    final l$upsert = upsert;
    final lOther$upsert = other.upsert;
    if (_$data.containsKey('upsert') != other._$data.containsKey('upsert')) {
      return false;
    }
    if (l$upsert != lOther$upsert) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$connect = connect;
    final l$connectOrCreate = connectOrCreate;
    final l$create = create;
    final l$delete = delete;
    final l$disconnect = disconnect;
    final l$update = update;
    final l$upsert = upsert;
    return Object.hashAll([
      _$data.containsKey('connect') ? l$connect : const {},
      _$data.containsKey('connectOrCreate') ? l$connectOrCreate : const {},
      _$data.containsKey('create') ? l$create : const {},
      _$data.containsKey('delete') ? l$delete : const {},
      _$data.containsKey('disconnect') ? l$disconnect : const {},
      _$data.containsKey('update') ? l$update : const {},
      _$data.containsKey('upsert') ? l$upsert : const {},
    ]);
  }
}

abstract class CopyWith$Input$BookUpdateOneWithoutBookEditedNestedInput<TRes> {
  factory CopyWith$Input$BookUpdateOneWithoutBookEditedNestedInput(
    Input$BookUpdateOneWithoutBookEditedNestedInput instance,
    TRes Function(Input$BookUpdateOneWithoutBookEditedNestedInput) then,
  ) = _CopyWithImpl$Input$BookUpdateOneWithoutBookEditedNestedInput;

  factory CopyWith$Input$BookUpdateOneWithoutBookEditedNestedInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$BookUpdateOneWithoutBookEditedNestedInput;

  TRes call({
    Input$BookWhereUniqueInput? connect,
    Input$BookCreateOrConnectWithoutBookEditedInput? connectOrCreate,
    Input$BookCreateWithoutBookEditedInput? create,
    Input$BookWhereInput? delete,
    Input$BookWhereInput? disconnect,
    Input$BookUpdateToOneWithWhereWithoutBookEditedInput? update,
    Input$BookUpsertWithoutBookEditedInput? upsert,
  });
  CopyWith$Input$BookWhereUniqueInput<TRes> get connect;
  CopyWith$Input$BookCreateOrConnectWithoutBookEditedInput<TRes>
      get connectOrCreate;
  CopyWith$Input$BookCreateWithoutBookEditedInput<TRes> get create;
  CopyWith$Input$BookWhereInput<TRes> get delete;
  CopyWith$Input$BookWhereInput<TRes> get disconnect;
  CopyWith$Input$BookUpdateToOneWithWhereWithoutBookEditedInput<TRes>
      get update;
  CopyWith$Input$BookUpsertWithoutBookEditedInput<TRes> get upsert;
}

class _CopyWithImpl$Input$BookUpdateOneWithoutBookEditedNestedInput<TRes>
    implements CopyWith$Input$BookUpdateOneWithoutBookEditedNestedInput<TRes> {
  _CopyWithImpl$Input$BookUpdateOneWithoutBookEditedNestedInput(
    this._instance,
    this._then,
  );

  final Input$BookUpdateOneWithoutBookEditedNestedInput _instance;

  final TRes Function(Input$BookUpdateOneWithoutBookEditedNestedInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? connect = _undefined,
    Object? connectOrCreate = _undefined,
    Object? create = _undefined,
    Object? delete = _undefined,
    Object? disconnect = _undefined,
    Object? update = _undefined,
    Object? upsert = _undefined,
  }) =>
      _then(Input$BookUpdateOneWithoutBookEditedNestedInput._({
        ..._instance._$data,
        if (connect != _undefined)
          'connect': (connect as Input$BookWhereUniqueInput?),
        if (connectOrCreate != _undefined)
          'connectOrCreate': (connectOrCreate
              as Input$BookCreateOrConnectWithoutBookEditedInput?),
        if (create != _undefined)
          'create': (create as Input$BookCreateWithoutBookEditedInput?),
        if (delete != _undefined) 'delete': (delete as Input$BookWhereInput?),
        if (disconnect != _undefined)
          'disconnect': (disconnect as Input$BookWhereInput?),
        if (update != _undefined)
          'update':
              (update as Input$BookUpdateToOneWithWhereWithoutBookEditedInput?),
        if (upsert != _undefined)
          'upsert': (upsert as Input$BookUpsertWithoutBookEditedInput?),
      }));

  CopyWith$Input$BookWhereUniqueInput<TRes> get connect {
    final local$connect = _instance.connect;
    return local$connect == null
        ? CopyWith$Input$BookWhereUniqueInput.stub(_then(_instance))
        : CopyWith$Input$BookWhereUniqueInput(
            local$connect, (e) => call(connect: e));
  }

  CopyWith$Input$BookCreateOrConnectWithoutBookEditedInput<TRes>
      get connectOrCreate {
    final local$connectOrCreate = _instance.connectOrCreate;
    return local$connectOrCreate == null
        ? CopyWith$Input$BookCreateOrConnectWithoutBookEditedInput.stub(
            _then(_instance))
        : CopyWith$Input$BookCreateOrConnectWithoutBookEditedInput(
            local$connectOrCreate, (e) => call(connectOrCreate: e));
  }

  CopyWith$Input$BookCreateWithoutBookEditedInput<TRes> get create {
    final local$create = _instance.create;
    return local$create == null
        ? CopyWith$Input$BookCreateWithoutBookEditedInput.stub(_then(_instance))
        : CopyWith$Input$BookCreateWithoutBookEditedInput(
            local$create, (e) => call(create: e));
  }

  CopyWith$Input$BookWhereInput<TRes> get delete {
    final local$delete = _instance.delete;
    return local$delete == null
        ? CopyWith$Input$BookWhereInput.stub(_then(_instance))
        : CopyWith$Input$BookWhereInput(local$delete, (e) => call(delete: e));
  }

  CopyWith$Input$BookWhereInput<TRes> get disconnect {
    final local$disconnect = _instance.disconnect;
    return local$disconnect == null
        ? CopyWith$Input$BookWhereInput.stub(_then(_instance))
        : CopyWith$Input$BookWhereInput(
            local$disconnect, (e) => call(disconnect: e));
  }

  CopyWith$Input$BookUpdateToOneWithWhereWithoutBookEditedInput<TRes>
      get update {
    final local$update = _instance.update;
    return local$update == null
        ? CopyWith$Input$BookUpdateToOneWithWhereWithoutBookEditedInput.stub(
            _then(_instance))
        : CopyWith$Input$BookUpdateToOneWithWhereWithoutBookEditedInput(
            local$update, (e) => call(update: e));
  }

  CopyWith$Input$BookUpsertWithoutBookEditedInput<TRes> get upsert {
    final local$upsert = _instance.upsert;
    return local$upsert == null
        ? CopyWith$Input$BookUpsertWithoutBookEditedInput.stub(_then(_instance))
        : CopyWith$Input$BookUpsertWithoutBookEditedInput(
            local$upsert, (e) => call(upsert: e));
  }
}

class _CopyWithStubImpl$Input$BookUpdateOneWithoutBookEditedNestedInput<TRes>
    implements CopyWith$Input$BookUpdateOneWithoutBookEditedNestedInput<TRes> {
  _CopyWithStubImpl$Input$BookUpdateOneWithoutBookEditedNestedInput(this._res);

  TRes _res;

  call({
    Input$BookWhereUniqueInput? connect,
    Input$BookCreateOrConnectWithoutBookEditedInput? connectOrCreate,
    Input$BookCreateWithoutBookEditedInput? create,
    Input$BookWhereInput? delete,
    Input$BookWhereInput? disconnect,
    Input$BookUpdateToOneWithWhereWithoutBookEditedInput? update,
    Input$BookUpsertWithoutBookEditedInput? upsert,
  }) =>
      _res;

  CopyWith$Input$BookWhereUniqueInput<TRes> get connect =>
      CopyWith$Input$BookWhereUniqueInput.stub(_res);

  CopyWith$Input$BookCreateOrConnectWithoutBookEditedInput<TRes>
      get connectOrCreate =>
          CopyWith$Input$BookCreateOrConnectWithoutBookEditedInput.stub(_res);

  CopyWith$Input$BookCreateWithoutBookEditedInput<TRes> get create =>
      CopyWith$Input$BookCreateWithoutBookEditedInput.stub(_res);

  CopyWith$Input$BookWhereInput<TRes> get delete =>
      CopyWith$Input$BookWhereInput.stub(_res);

  CopyWith$Input$BookWhereInput<TRes> get disconnect =>
      CopyWith$Input$BookWhereInput.stub(_res);

  CopyWith$Input$BookUpdateToOneWithWhereWithoutBookEditedInput<TRes>
      get update =>
          CopyWith$Input$BookUpdateToOneWithWhereWithoutBookEditedInput.stub(
              _res);

  CopyWith$Input$BookUpsertWithoutBookEditedInput<TRes> get upsert =>
      CopyWith$Input$BookUpsertWithoutBookEditedInput.stub(_res);
}

class Input$BookUpdateOneWithoutBookRawNestedInput {
  factory Input$BookUpdateOneWithoutBookRawNestedInput({
    Input$BookWhereUniqueInput? connect,
    Input$BookCreateOrConnectWithoutBookRawInput? connectOrCreate,
    Input$BookCreateWithoutBookRawInput? create,
    Input$BookWhereInput? delete,
    Input$BookWhereInput? disconnect,
    Input$BookUpdateToOneWithWhereWithoutBookRawInput? update,
    Input$BookUpsertWithoutBookRawInput? upsert,
  }) =>
      Input$BookUpdateOneWithoutBookRawNestedInput._({
        if (connect != null) r'connect': connect,
        if (connectOrCreate != null) r'connectOrCreate': connectOrCreate,
        if (create != null) r'create': create,
        if (delete != null) r'delete': delete,
        if (disconnect != null) r'disconnect': disconnect,
        if (update != null) r'update': update,
        if (upsert != null) r'upsert': upsert,
      });

  Input$BookUpdateOneWithoutBookRawNestedInput._(this._$data);

  factory Input$BookUpdateOneWithoutBookRawNestedInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('connect')) {
      final l$connect = data['connect'];
      result$data['connect'] = l$connect == null
          ? null
          : Input$BookWhereUniqueInput.fromJson(
              (l$connect as Map<String, dynamic>));
    }
    if (data.containsKey('connectOrCreate')) {
      final l$connectOrCreate = data['connectOrCreate'];
      result$data['connectOrCreate'] = l$connectOrCreate == null
          ? null
          : Input$BookCreateOrConnectWithoutBookRawInput.fromJson(
              (l$connectOrCreate as Map<String, dynamic>));
    }
    if (data.containsKey('create')) {
      final l$create = data['create'];
      result$data['create'] = l$create == null
          ? null
          : Input$BookCreateWithoutBookRawInput.fromJson(
              (l$create as Map<String, dynamic>));
    }
    if (data.containsKey('delete')) {
      final l$delete = data['delete'];
      result$data['delete'] = l$delete == null
          ? null
          : Input$BookWhereInput.fromJson((l$delete as Map<String, dynamic>));
    }
    if (data.containsKey('disconnect')) {
      final l$disconnect = data['disconnect'];
      result$data['disconnect'] = l$disconnect == null
          ? null
          : Input$BookWhereInput.fromJson(
              (l$disconnect as Map<String, dynamic>));
    }
    if (data.containsKey('update')) {
      final l$update = data['update'];
      result$data['update'] = l$update == null
          ? null
          : Input$BookUpdateToOneWithWhereWithoutBookRawInput.fromJson(
              (l$update as Map<String, dynamic>));
    }
    if (data.containsKey('upsert')) {
      final l$upsert = data['upsert'];
      result$data['upsert'] = l$upsert == null
          ? null
          : Input$BookUpsertWithoutBookRawInput.fromJson(
              (l$upsert as Map<String, dynamic>));
    }
    return Input$BookUpdateOneWithoutBookRawNestedInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$BookWhereUniqueInput? get connect =>
      (_$data['connect'] as Input$BookWhereUniqueInput?);

  Input$BookCreateOrConnectWithoutBookRawInput? get connectOrCreate =>
      (_$data['connectOrCreate']
          as Input$BookCreateOrConnectWithoutBookRawInput?);

  Input$BookCreateWithoutBookRawInput? get create =>
      (_$data['create'] as Input$BookCreateWithoutBookRawInput?);

  Input$BookWhereInput? get delete =>
      (_$data['delete'] as Input$BookWhereInput?);

  Input$BookWhereInput? get disconnect =>
      (_$data['disconnect'] as Input$BookWhereInput?);

  Input$BookUpdateToOneWithWhereWithoutBookRawInput? get update =>
      (_$data['update'] as Input$BookUpdateToOneWithWhereWithoutBookRawInput?);

  Input$BookUpsertWithoutBookRawInput? get upsert =>
      (_$data['upsert'] as Input$BookUpsertWithoutBookRawInput?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('connect')) {
      final l$connect = connect;
      result$data['connect'] = l$connect?.toJson();
    }
    if (_$data.containsKey('connectOrCreate')) {
      final l$connectOrCreate = connectOrCreate;
      result$data['connectOrCreate'] = l$connectOrCreate?.toJson();
    }
    if (_$data.containsKey('create')) {
      final l$create = create;
      result$data['create'] = l$create?.toJson();
    }
    if (_$data.containsKey('delete')) {
      final l$delete = delete;
      result$data['delete'] = l$delete?.toJson();
    }
    if (_$data.containsKey('disconnect')) {
      final l$disconnect = disconnect;
      result$data['disconnect'] = l$disconnect?.toJson();
    }
    if (_$data.containsKey('update')) {
      final l$update = update;
      result$data['update'] = l$update?.toJson();
    }
    if (_$data.containsKey('upsert')) {
      final l$upsert = upsert;
      result$data['upsert'] = l$upsert?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$BookUpdateOneWithoutBookRawNestedInput<
          Input$BookUpdateOneWithoutBookRawNestedInput>
      get copyWith => CopyWith$Input$BookUpdateOneWithoutBookRawNestedInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$BookUpdateOneWithoutBookRawNestedInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$connect = connect;
    final lOther$connect = other.connect;
    if (_$data.containsKey('connect') != other._$data.containsKey('connect')) {
      return false;
    }
    if (l$connect != lOther$connect) {
      return false;
    }
    final l$connectOrCreate = connectOrCreate;
    final lOther$connectOrCreate = other.connectOrCreate;
    if (_$data.containsKey('connectOrCreate') !=
        other._$data.containsKey('connectOrCreate')) {
      return false;
    }
    if (l$connectOrCreate != lOther$connectOrCreate) {
      return false;
    }
    final l$create = create;
    final lOther$create = other.create;
    if (_$data.containsKey('create') != other._$data.containsKey('create')) {
      return false;
    }
    if (l$create != lOther$create) {
      return false;
    }
    final l$delete = delete;
    final lOther$delete = other.delete;
    if (_$data.containsKey('delete') != other._$data.containsKey('delete')) {
      return false;
    }
    if (l$delete != lOther$delete) {
      return false;
    }
    final l$disconnect = disconnect;
    final lOther$disconnect = other.disconnect;
    if (_$data.containsKey('disconnect') !=
        other._$data.containsKey('disconnect')) {
      return false;
    }
    if (l$disconnect != lOther$disconnect) {
      return false;
    }
    final l$update = update;
    final lOther$update = other.update;
    if (_$data.containsKey('update') != other._$data.containsKey('update')) {
      return false;
    }
    if (l$update != lOther$update) {
      return false;
    }
    final l$upsert = upsert;
    final lOther$upsert = other.upsert;
    if (_$data.containsKey('upsert') != other._$data.containsKey('upsert')) {
      return false;
    }
    if (l$upsert != lOther$upsert) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$connect = connect;
    final l$connectOrCreate = connectOrCreate;
    final l$create = create;
    final l$delete = delete;
    final l$disconnect = disconnect;
    final l$update = update;
    final l$upsert = upsert;
    return Object.hashAll([
      _$data.containsKey('connect') ? l$connect : const {},
      _$data.containsKey('connectOrCreate') ? l$connectOrCreate : const {},
      _$data.containsKey('create') ? l$create : const {},
      _$data.containsKey('delete') ? l$delete : const {},
      _$data.containsKey('disconnect') ? l$disconnect : const {},
      _$data.containsKey('update') ? l$update : const {},
      _$data.containsKey('upsert') ? l$upsert : const {},
    ]);
  }
}

abstract class CopyWith$Input$BookUpdateOneWithoutBookRawNestedInput<TRes> {
  factory CopyWith$Input$BookUpdateOneWithoutBookRawNestedInput(
    Input$BookUpdateOneWithoutBookRawNestedInput instance,
    TRes Function(Input$BookUpdateOneWithoutBookRawNestedInput) then,
  ) = _CopyWithImpl$Input$BookUpdateOneWithoutBookRawNestedInput;

  factory CopyWith$Input$BookUpdateOneWithoutBookRawNestedInput.stub(TRes res) =
      _CopyWithStubImpl$Input$BookUpdateOneWithoutBookRawNestedInput;

  TRes call({
    Input$BookWhereUniqueInput? connect,
    Input$BookCreateOrConnectWithoutBookRawInput? connectOrCreate,
    Input$BookCreateWithoutBookRawInput? create,
    Input$BookWhereInput? delete,
    Input$BookWhereInput? disconnect,
    Input$BookUpdateToOneWithWhereWithoutBookRawInput? update,
    Input$BookUpsertWithoutBookRawInput? upsert,
  });
  CopyWith$Input$BookWhereUniqueInput<TRes> get connect;
  CopyWith$Input$BookCreateOrConnectWithoutBookRawInput<TRes>
      get connectOrCreate;
  CopyWith$Input$BookCreateWithoutBookRawInput<TRes> get create;
  CopyWith$Input$BookWhereInput<TRes> get delete;
  CopyWith$Input$BookWhereInput<TRes> get disconnect;
  CopyWith$Input$BookUpdateToOneWithWhereWithoutBookRawInput<TRes> get update;
  CopyWith$Input$BookUpsertWithoutBookRawInput<TRes> get upsert;
}

class _CopyWithImpl$Input$BookUpdateOneWithoutBookRawNestedInput<TRes>
    implements CopyWith$Input$BookUpdateOneWithoutBookRawNestedInput<TRes> {
  _CopyWithImpl$Input$BookUpdateOneWithoutBookRawNestedInput(
    this._instance,
    this._then,
  );

  final Input$BookUpdateOneWithoutBookRawNestedInput _instance;

  final TRes Function(Input$BookUpdateOneWithoutBookRawNestedInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? connect = _undefined,
    Object? connectOrCreate = _undefined,
    Object? create = _undefined,
    Object? delete = _undefined,
    Object? disconnect = _undefined,
    Object? update = _undefined,
    Object? upsert = _undefined,
  }) =>
      _then(Input$BookUpdateOneWithoutBookRawNestedInput._({
        ..._instance._$data,
        if (connect != _undefined)
          'connect': (connect as Input$BookWhereUniqueInput?),
        if (connectOrCreate != _undefined)
          'connectOrCreate': (connectOrCreate
              as Input$BookCreateOrConnectWithoutBookRawInput?),
        if (create != _undefined)
          'create': (create as Input$BookCreateWithoutBookRawInput?),
        if (delete != _undefined) 'delete': (delete as Input$BookWhereInput?),
        if (disconnect != _undefined)
          'disconnect': (disconnect as Input$BookWhereInput?),
        if (update != _undefined)
          'update':
              (update as Input$BookUpdateToOneWithWhereWithoutBookRawInput?),
        if (upsert != _undefined)
          'upsert': (upsert as Input$BookUpsertWithoutBookRawInput?),
      }));

  CopyWith$Input$BookWhereUniqueInput<TRes> get connect {
    final local$connect = _instance.connect;
    return local$connect == null
        ? CopyWith$Input$BookWhereUniqueInput.stub(_then(_instance))
        : CopyWith$Input$BookWhereUniqueInput(
            local$connect, (e) => call(connect: e));
  }

  CopyWith$Input$BookCreateOrConnectWithoutBookRawInput<TRes>
      get connectOrCreate {
    final local$connectOrCreate = _instance.connectOrCreate;
    return local$connectOrCreate == null
        ? CopyWith$Input$BookCreateOrConnectWithoutBookRawInput.stub(
            _then(_instance))
        : CopyWith$Input$BookCreateOrConnectWithoutBookRawInput(
            local$connectOrCreate, (e) => call(connectOrCreate: e));
  }

  CopyWith$Input$BookCreateWithoutBookRawInput<TRes> get create {
    final local$create = _instance.create;
    return local$create == null
        ? CopyWith$Input$BookCreateWithoutBookRawInput.stub(_then(_instance))
        : CopyWith$Input$BookCreateWithoutBookRawInput(
            local$create, (e) => call(create: e));
  }

  CopyWith$Input$BookWhereInput<TRes> get delete {
    final local$delete = _instance.delete;
    return local$delete == null
        ? CopyWith$Input$BookWhereInput.stub(_then(_instance))
        : CopyWith$Input$BookWhereInput(local$delete, (e) => call(delete: e));
  }

  CopyWith$Input$BookWhereInput<TRes> get disconnect {
    final local$disconnect = _instance.disconnect;
    return local$disconnect == null
        ? CopyWith$Input$BookWhereInput.stub(_then(_instance))
        : CopyWith$Input$BookWhereInput(
            local$disconnect, (e) => call(disconnect: e));
  }

  CopyWith$Input$BookUpdateToOneWithWhereWithoutBookRawInput<TRes> get update {
    final local$update = _instance.update;
    return local$update == null
        ? CopyWith$Input$BookUpdateToOneWithWhereWithoutBookRawInput.stub(
            _then(_instance))
        : CopyWith$Input$BookUpdateToOneWithWhereWithoutBookRawInput(
            local$update, (e) => call(update: e));
  }

  CopyWith$Input$BookUpsertWithoutBookRawInput<TRes> get upsert {
    final local$upsert = _instance.upsert;
    return local$upsert == null
        ? CopyWith$Input$BookUpsertWithoutBookRawInput.stub(_then(_instance))
        : CopyWith$Input$BookUpsertWithoutBookRawInput(
            local$upsert, (e) => call(upsert: e));
  }
}

class _CopyWithStubImpl$Input$BookUpdateOneWithoutBookRawNestedInput<TRes>
    implements CopyWith$Input$BookUpdateOneWithoutBookRawNestedInput<TRes> {
  _CopyWithStubImpl$Input$BookUpdateOneWithoutBookRawNestedInput(this._res);

  TRes _res;

  call({
    Input$BookWhereUniqueInput? connect,
    Input$BookCreateOrConnectWithoutBookRawInput? connectOrCreate,
    Input$BookCreateWithoutBookRawInput? create,
    Input$BookWhereInput? delete,
    Input$BookWhereInput? disconnect,
    Input$BookUpdateToOneWithWhereWithoutBookRawInput? update,
    Input$BookUpsertWithoutBookRawInput? upsert,
  }) =>
      _res;

  CopyWith$Input$BookWhereUniqueInput<TRes> get connect =>
      CopyWith$Input$BookWhereUniqueInput.stub(_res);

  CopyWith$Input$BookCreateOrConnectWithoutBookRawInput<TRes>
      get connectOrCreate =>
          CopyWith$Input$BookCreateOrConnectWithoutBookRawInput.stub(_res);

  CopyWith$Input$BookCreateWithoutBookRawInput<TRes> get create =>
      CopyWith$Input$BookCreateWithoutBookRawInput.stub(_res);

  CopyWith$Input$BookWhereInput<TRes> get delete =>
      CopyWith$Input$BookWhereInput.stub(_res);

  CopyWith$Input$BookWhereInput<TRes> get disconnect =>
      CopyWith$Input$BookWhereInput.stub(_res);

  CopyWith$Input$BookUpdateToOneWithWhereWithoutBookRawInput<TRes> get update =>
      CopyWith$Input$BookUpdateToOneWithWhereWithoutBookRawInput.stub(_res);

  CopyWith$Input$BookUpsertWithoutBookRawInput<TRes> get upsert =>
      CopyWith$Input$BookUpsertWithoutBookRawInput.stub(_res);
}

class Input$BookUpdateToOneWithWhereWithoutBookEditedInput {
  factory Input$BookUpdateToOneWithWhereWithoutBookEditedInput({
    required Input$BookUpdateWithoutBookEditedInput data,
    Input$BookWhereInput? where,
  }) =>
      Input$BookUpdateToOneWithWhereWithoutBookEditedInput._({
        r'data': data,
        if (where != null) r'where': where,
      });

  Input$BookUpdateToOneWithWhereWithoutBookEditedInput._(this._$data);

  factory Input$BookUpdateToOneWithWhereWithoutBookEditedInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$data = data['data'];
    result$data['data'] = Input$BookUpdateWithoutBookEditedInput.fromJson(
        (l$data as Map<String, dynamic>));
    if (data.containsKey('where')) {
      final l$where = data['where'];
      result$data['where'] = l$where == null
          ? null
          : Input$BookWhereInput.fromJson((l$where as Map<String, dynamic>));
    }
    return Input$BookUpdateToOneWithWhereWithoutBookEditedInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$BookUpdateWithoutBookEditedInput get data =>
      (_$data['data'] as Input$BookUpdateWithoutBookEditedInput);

  Input$BookWhereInput? get where => (_$data['where'] as Input$BookWhereInput?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$data = data;
    result$data['data'] = l$data.toJson();
    if (_$data.containsKey('where')) {
      final l$where = where;
      result$data['where'] = l$where?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$BookUpdateToOneWithWhereWithoutBookEditedInput<
          Input$BookUpdateToOneWithWhereWithoutBookEditedInput>
      get copyWith =>
          CopyWith$Input$BookUpdateToOneWithWhereWithoutBookEditedInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$BookUpdateToOneWithWhereWithoutBookEditedInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$data = data;
    final lOther$data = other.data;
    if (l$data != lOther$data) {
      return false;
    }
    final l$where = where;
    final lOther$where = other.where;
    if (_$data.containsKey('where') != other._$data.containsKey('where')) {
      return false;
    }
    if (l$where != lOther$where) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$data = data;
    final l$where = where;
    return Object.hashAll([
      l$data,
      _$data.containsKey('where') ? l$where : const {},
    ]);
  }
}

abstract class CopyWith$Input$BookUpdateToOneWithWhereWithoutBookEditedInput<
    TRes> {
  factory CopyWith$Input$BookUpdateToOneWithWhereWithoutBookEditedInput(
    Input$BookUpdateToOneWithWhereWithoutBookEditedInput instance,
    TRes Function(Input$BookUpdateToOneWithWhereWithoutBookEditedInput) then,
  ) = _CopyWithImpl$Input$BookUpdateToOneWithWhereWithoutBookEditedInput;

  factory CopyWith$Input$BookUpdateToOneWithWhereWithoutBookEditedInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$BookUpdateToOneWithWhereWithoutBookEditedInput;

  TRes call({
    Input$BookUpdateWithoutBookEditedInput? data,
    Input$BookWhereInput? where,
  });
  CopyWith$Input$BookUpdateWithoutBookEditedInput<TRes> get data;
  CopyWith$Input$BookWhereInput<TRes> get where;
}

class _CopyWithImpl$Input$BookUpdateToOneWithWhereWithoutBookEditedInput<TRes>
    implements
        CopyWith$Input$BookUpdateToOneWithWhereWithoutBookEditedInput<TRes> {
  _CopyWithImpl$Input$BookUpdateToOneWithWhereWithoutBookEditedInput(
    this._instance,
    this._then,
  );

  final Input$BookUpdateToOneWithWhereWithoutBookEditedInput _instance;

  final TRes Function(Input$BookUpdateToOneWithWhereWithoutBookEditedInput)
      _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? data = _undefined,
    Object? where = _undefined,
  }) =>
      _then(Input$BookUpdateToOneWithWhereWithoutBookEditedInput._({
        ..._instance._$data,
        if (data != _undefined && data != null)
          'data': (data as Input$BookUpdateWithoutBookEditedInput),
        if (where != _undefined) 'where': (where as Input$BookWhereInput?),
      }));

  CopyWith$Input$BookUpdateWithoutBookEditedInput<TRes> get data {
    final local$data = _instance.data;
    return CopyWith$Input$BookUpdateWithoutBookEditedInput(
        local$data, (e) => call(data: e));
  }

  CopyWith$Input$BookWhereInput<TRes> get where {
    final local$where = _instance.where;
    return local$where == null
        ? CopyWith$Input$BookWhereInput.stub(_then(_instance))
        : CopyWith$Input$BookWhereInput(local$where, (e) => call(where: e));
  }
}

class _CopyWithStubImpl$Input$BookUpdateToOneWithWhereWithoutBookEditedInput<
        TRes>
    implements
        CopyWith$Input$BookUpdateToOneWithWhereWithoutBookEditedInput<TRes> {
  _CopyWithStubImpl$Input$BookUpdateToOneWithWhereWithoutBookEditedInput(
      this._res);

  TRes _res;

  call({
    Input$BookUpdateWithoutBookEditedInput? data,
    Input$BookWhereInput? where,
  }) =>
      _res;

  CopyWith$Input$BookUpdateWithoutBookEditedInput<TRes> get data =>
      CopyWith$Input$BookUpdateWithoutBookEditedInput.stub(_res);

  CopyWith$Input$BookWhereInput<TRes> get where =>
      CopyWith$Input$BookWhereInput.stub(_res);
}

class Input$BookUpdateToOneWithWhereWithoutBookRawInput {
  factory Input$BookUpdateToOneWithWhereWithoutBookRawInput({
    required Input$BookUpdateWithoutBookRawInput data,
    Input$BookWhereInput? where,
  }) =>
      Input$BookUpdateToOneWithWhereWithoutBookRawInput._({
        r'data': data,
        if (where != null) r'where': where,
      });

  Input$BookUpdateToOneWithWhereWithoutBookRawInput._(this._$data);

  factory Input$BookUpdateToOneWithWhereWithoutBookRawInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$data = data['data'];
    result$data['data'] = Input$BookUpdateWithoutBookRawInput.fromJson(
        (l$data as Map<String, dynamic>));
    if (data.containsKey('where')) {
      final l$where = data['where'];
      result$data['where'] = l$where == null
          ? null
          : Input$BookWhereInput.fromJson((l$where as Map<String, dynamic>));
    }
    return Input$BookUpdateToOneWithWhereWithoutBookRawInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$BookUpdateWithoutBookRawInput get data =>
      (_$data['data'] as Input$BookUpdateWithoutBookRawInput);

  Input$BookWhereInput? get where => (_$data['where'] as Input$BookWhereInput?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$data = data;
    result$data['data'] = l$data.toJson();
    if (_$data.containsKey('where')) {
      final l$where = where;
      result$data['where'] = l$where?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$BookUpdateToOneWithWhereWithoutBookRawInput<
          Input$BookUpdateToOneWithWhereWithoutBookRawInput>
      get copyWith =>
          CopyWith$Input$BookUpdateToOneWithWhereWithoutBookRawInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$BookUpdateToOneWithWhereWithoutBookRawInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$data = data;
    final lOther$data = other.data;
    if (l$data != lOther$data) {
      return false;
    }
    final l$where = where;
    final lOther$where = other.where;
    if (_$data.containsKey('where') != other._$data.containsKey('where')) {
      return false;
    }
    if (l$where != lOther$where) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$data = data;
    final l$where = where;
    return Object.hashAll([
      l$data,
      _$data.containsKey('where') ? l$where : const {},
    ]);
  }
}

abstract class CopyWith$Input$BookUpdateToOneWithWhereWithoutBookRawInput<
    TRes> {
  factory CopyWith$Input$BookUpdateToOneWithWhereWithoutBookRawInput(
    Input$BookUpdateToOneWithWhereWithoutBookRawInput instance,
    TRes Function(Input$BookUpdateToOneWithWhereWithoutBookRawInput) then,
  ) = _CopyWithImpl$Input$BookUpdateToOneWithWhereWithoutBookRawInput;

  factory CopyWith$Input$BookUpdateToOneWithWhereWithoutBookRawInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$BookUpdateToOneWithWhereWithoutBookRawInput;

  TRes call({
    Input$BookUpdateWithoutBookRawInput? data,
    Input$BookWhereInput? where,
  });
  CopyWith$Input$BookUpdateWithoutBookRawInput<TRes> get data;
  CopyWith$Input$BookWhereInput<TRes> get where;
}

class _CopyWithImpl$Input$BookUpdateToOneWithWhereWithoutBookRawInput<TRes>
    implements
        CopyWith$Input$BookUpdateToOneWithWhereWithoutBookRawInput<TRes> {
  _CopyWithImpl$Input$BookUpdateToOneWithWhereWithoutBookRawInput(
    this._instance,
    this._then,
  );

  final Input$BookUpdateToOneWithWhereWithoutBookRawInput _instance;

  final TRes Function(Input$BookUpdateToOneWithWhereWithoutBookRawInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? data = _undefined,
    Object? where = _undefined,
  }) =>
      _then(Input$BookUpdateToOneWithWhereWithoutBookRawInput._({
        ..._instance._$data,
        if (data != _undefined && data != null)
          'data': (data as Input$BookUpdateWithoutBookRawInput),
        if (where != _undefined) 'where': (where as Input$BookWhereInput?),
      }));

  CopyWith$Input$BookUpdateWithoutBookRawInput<TRes> get data {
    final local$data = _instance.data;
    return CopyWith$Input$BookUpdateWithoutBookRawInput(
        local$data, (e) => call(data: e));
  }

  CopyWith$Input$BookWhereInput<TRes> get where {
    final local$where = _instance.where;
    return local$where == null
        ? CopyWith$Input$BookWhereInput.stub(_then(_instance))
        : CopyWith$Input$BookWhereInput(local$where, (e) => call(where: e));
  }
}

class _CopyWithStubImpl$Input$BookUpdateToOneWithWhereWithoutBookRawInput<TRes>
    implements
        CopyWith$Input$BookUpdateToOneWithWhereWithoutBookRawInput<TRes> {
  _CopyWithStubImpl$Input$BookUpdateToOneWithWhereWithoutBookRawInput(
      this._res);

  TRes _res;

  call({
    Input$BookUpdateWithoutBookRawInput? data,
    Input$BookWhereInput? where,
  }) =>
      _res;

  CopyWith$Input$BookUpdateWithoutBookRawInput<TRes> get data =>
      CopyWith$Input$BookUpdateWithoutBookRawInput.stub(_res);

  CopyWith$Input$BookWhereInput<TRes> get where =>
      CopyWith$Input$BookWhereInput.stub(_res);
}

class Input$BookUpdateWithoutBookEditedInput {
  factory Input$BookUpdateWithoutBookEditedInput({
    Input$BookRevisionUpdateOneWithoutBookRawNestedInput? bookRaw,
    Input$DateTimeFieldUpdateOperationsInput? createdAt,
    Input$StringFieldUpdateOperationsInput? title,
    Input$DateTimeFieldUpdateOperationsInput? updatedAt,
    Input$StringFieldUpdateOperationsInput? uuid,
  }) =>
      Input$BookUpdateWithoutBookEditedInput._({
        if (bookRaw != null) r'bookRaw': bookRaw,
        if (createdAt != null) r'createdAt': createdAt,
        if (title != null) r'title': title,
        if (updatedAt != null) r'updatedAt': updatedAt,
        if (uuid != null) r'uuid': uuid,
      });

  Input$BookUpdateWithoutBookEditedInput._(this._$data);

  factory Input$BookUpdateWithoutBookEditedInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('bookRaw')) {
      final l$bookRaw = data['bookRaw'];
      result$data['bookRaw'] = l$bookRaw == null
          ? null
          : Input$BookRevisionUpdateOneWithoutBookRawNestedInput.fromJson(
              (l$bookRaw as Map<String, dynamic>));
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : Input$DateTimeFieldUpdateOperationsInput.fromJson(
              (l$createdAt as Map<String, dynamic>));
    }
    if (data.containsKey('title')) {
      final l$title = data['title'];
      result$data['title'] = l$title == null
          ? null
          : Input$StringFieldUpdateOperationsInput.fromJson(
              (l$title as Map<String, dynamic>));
    }
    if (data.containsKey('updatedAt')) {
      final l$updatedAt = data['updatedAt'];
      result$data['updatedAt'] = l$updatedAt == null
          ? null
          : Input$DateTimeFieldUpdateOperationsInput.fromJson(
              (l$updatedAt as Map<String, dynamic>));
    }
    if (data.containsKey('uuid')) {
      final l$uuid = data['uuid'];
      result$data['uuid'] = l$uuid == null
          ? null
          : Input$StringFieldUpdateOperationsInput.fromJson(
              (l$uuid as Map<String, dynamic>));
    }
    return Input$BookUpdateWithoutBookEditedInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$BookRevisionUpdateOneWithoutBookRawNestedInput? get bookRaw =>
      (_$data['bookRaw']
          as Input$BookRevisionUpdateOneWithoutBookRawNestedInput?);

  Input$DateTimeFieldUpdateOperationsInput? get createdAt =>
      (_$data['createdAt'] as Input$DateTimeFieldUpdateOperationsInput?);

  Input$StringFieldUpdateOperationsInput? get title =>
      (_$data['title'] as Input$StringFieldUpdateOperationsInput?);

  Input$DateTimeFieldUpdateOperationsInput? get updatedAt =>
      (_$data['updatedAt'] as Input$DateTimeFieldUpdateOperationsInput?);

  Input$StringFieldUpdateOperationsInput? get uuid =>
      (_$data['uuid'] as Input$StringFieldUpdateOperationsInput?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('bookRaw')) {
      final l$bookRaw = bookRaw;
      result$data['bookRaw'] = l$bookRaw?.toJson();
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toJson();
    }
    if (_$data.containsKey('title')) {
      final l$title = title;
      result$data['title'] = l$title?.toJson();
    }
    if (_$data.containsKey('updatedAt')) {
      final l$updatedAt = updatedAt;
      result$data['updatedAt'] = l$updatedAt?.toJson();
    }
    if (_$data.containsKey('uuid')) {
      final l$uuid = uuid;
      result$data['uuid'] = l$uuid?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$BookUpdateWithoutBookEditedInput<
          Input$BookUpdateWithoutBookEditedInput>
      get copyWith => CopyWith$Input$BookUpdateWithoutBookEditedInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$BookUpdateWithoutBookEditedInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$bookRaw = bookRaw;
    final lOther$bookRaw = other.bookRaw;
    if (_$data.containsKey('bookRaw') != other._$data.containsKey('bookRaw')) {
      return false;
    }
    if (l$bookRaw != lOther$bookRaw) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$title = title;
    final lOther$title = other.title;
    if (_$data.containsKey('title') != other._$data.containsKey('title')) {
      return false;
    }
    if (l$title != lOther$title) {
      return false;
    }
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (_$data.containsKey('updatedAt') !=
        other._$data.containsKey('updatedAt')) {
      return false;
    }
    if (l$updatedAt != lOther$updatedAt) {
      return false;
    }
    final l$uuid = uuid;
    final lOther$uuid = other.uuid;
    if (_$data.containsKey('uuid') != other._$data.containsKey('uuid')) {
      return false;
    }
    if (l$uuid != lOther$uuid) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$bookRaw = bookRaw;
    final l$createdAt = createdAt;
    final l$title = title;
    final l$updatedAt = updatedAt;
    final l$uuid = uuid;
    return Object.hashAll([
      _$data.containsKey('bookRaw') ? l$bookRaw : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('title') ? l$title : const {},
      _$data.containsKey('updatedAt') ? l$updatedAt : const {},
      _$data.containsKey('uuid') ? l$uuid : const {},
    ]);
  }
}

abstract class CopyWith$Input$BookUpdateWithoutBookEditedInput<TRes> {
  factory CopyWith$Input$BookUpdateWithoutBookEditedInput(
    Input$BookUpdateWithoutBookEditedInput instance,
    TRes Function(Input$BookUpdateWithoutBookEditedInput) then,
  ) = _CopyWithImpl$Input$BookUpdateWithoutBookEditedInput;

  factory CopyWith$Input$BookUpdateWithoutBookEditedInput.stub(TRes res) =
      _CopyWithStubImpl$Input$BookUpdateWithoutBookEditedInput;

  TRes call({
    Input$BookRevisionUpdateOneWithoutBookRawNestedInput? bookRaw,
    Input$DateTimeFieldUpdateOperationsInput? createdAt,
    Input$StringFieldUpdateOperationsInput? title,
    Input$DateTimeFieldUpdateOperationsInput? updatedAt,
    Input$StringFieldUpdateOperationsInput? uuid,
  });
  CopyWith$Input$BookRevisionUpdateOneWithoutBookRawNestedInput<TRes>
      get bookRaw;
  CopyWith$Input$DateTimeFieldUpdateOperationsInput<TRes> get createdAt;
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get title;
  CopyWith$Input$DateTimeFieldUpdateOperationsInput<TRes> get updatedAt;
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get uuid;
}

class _CopyWithImpl$Input$BookUpdateWithoutBookEditedInput<TRes>
    implements CopyWith$Input$BookUpdateWithoutBookEditedInput<TRes> {
  _CopyWithImpl$Input$BookUpdateWithoutBookEditedInput(
    this._instance,
    this._then,
  );

  final Input$BookUpdateWithoutBookEditedInput _instance;

  final TRes Function(Input$BookUpdateWithoutBookEditedInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? bookRaw = _undefined,
    Object? createdAt = _undefined,
    Object? title = _undefined,
    Object? updatedAt = _undefined,
    Object? uuid = _undefined,
  }) =>
      _then(Input$BookUpdateWithoutBookEditedInput._({
        ..._instance._$data,
        if (bookRaw != _undefined)
          'bookRaw': (bookRaw
              as Input$BookRevisionUpdateOneWithoutBookRawNestedInput?),
        if (createdAt != _undefined)
          'createdAt': (createdAt as Input$DateTimeFieldUpdateOperationsInput?),
        if (title != _undefined)
          'title': (title as Input$StringFieldUpdateOperationsInput?),
        if (updatedAt != _undefined)
          'updatedAt': (updatedAt as Input$DateTimeFieldUpdateOperationsInput?),
        if (uuid != _undefined)
          'uuid': (uuid as Input$StringFieldUpdateOperationsInput?),
      }));

  CopyWith$Input$BookRevisionUpdateOneWithoutBookRawNestedInput<TRes>
      get bookRaw {
    final local$bookRaw = _instance.bookRaw;
    return local$bookRaw == null
        ? CopyWith$Input$BookRevisionUpdateOneWithoutBookRawNestedInput.stub(
            _then(_instance))
        : CopyWith$Input$BookRevisionUpdateOneWithoutBookRawNestedInput(
            local$bookRaw, (e) => call(bookRaw: e));
  }

  CopyWith$Input$DateTimeFieldUpdateOperationsInput<TRes> get createdAt {
    final local$createdAt = _instance.createdAt;
    return local$createdAt == null
        ? CopyWith$Input$DateTimeFieldUpdateOperationsInput.stub(
            _then(_instance))
        : CopyWith$Input$DateTimeFieldUpdateOperationsInput(
            local$createdAt, (e) => call(createdAt: e));
  }

  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get title {
    final local$title = _instance.title;
    return local$title == null
        ? CopyWith$Input$StringFieldUpdateOperationsInput.stub(_then(_instance))
        : CopyWith$Input$StringFieldUpdateOperationsInput(
            local$title, (e) => call(title: e));
  }

  CopyWith$Input$DateTimeFieldUpdateOperationsInput<TRes> get updatedAt {
    final local$updatedAt = _instance.updatedAt;
    return local$updatedAt == null
        ? CopyWith$Input$DateTimeFieldUpdateOperationsInput.stub(
            _then(_instance))
        : CopyWith$Input$DateTimeFieldUpdateOperationsInput(
            local$updatedAt, (e) => call(updatedAt: e));
  }

  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get uuid {
    final local$uuid = _instance.uuid;
    return local$uuid == null
        ? CopyWith$Input$StringFieldUpdateOperationsInput.stub(_then(_instance))
        : CopyWith$Input$StringFieldUpdateOperationsInput(
            local$uuid, (e) => call(uuid: e));
  }
}

class _CopyWithStubImpl$Input$BookUpdateWithoutBookEditedInput<TRes>
    implements CopyWith$Input$BookUpdateWithoutBookEditedInput<TRes> {
  _CopyWithStubImpl$Input$BookUpdateWithoutBookEditedInput(this._res);

  TRes _res;

  call({
    Input$BookRevisionUpdateOneWithoutBookRawNestedInput? bookRaw,
    Input$DateTimeFieldUpdateOperationsInput? createdAt,
    Input$StringFieldUpdateOperationsInput? title,
    Input$DateTimeFieldUpdateOperationsInput? updatedAt,
    Input$StringFieldUpdateOperationsInput? uuid,
  }) =>
      _res;

  CopyWith$Input$BookRevisionUpdateOneWithoutBookRawNestedInput<TRes>
      get bookRaw =>
          CopyWith$Input$BookRevisionUpdateOneWithoutBookRawNestedInput.stub(
              _res);

  CopyWith$Input$DateTimeFieldUpdateOperationsInput<TRes> get createdAt =>
      CopyWith$Input$DateTimeFieldUpdateOperationsInput.stub(_res);

  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get title =>
      CopyWith$Input$StringFieldUpdateOperationsInput.stub(_res);

  CopyWith$Input$DateTimeFieldUpdateOperationsInput<TRes> get updatedAt =>
      CopyWith$Input$DateTimeFieldUpdateOperationsInput.stub(_res);

  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get uuid =>
      CopyWith$Input$StringFieldUpdateOperationsInput.stub(_res);
}

class Input$BookUpdateWithoutBookRawInput {
  factory Input$BookUpdateWithoutBookRawInput({
    Input$BookRevisionUpdateOneWithoutBookEditedNestedInput? bookEdited,
    Input$DateTimeFieldUpdateOperationsInput? createdAt,
    Input$StringFieldUpdateOperationsInput? title,
    Input$DateTimeFieldUpdateOperationsInput? updatedAt,
    Input$StringFieldUpdateOperationsInput? uuid,
  }) =>
      Input$BookUpdateWithoutBookRawInput._({
        if (bookEdited != null) r'bookEdited': bookEdited,
        if (createdAt != null) r'createdAt': createdAt,
        if (title != null) r'title': title,
        if (updatedAt != null) r'updatedAt': updatedAt,
        if (uuid != null) r'uuid': uuid,
      });

  Input$BookUpdateWithoutBookRawInput._(this._$data);

  factory Input$BookUpdateWithoutBookRawInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('bookEdited')) {
      final l$bookEdited = data['bookEdited'];
      result$data['bookEdited'] = l$bookEdited == null
          ? null
          : Input$BookRevisionUpdateOneWithoutBookEditedNestedInput.fromJson(
              (l$bookEdited as Map<String, dynamic>));
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : Input$DateTimeFieldUpdateOperationsInput.fromJson(
              (l$createdAt as Map<String, dynamic>));
    }
    if (data.containsKey('title')) {
      final l$title = data['title'];
      result$data['title'] = l$title == null
          ? null
          : Input$StringFieldUpdateOperationsInput.fromJson(
              (l$title as Map<String, dynamic>));
    }
    if (data.containsKey('updatedAt')) {
      final l$updatedAt = data['updatedAt'];
      result$data['updatedAt'] = l$updatedAt == null
          ? null
          : Input$DateTimeFieldUpdateOperationsInput.fromJson(
              (l$updatedAt as Map<String, dynamic>));
    }
    if (data.containsKey('uuid')) {
      final l$uuid = data['uuid'];
      result$data['uuid'] = l$uuid == null
          ? null
          : Input$StringFieldUpdateOperationsInput.fromJson(
              (l$uuid as Map<String, dynamic>));
    }
    return Input$BookUpdateWithoutBookRawInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$BookRevisionUpdateOneWithoutBookEditedNestedInput? get bookEdited =>
      (_$data['bookEdited']
          as Input$BookRevisionUpdateOneWithoutBookEditedNestedInput?);

  Input$DateTimeFieldUpdateOperationsInput? get createdAt =>
      (_$data['createdAt'] as Input$DateTimeFieldUpdateOperationsInput?);

  Input$StringFieldUpdateOperationsInput? get title =>
      (_$data['title'] as Input$StringFieldUpdateOperationsInput?);

  Input$DateTimeFieldUpdateOperationsInput? get updatedAt =>
      (_$data['updatedAt'] as Input$DateTimeFieldUpdateOperationsInput?);

  Input$StringFieldUpdateOperationsInput? get uuid =>
      (_$data['uuid'] as Input$StringFieldUpdateOperationsInput?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('bookEdited')) {
      final l$bookEdited = bookEdited;
      result$data['bookEdited'] = l$bookEdited?.toJson();
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toJson();
    }
    if (_$data.containsKey('title')) {
      final l$title = title;
      result$data['title'] = l$title?.toJson();
    }
    if (_$data.containsKey('updatedAt')) {
      final l$updatedAt = updatedAt;
      result$data['updatedAt'] = l$updatedAt?.toJson();
    }
    if (_$data.containsKey('uuid')) {
      final l$uuid = uuid;
      result$data['uuid'] = l$uuid?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$BookUpdateWithoutBookRawInput<
          Input$BookUpdateWithoutBookRawInput>
      get copyWith => CopyWith$Input$BookUpdateWithoutBookRawInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$BookUpdateWithoutBookRawInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$bookEdited = bookEdited;
    final lOther$bookEdited = other.bookEdited;
    if (_$data.containsKey('bookEdited') !=
        other._$data.containsKey('bookEdited')) {
      return false;
    }
    if (l$bookEdited != lOther$bookEdited) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$title = title;
    final lOther$title = other.title;
    if (_$data.containsKey('title') != other._$data.containsKey('title')) {
      return false;
    }
    if (l$title != lOther$title) {
      return false;
    }
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (_$data.containsKey('updatedAt') !=
        other._$data.containsKey('updatedAt')) {
      return false;
    }
    if (l$updatedAt != lOther$updatedAt) {
      return false;
    }
    final l$uuid = uuid;
    final lOther$uuid = other.uuid;
    if (_$data.containsKey('uuid') != other._$data.containsKey('uuid')) {
      return false;
    }
    if (l$uuid != lOther$uuid) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$bookEdited = bookEdited;
    final l$createdAt = createdAt;
    final l$title = title;
    final l$updatedAt = updatedAt;
    final l$uuid = uuid;
    return Object.hashAll([
      _$data.containsKey('bookEdited') ? l$bookEdited : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('title') ? l$title : const {},
      _$data.containsKey('updatedAt') ? l$updatedAt : const {},
      _$data.containsKey('uuid') ? l$uuid : const {},
    ]);
  }
}

abstract class CopyWith$Input$BookUpdateWithoutBookRawInput<TRes> {
  factory CopyWith$Input$BookUpdateWithoutBookRawInput(
    Input$BookUpdateWithoutBookRawInput instance,
    TRes Function(Input$BookUpdateWithoutBookRawInput) then,
  ) = _CopyWithImpl$Input$BookUpdateWithoutBookRawInput;

  factory CopyWith$Input$BookUpdateWithoutBookRawInput.stub(TRes res) =
      _CopyWithStubImpl$Input$BookUpdateWithoutBookRawInput;

  TRes call({
    Input$BookRevisionUpdateOneWithoutBookEditedNestedInput? bookEdited,
    Input$DateTimeFieldUpdateOperationsInput? createdAt,
    Input$StringFieldUpdateOperationsInput? title,
    Input$DateTimeFieldUpdateOperationsInput? updatedAt,
    Input$StringFieldUpdateOperationsInput? uuid,
  });
  CopyWith$Input$BookRevisionUpdateOneWithoutBookEditedNestedInput<TRes>
      get bookEdited;
  CopyWith$Input$DateTimeFieldUpdateOperationsInput<TRes> get createdAt;
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get title;
  CopyWith$Input$DateTimeFieldUpdateOperationsInput<TRes> get updatedAt;
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get uuid;
}

class _CopyWithImpl$Input$BookUpdateWithoutBookRawInput<TRes>
    implements CopyWith$Input$BookUpdateWithoutBookRawInput<TRes> {
  _CopyWithImpl$Input$BookUpdateWithoutBookRawInput(
    this._instance,
    this._then,
  );

  final Input$BookUpdateWithoutBookRawInput _instance;

  final TRes Function(Input$BookUpdateWithoutBookRawInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? bookEdited = _undefined,
    Object? createdAt = _undefined,
    Object? title = _undefined,
    Object? updatedAt = _undefined,
    Object? uuid = _undefined,
  }) =>
      _then(Input$BookUpdateWithoutBookRawInput._({
        ..._instance._$data,
        if (bookEdited != _undefined)
          'bookEdited': (bookEdited
              as Input$BookRevisionUpdateOneWithoutBookEditedNestedInput?),
        if (createdAt != _undefined)
          'createdAt': (createdAt as Input$DateTimeFieldUpdateOperationsInput?),
        if (title != _undefined)
          'title': (title as Input$StringFieldUpdateOperationsInput?),
        if (updatedAt != _undefined)
          'updatedAt': (updatedAt as Input$DateTimeFieldUpdateOperationsInput?),
        if (uuid != _undefined)
          'uuid': (uuid as Input$StringFieldUpdateOperationsInput?),
      }));

  CopyWith$Input$BookRevisionUpdateOneWithoutBookEditedNestedInput<TRes>
      get bookEdited {
    final local$bookEdited = _instance.bookEdited;
    return local$bookEdited == null
        ? CopyWith$Input$BookRevisionUpdateOneWithoutBookEditedNestedInput.stub(
            _then(_instance))
        : CopyWith$Input$BookRevisionUpdateOneWithoutBookEditedNestedInput(
            local$bookEdited, (e) => call(bookEdited: e));
  }

  CopyWith$Input$DateTimeFieldUpdateOperationsInput<TRes> get createdAt {
    final local$createdAt = _instance.createdAt;
    return local$createdAt == null
        ? CopyWith$Input$DateTimeFieldUpdateOperationsInput.stub(
            _then(_instance))
        : CopyWith$Input$DateTimeFieldUpdateOperationsInput(
            local$createdAt, (e) => call(createdAt: e));
  }

  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get title {
    final local$title = _instance.title;
    return local$title == null
        ? CopyWith$Input$StringFieldUpdateOperationsInput.stub(_then(_instance))
        : CopyWith$Input$StringFieldUpdateOperationsInput(
            local$title, (e) => call(title: e));
  }

  CopyWith$Input$DateTimeFieldUpdateOperationsInput<TRes> get updatedAt {
    final local$updatedAt = _instance.updatedAt;
    return local$updatedAt == null
        ? CopyWith$Input$DateTimeFieldUpdateOperationsInput.stub(
            _then(_instance))
        : CopyWith$Input$DateTimeFieldUpdateOperationsInput(
            local$updatedAt, (e) => call(updatedAt: e));
  }

  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get uuid {
    final local$uuid = _instance.uuid;
    return local$uuid == null
        ? CopyWith$Input$StringFieldUpdateOperationsInput.stub(_then(_instance))
        : CopyWith$Input$StringFieldUpdateOperationsInput(
            local$uuid, (e) => call(uuid: e));
  }
}

class _CopyWithStubImpl$Input$BookUpdateWithoutBookRawInput<TRes>
    implements CopyWith$Input$BookUpdateWithoutBookRawInput<TRes> {
  _CopyWithStubImpl$Input$BookUpdateWithoutBookRawInput(this._res);

  TRes _res;

  call({
    Input$BookRevisionUpdateOneWithoutBookEditedNestedInput? bookEdited,
    Input$DateTimeFieldUpdateOperationsInput? createdAt,
    Input$StringFieldUpdateOperationsInput? title,
    Input$DateTimeFieldUpdateOperationsInput? updatedAt,
    Input$StringFieldUpdateOperationsInput? uuid,
  }) =>
      _res;

  CopyWith$Input$BookRevisionUpdateOneWithoutBookEditedNestedInput<TRes>
      get bookEdited =>
          CopyWith$Input$BookRevisionUpdateOneWithoutBookEditedNestedInput.stub(
              _res);

  CopyWith$Input$DateTimeFieldUpdateOperationsInput<TRes> get createdAt =>
      CopyWith$Input$DateTimeFieldUpdateOperationsInput.stub(_res);

  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get title =>
      CopyWith$Input$StringFieldUpdateOperationsInput.stub(_res);

  CopyWith$Input$DateTimeFieldUpdateOperationsInput<TRes> get updatedAt =>
      CopyWith$Input$DateTimeFieldUpdateOperationsInput.stub(_res);

  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get uuid =>
      CopyWith$Input$StringFieldUpdateOperationsInput.stub(_res);
}

class Input$BookUpsertWithoutBookEditedInput {
  factory Input$BookUpsertWithoutBookEditedInput({
    required Input$BookCreateWithoutBookEditedInput create,
    required Input$BookUpdateWithoutBookEditedInput update,
    Input$BookWhereInput? where,
  }) =>
      Input$BookUpsertWithoutBookEditedInput._({
        r'create': create,
        r'update': update,
        if (where != null) r'where': where,
      });

  Input$BookUpsertWithoutBookEditedInput._(this._$data);

  factory Input$BookUpsertWithoutBookEditedInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$create = data['create'];
    result$data['create'] = Input$BookCreateWithoutBookEditedInput.fromJson(
        (l$create as Map<String, dynamic>));
    final l$update = data['update'];
    result$data['update'] = Input$BookUpdateWithoutBookEditedInput.fromJson(
        (l$update as Map<String, dynamic>));
    if (data.containsKey('where')) {
      final l$where = data['where'];
      result$data['where'] = l$where == null
          ? null
          : Input$BookWhereInput.fromJson((l$where as Map<String, dynamic>));
    }
    return Input$BookUpsertWithoutBookEditedInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$BookCreateWithoutBookEditedInput get create =>
      (_$data['create'] as Input$BookCreateWithoutBookEditedInput);

  Input$BookUpdateWithoutBookEditedInput get update =>
      (_$data['update'] as Input$BookUpdateWithoutBookEditedInput);

  Input$BookWhereInput? get where => (_$data['where'] as Input$BookWhereInput?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$create = create;
    result$data['create'] = l$create.toJson();
    final l$update = update;
    result$data['update'] = l$update.toJson();
    if (_$data.containsKey('where')) {
      final l$where = where;
      result$data['where'] = l$where?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$BookUpsertWithoutBookEditedInput<
          Input$BookUpsertWithoutBookEditedInput>
      get copyWith => CopyWith$Input$BookUpsertWithoutBookEditedInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$BookUpsertWithoutBookEditedInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != lOther$create) {
      return false;
    }
    final l$update = update;
    final lOther$update = other.update;
    if (l$update != lOther$update) {
      return false;
    }
    final l$where = where;
    final lOther$where = other.where;
    if (_$data.containsKey('where') != other._$data.containsKey('where')) {
      return false;
    }
    if (l$where != lOther$where) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$create = create;
    final l$update = update;
    final l$where = where;
    return Object.hashAll([
      l$create,
      l$update,
      _$data.containsKey('where') ? l$where : const {},
    ]);
  }
}

abstract class CopyWith$Input$BookUpsertWithoutBookEditedInput<TRes> {
  factory CopyWith$Input$BookUpsertWithoutBookEditedInput(
    Input$BookUpsertWithoutBookEditedInput instance,
    TRes Function(Input$BookUpsertWithoutBookEditedInput) then,
  ) = _CopyWithImpl$Input$BookUpsertWithoutBookEditedInput;

  factory CopyWith$Input$BookUpsertWithoutBookEditedInput.stub(TRes res) =
      _CopyWithStubImpl$Input$BookUpsertWithoutBookEditedInput;

  TRes call({
    Input$BookCreateWithoutBookEditedInput? create,
    Input$BookUpdateWithoutBookEditedInput? update,
    Input$BookWhereInput? where,
  });
  CopyWith$Input$BookCreateWithoutBookEditedInput<TRes> get create;
  CopyWith$Input$BookUpdateWithoutBookEditedInput<TRes> get update;
  CopyWith$Input$BookWhereInput<TRes> get where;
}

class _CopyWithImpl$Input$BookUpsertWithoutBookEditedInput<TRes>
    implements CopyWith$Input$BookUpsertWithoutBookEditedInput<TRes> {
  _CopyWithImpl$Input$BookUpsertWithoutBookEditedInput(
    this._instance,
    this._then,
  );

  final Input$BookUpsertWithoutBookEditedInput _instance;

  final TRes Function(Input$BookUpsertWithoutBookEditedInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? create = _undefined,
    Object? update = _undefined,
    Object? where = _undefined,
  }) =>
      _then(Input$BookUpsertWithoutBookEditedInput._({
        ..._instance._$data,
        if (create != _undefined && create != null)
          'create': (create as Input$BookCreateWithoutBookEditedInput),
        if (update != _undefined && update != null)
          'update': (update as Input$BookUpdateWithoutBookEditedInput),
        if (where != _undefined) 'where': (where as Input$BookWhereInput?),
      }));

  CopyWith$Input$BookCreateWithoutBookEditedInput<TRes> get create {
    final local$create = _instance.create;
    return CopyWith$Input$BookCreateWithoutBookEditedInput(
        local$create, (e) => call(create: e));
  }

  CopyWith$Input$BookUpdateWithoutBookEditedInput<TRes> get update {
    final local$update = _instance.update;
    return CopyWith$Input$BookUpdateWithoutBookEditedInput(
        local$update, (e) => call(update: e));
  }

  CopyWith$Input$BookWhereInput<TRes> get where {
    final local$where = _instance.where;
    return local$where == null
        ? CopyWith$Input$BookWhereInput.stub(_then(_instance))
        : CopyWith$Input$BookWhereInput(local$where, (e) => call(where: e));
  }
}

class _CopyWithStubImpl$Input$BookUpsertWithoutBookEditedInput<TRes>
    implements CopyWith$Input$BookUpsertWithoutBookEditedInput<TRes> {
  _CopyWithStubImpl$Input$BookUpsertWithoutBookEditedInput(this._res);

  TRes _res;

  call({
    Input$BookCreateWithoutBookEditedInput? create,
    Input$BookUpdateWithoutBookEditedInput? update,
    Input$BookWhereInput? where,
  }) =>
      _res;

  CopyWith$Input$BookCreateWithoutBookEditedInput<TRes> get create =>
      CopyWith$Input$BookCreateWithoutBookEditedInput.stub(_res);

  CopyWith$Input$BookUpdateWithoutBookEditedInput<TRes> get update =>
      CopyWith$Input$BookUpdateWithoutBookEditedInput.stub(_res);

  CopyWith$Input$BookWhereInput<TRes> get where =>
      CopyWith$Input$BookWhereInput.stub(_res);
}

class Input$BookUpsertWithoutBookRawInput {
  factory Input$BookUpsertWithoutBookRawInput({
    required Input$BookCreateWithoutBookRawInput create,
    required Input$BookUpdateWithoutBookRawInput update,
    Input$BookWhereInput? where,
  }) =>
      Input$BookUpsertWithoutBookRawInput._({
        r'create': create,
        r'update': update,
        if (where != null) r'where': where,
      });

  Input$BookUpsertWithoutBookRawInput._(this._$data);

  factory Input$BookUpsertWithoutBookRawInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$create = data['create'];
    result$data['create'] = Input$BookCreateWithoutBookRawInput.fromJson(
        (l$create as Map<String, dynamic>));
    final l$update = data['update'];
    result$data['update'] = Input$BookUpdateWithoutBookRawInput.fromJson(
        (l$update as Map<String, dynamic>));
    if (data.containsKey('where')) {
      final l$where = data['where'];
      result$data['where'] = l$where == null
          ? null
          : Input$BookWhereInput.fromJson((l$where as Map<String, dynamic>));
    }
    return Input$BookUpsertWithoutBookRawInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$BookCreateWithoutBookRawInput get create =>
      (_$data['create'] as Input$BookCreateWithoutBookRawInput);

  Input$BookUpdateWithoutBookRawInput get update =>
      (_$data['update'] as Input$BookUpdateWithoutBookRawInput);

  Input$BookWhereInput? get where => (_$data['where'] as Input$BookWhereInput?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$create = create;
    result$data['create'] = l$create.toJson();
    final l$update = update;
    result$data['update'] = l$update.toJson();
    if (_$data.containsKey('where')) {
      final l$where = where;
      result$data['where'] = l$where?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$BookUpsertWithoutBookRawInput<
          Input$BookUpsertWithoutBookRawInput>
      get copyWith => CopyWith$Input$BookUpsertWithoutBookRawInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$BookUpsertWithoutBookRawInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != lOther$create) {
      return false;
    }
    final l$update = update;
    final lOther$update = other.update;
    if (l$update != lOther$update) {
      return false;
    }
    final l$where = where;
    final lOther$where = other.where;
    if (_$data.containsKey('where') != other._$data.containsKey('where')) {
      return false;
    }
    if (l$where != lOther$where) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$create = create;
    final l$update = update;
    final l$where = where;
    return Object.hashAll([
      l$create,
      l$update,
      _$data.containsKey('where') ? l$where : const {},
    ]);
  }
}

abstract class CopyWith$Input$BookUpsertWithoutBookRawInput<TRes> {
  factory CopyWith$Input$BookUpsertWithoutBookRawInput(
    Input$BookUpsertWithoutBookRawInput instance,
    TRes Function(Input$BookUpsertWithoutBookRawInput) then,
  ) = _CopyWithImpl$Input$BookUpsertWithoutBookRawInput;

  factory CopyWith$Input$BookUpsertWithoutBookRawInput.stub(TRes res) =
      _CopyWithStubImpl$Input$BookUpsertWithoutBookRawInput;

  TRes call({
    Input$BookCreateWithoutBookRawInput? create,
    Input$BookUpdateWithoutBookRawInput? update,
    Input$BookWhereInput? where,
  });
  CopyWith$Input$BookCreateWithoutBookRawInput<TRes> get create;
  CopyWith$Input$BookUpdateWithoutBookRawInput<TRes> get update;
  CopyWith$Input$BookWhereInput<TRes> get where;
}

class _CopyWithImpl$Input$BookUpsertWithoutBookRawInput<TRes>
    implements CopyWith$Input$BookUpsertWithoutBookRawInput<TRes> {
  _CopyWithImpl$Input$BookUpsertWithoutBookRawInput(
    this._instance,
    this._then,
  );

  final Input$BookUpsertWithoutBookRawInput _instance;

  final TRes Function(Input$BookUpsertWithoutBookRawInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? create = _undefined,
    Object? update = _undefined,
    Object? where = _undefined,
  }) =>
      _then(Input$BookUpsertWithoutBookRawInput._({
        ..._instance._$data,
        if (create != _undefined && create != null)
          'create': (create as Input$BookCreateWithoutBookRawInput),
        if (update != _undefined && update != null)
          'update': (update as Input$BookUpdateWithoutBookRawInput),
        if (where != _undefined) 'where': (where as Input$BookWhereInput?),
      }));

  CopyWith$Input$BookCreateWithoutBookRawInput<TRes> get create {
    final local$create = _instance.create;
    return CopyWith$Input$BookCreateWithoutBookRawInput(
        local$create, (e) => call(create: e));
  }

  CopyWith$Input$BookUpdateWithoutBookRawInput<TRes> get update {
    final local$update = _instance.update;
    return CopyWith$Input$BookUpdateWithoutBookRawInput(
        local$update, (e) => call(update: e));
  }

  CopyWith$Input$BookWhereInput<TRes> get where {
    final local$where = _instance.where;
    return local$where == null
        ? CopyWith$Input$BookWhereInput.stub(_then(_instance))
        : CopyWith$Input$BookWhereInput(local$where, (e) => call(where: e));
  }
}

class _CopyWithStubImpl$Input$BookUpsertWithoutBookRawInput<TRes>
    implements CopyWith$Input$BookUpsertWithoutBookRawInput<TRes> {
  _CopyWithStubImpl$Input$BookUpsertWithoutBookRawInput(this._res);

  TRes _res;

  call({
    Input$BookCreateWithoutBookRawInput? create,
    Input$BookUpdateWithoutBookRawInput? update,
    Input$BookWhereInput? where,
  }) =>
      _res;

  CopyWith$Input$BookCreateWithoutBookRawInput<TRes> get create =>
      CopyWith$Input$BookCreateWithoutBookRawInput.stub(_res);

  CopyWith$Input$BookUpdateWithoutBookRawInput<TRes> get update =>
      CopyWith$Input$BookUpdateWithoutBookRawInput.stub(_res);

  CopyWith$Input$BookWhereInput<TRes> get where =>
      CopyWith$Input$BookWhereInput.stub(_res);
}

class Input$BookWhereInput {
  factory Input$BookWhereInput({
    List<Input$BookWhereInput>? AND,
    List<Input$BookWhereInput>? NOT,
    List<Input$BookWhereInput>? OR,
    Input$BookRevisionNullableRelationFilter? bookEdited,
    Input$BookRevisionNullableRelationFilter? bookRaw,
    Input$DateTimeFilter? createdAt,
    Input$StringFilter? title,
    Input$DateTimeFilter? updatedAt,
    Input$UuidFilter? uuid,
  }) =>
      Input$BookWhereInput._({
        if (AND != null) r'AND': AND,
        if (NOT != null) r'NOT': NOT,
        if (OR != null) r'OR': OR,
        if (bookEdited != null) r'bookEdited': bookEdited,
        if (bookRaw != null) r'bookRaw': bookRaw,
        if (createdAt != null) r'createdAt': createdAt,
        if (title != null) r'title': title,
        if (updatedAt != null) r'updatedAt': updatedAt,
        if (uuid != null) r'uuid': uuid,
      });

  Input$BookWhereInput._(this._$data);

  factory Input$BookWhereInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('AND')) {
      final l$AND = data['AND'];
      result$data['AND'] = (l$AND as List<dynamic>?)
          ?.map(
              (e) => Input$BookWhereInput.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('NOT')) {
      final l$NOT = data['NOT'];
      result$data['NOT'] = (l$NOT as List<dynamic>?)
          ?.map(
              (e) => Input$BookWhereInput.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('OR')) {
      final l$OR = data['OR'];
      result$data['OR'] = (l$OR as List<dynamic>?)
          ?.map(
              (e) => Input$BookWhereInput.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('bookEdited')) {
      final l$bookEdited = data['bookEdited'];
      result$data['bookEdited'] = l$bookEdited == null
          ? null
          : Input$BookRevisionNullableRelationFilter.fromJson(
              (l$bookEdited as Map<String, dynamic>));
    }
    if (data.containsKey('bookRaw')) {
      final l$bookRaw = data['bookRaw'];
      result$data['bookRaw'] = l$bookRaw == null
          ? null
          : Input$BookRevisionNullableRelationFilter.fromJson(
              (l$bookRaw as Map<String, dynamic>));
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : Input$DateTimeFilter.fromJson(
              (l$createdAt as Map<String, dynamic>));
    }
    if (data.containsKey('title')) {
      final l$title = data['title'];
      result$data['title'] = l$title == null
          ? null
          : Input$StringFilter.fromJson((l$title as Map<String, dynamic>));
    }
    if (data.containsKey('updatedAt')) {
      final l$updatedAt = data['updatedAt'];
      result$data['updatedAt'] = l$updatedAt == null
          ? null
          : Input$DateTimeFilter.fromJson(
              (l$updatedAt as Map<String, dynamic>));
    }
    if (data.containsKey('uuid')) {
      final l$uuid = data['uuid'];
      result$data['uuid'] = l$uuid == null
          ? null
          : Input$UuidFilter.fromJson((l$uuid as Map<String, dynamic>));
    }
    return Input$BookWhereInput._(result$data);
  }

  Map<String, dynamic> _$data;

  List<Input$BookWhereInput>? get AND =>
      (_$data['AND'] as List<Input$BookWhereInput>?);

  List<Input$BookWhereInput>? get NOT =>
      (_$data['NOT'] as List<Input$BookWhereInput>?);

  List<Input$BookWhereInput>? get OR =>
      (_$data['OR'] as List<Input$BookWhereInput>?);

  Input$BookRevisionNullableRelationFilter? get bookEdited =>
      (_$data['bookEdited'] as Input$BookRevisionNullableRelationFilter?);

  Input$BookRevisionNullableRelationFilter? get bookRaw =>
      (_$data['bookRaw'] as Input$BookRevisionNullableRelationFilter?);

  Input$DateTimeFilter? get createdAt =>
      (_$data['createdAt'] as Input$DateTimeFilter?);

  Input$StringFilter? get title => (_$data['title'] as Input$StringFilter?);

  Input$DateTimeFilter? get updatedAt =>
      (_$data['updatedAt'] as Input$DateTimeFilter?);

  Input$UuidFilter? get uuid => (_$data['uuid'] as Input$UuidFilter?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('AND')) {
      final l$AND = AND;
      result$data['AND'] = l$AND?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('NOT')) {
      final l$NOT = NOT;
      result$data['NOT'] = l$NOT?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('OR')) {
      final l$OR = OR;
      result$data['OR'] = l$OR?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('bookEdited')) {
      final l$bookEdited = bookEdited;
      result$data['bookEdited'] = l$bookEdited?.toJson();
    }
    if (_$data.containsKey('bookRaw')) {
      final l$bookRaw = bookRaw;
      result$data['bookRaw'] = l$bookRaw?.toJson();
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toJson();
    }
    if (_$data.containsKey('title')) {
      final l$title = title;
      result$data['title'] = l$title?.toJson();
    }
    if (_$data.containsKey('updatedAt')) {
      final l$updatedAt = updatedAt;
      result$data['updatedAt'] = l$updatedAt?.toJson();
    }
    if (_$data.containsKey('uuid')) {
      final l$uuid = uuid;
      result$data['uuid'] = l$uuid?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$BookWhereInput<Input$BookWhereInput> get copyWith =>
      CopyWith$Input$BookWhereInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$BookWhereInput) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$AND = AND;
    final lOther$AND = other.AND;
    if (_$data.containsKey('AND') != other._$data.containsKey('AND')) {
      return false;
    }
    if (l$AND != null && lOther$AND != null) {
      if (l$AND.length != lOther$AND.length) {
        return false;
      }
      for (int i = 0; i < l$AND.length; i++) {
        final l$AND$entry = l$AND[i];
        final lOther$AND$entry = lOther$AND[i];
        if (l$AND$entry != lOther$AND$entry) {
          return false;
        }
      }
    } else if (l$AND != lOther$AND) {
      return false;
    }
    final l$NOT = NOT;
    final lOther$NOT = other.NOT;
    if (_$data.containsKey('NOT') != other._$data.containsKey('NOT')) {
      return false;
    }
    if (l$NOT != null && lOther$NOT != null) {
      if (l$NOT.length != lOther$NOT.length) {
        return false;
      }
      for (int i = 0; i < l$NOT.length; i++) {
        final l$NOT$entry = l$NOT[i];
        final lOther$NOT$entry = lOther$NOT[i];
        if (l$NOT$entry != lOther$NOT$entry) {
          return false;
        }
      }
    } else if (l$NOT != lOther$NOT) {
      return false;
    }
    final l$OR = OR;
    final lOther$OR = other.OR;
    if (_$data.containsKey('OR') != other._$data.containsKey('OR')) {
      return false;
    }
    if (l$OR != null && lOther$OR != null) {
      if (l$OR.length != lOther$OR.length) {
        return false;
      }
      for (int i = 0; i < l$OR.length; i++) {
        final l$OR$entry = l$OR[i];
        final lOther$OR$entry = lOther$OR[i];
        if (l$OR$entry != lOther$OR$entry) {
          return false;
        }
      }
    } else if (l$OR != lOther$OR) {
      return false;
    }
    final l$bookEdited = bookEdited;
    final lOther$bookEdited = other.bookEdited;
    if (_$data.containsKey('bookEdited') !=
        other._$data.containsKey('bookEdited')) {
      return false;
    }
    if (l$bookEdited != lOther$bookEdited) {
      return false;
    }
    final l$bookRaw = bookRaw;
    final lOther$bookRaw = other.bookRaw;
    if (_$data.containsKey('bookRaw') != other._$data.containsKey('bookRaw')) {
      return false;
    }
    if (l$bookRaw != lOther$bookRaw) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$title = title;
    final lOther$title = other.title;
    if (_$data.containsKey('title') != other._$data.containsKey('title')) {
      return false;
    }
    if (l$title != lOther$title) {
      return false;
    }
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (_$data.containsKey('updatedAt') !=
        other._$data.containsKey('updatedAt')) {
      return false;
    }
    if (l$updatedAt != lOther$updatedAt) {
      return false;
    }
    final l$uuid = uuid;
    final lOther$uuid = other.uuid;
    if (_$data.containsKey('uuid') != other._$data.containsKey('uuid')) {
      return false;
    }
    if (l$uuid != lOther$uuid) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$AND = AND;
    final l$NOT = NOT;
    final l$OR = OR;
    final l$bookEdited = bookEdited;
    final l$bookRaw = bookRaw;
    final l$createdAt = createdAt;
    final l$title = title;
    final l$updatedAt = updatedAt;
    final l$uuid = uuid;
    return Object.hashAll([
      _$data.containsKey('AND')
          ? l$AND == null
              ? null
              : Object.hashAll(l$AND.map((v) => v))
          : const {},
      _$data.containsKey('NOT')
          ? l$NOT == null
              ? null
              : Object.hashAll(l$NOT.map((v) => v))
          : const {},
      _$data.containsKey('OR')
          ? l$OR == null
              ? null
              : Object.hashAll(l$OR.map((v) => v))
          : const {},
      _$data.containsKey('bookEdited') ? l$bookEdited : const {},
      _$data.containsKey('bookRaw') ? l$bookRaw : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('title') ? l$title : const {},
      _$data.containsKey('updatedAt') ? l$updatedAt : const {},
      _$data.containsKey('uuid') ? l$uuid : const {},
    ]);
  }
}

abstract class CopyWith$Input$BookWhereInput<TRes> {
  factory CopyWith$Input$BookWhereInput(
    Input$BookWhereInput instance,
    TRes Function(Input$BookWhereInput) then,
  ) = _CopyWithImpl$Input$BookWhereInput;

  factory CopyWith$Input$BookWhereInput.stub(TRes res) =
      _CopyWithStubImpl$Input$BookWhereInput;

  TRes call({
    List<Input$BookWhereInput>? AND,
    List<Input$BookWhereInput>? NOT,
    List<Input$BookWhereInput>? OR,
    Input$BookRevisionNullableRelationFilter? bookEdited,
    Input$BookRevisionNullableRelationFilter? bookRaw,
    Input$DateTimeFilter? createdAt,
    Input$StringFilter? title,
    Input$DateTimeFilter? updatedAt,
    Input$UuidFilter? uuid,
  });
  TRes AND(
      Iterable<Input$BookWhereInput>? Function(
              Iterable<CopyWith$Input$BookWhereInput<Input$BookWhereInput>>?)
          _fn);
  TRes NOT(
      Iterable<Input$BookWhereInput>? Function(
              Iterable<CopyWith$Input$BookWhereInput<Input$BookWhereInput>>?)
          _fn);
  TRes OR(
      Iterable<Input$BookWhereInput>? Function(
              Iterable<CopyWith$Input$BookWhereInput<Input$BookWhereInput>>?)
          _fn);
  CopyWith$Input$BookRevisionNullableRelationFilter<TRes> get bookEdited;
  CopyWith$Input$BookRevisionNullableRelationFilter<TRes> get bookRaw;
  CopyWith$Input$DateTimeFilter<TRes> get createdAt;
  CopyWith$Input$StringFilter<TRes> get title;
  CopyWith$Input$DateTimeFilter<TRes> get updatedAt;
  CopyWith$Input$UuidFilter<TRes> get uuid;
}

class _CopyWithImpl$Input$BookWhereInput<TRes>
    implements CopyWith$Input$BookWhereInput<TRes> {
  _CopyWithImpl$Input$BookWhereInput(
    this._instance,
    this._then,
  );

  final Input$BookWhereInput _instance;

  final TRes Function(Input$BookWhereInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? AND = _undefined,
    Object? NOT = _undefined,
    Object? OR = _undefined,
    Object? bookEdited = _undefined,
    Object? bookRaw = _undefined,
    Object? createdAt = _undefined,
    Object? title = _undefined,
    Object? updatedAt = _undefined,
    Object? uuid = _undefined,
  }) =>
      _then(Input$BookWhereInput._({
        ..._instance._$data,
        if (AND != _undefined) 'AND': (AND as List<Input$BookWhereInput>?),
        if (NOT != _undefined) 'NOT': (NOT as List<Input$BookWhereInput>?),
        if (OR != _undefined) 'OR': (OR as List<Input$BookWhereInput>?),
        if (bookEdited != _undefined)
          'bookEdited':
              (bookEdited as Input$BookRevisionNullableRelationFilter?),
        if (bookRaw != _undefined)
          'bookRaw': (bookRaw as Input$BookRevisionNullableRelationFilter?),
        if (createdAt != _undefined)
          'createdAt': (createdAt as Input$DateTimeFilter?),
        if (title != _undefined) 'title': (title as Input$StringFilter?),
        if (updatedAt != _undefined)
          'updatedAt': (updatedAt as Input$DateTimeFilter?),
        if (uuid != _undefined) 'uuid': (uuid as Input$UuidFilter?),
      }));

  TRes AND(
          Iterable<Input$BookWhereInput>? Function(
                  Iterable<
                      CopyWith$Input$BookWhereInput<Input$BookWhereInput>>?)
              _fn) =>
      call(
          AND: _fn(_instance.AND?.map((e) => CopyWith$Input$BookWhereInput(
                e,
                (i) => i,
              )))?.toList());

  TRes NOT(
          Iterable<Input$BookWhereInput>? Function(
                  Iterable<
                      CopyWith$Input$BookWhereInput<Input$BookWhereInput>>?)
              _fn) =>
      call(
          NOT: _fn(_instance.NOT?.map((e) => CopyWith$Input$BookWhereInput(
                e,
                (i) => i,
              )))?.toList());

  TRes OR(
          Iterable<Input$BookWhereInput>? Function(
                  Iterable<
                      CopyWith$Input$BookWhereInput<Input$BookWhereInput>>?)
              _fn) =>
      call(
          OR: _fn(_instance.OR?.map((e) => CopyWith$Input$BookWhereInput(
                e,
                (i) => i,
              )))?.toList());

  CopyWith$Input$BookRevisionNullableRelationFilter<TRes> get bookEdited {
    final local$bookEdited = _instance.bookEdited;
    return local$bookEdited == null
        ? CopyWith$Input$BookRevisionNullableRelationFilter.stub(
            _then(_instance))
        : CopyWith$Input$BookRevisionNullableRelationFilter(
            local$bookEdited, (e) => call(bookEdited: e));
  }

  CopyWith$Input$BookRevisionNullableRelationFilter<TRes> get bookRaw {
    final local$bookRaw = _instance.bookRaw;
    return local$bookRaw == null
        ? CopyWith$Input$BookRevisionNullableRelationFilter.stub(
            _then(_instance))
        : CopyWith$Input$BookRevisionNullableRelationFilter(
            local$bookRaw, (e) => call(bookRaw: e));
  }

  CopyWith$Input$DateTimeFilter<TRes> get createdAt {
    final local$createdAt = _instance.createdAt;
    return local$createdAt == null
        ? CopyWith$Input$DateTimeFilter.stub(_then(_instance))
        : CopyWith$Input$DateTimeFilter(
            local$createdAt, (e) => call(createdAt: e));
  }

  CopyWith$Input$StringFilter<TRes> get title {
    final local$title = _instance.title;
    return local$title == null
        ? CopyWith$Input$StringFilter.stub(_then(_instance))
        : CopyWith$Input$StringFilter(local$title, (e) => call(title: e));
  }

  CopyWith$Input$DateTimeFilter<TRes> get updatedAt {
    final local$updatedAt = _instance.updatedAt;
    return local$updatedAt == null
        ? CopyWith$Input$DateTimeFilter.stub(_then(_instance))
        : CopyWith$Input$DateTimeFilter(
            local$updatedAt, (e) => call(updatedAt: e));
  }

  CopyWith$Input$UuidFilter<TRes> get uuid {
    final local$uuid = _instance.uuid;
    return local$uuid == null
        ? CopyWith$Input$UuidFilter.stub(_then(_instance))
        : CopyWith$Input$UuidFilter(local$uuid, (e) => call(uuid: e));
  }
}

class _CopyWithStubImpl$Input$BookWhereInput<TRes>
    implements CopyWith$Input$BookWhereInput<TRes> {
  _CopyWithStubImpl$Input$BookWhereInput(this._res);

  TRes _res;

  call({
    List<Input$BookWhereInput>? AND,
    List<Input$BookWhereInput>? NOT,
    List<Input$BookWhereInput>? OR,
    Input$BookRevisionNullableRelationFilter? bookEdited,
    Input$BookRevisionNullableRelationFilter? bookRaw,
    Input$DateTimeFilter? createdAt,
    Input$StringFilter? title,
    Input$DateTimeFilter? updatedAt,
    Input$UuidFilter? uuid,
  }) =>
      _res;

  AND(_fn) => _res;

  NOT(_fn) => _res;

  OR(_fn) => _res;

  CopyWith$Input$BookRevisionNullableRelationFilter<TRes> get bookEdited =>
      CopyWith$Input$BookRevisionNullableRelationFilter.stub(_res);

  CopyWith$Input$BookRevisionNullableRelationFilter<TRes> get bookRaw =>
      CopyWith$Input$BookRevisionNullableRelationFilter.stub(_res);

  CopyWith$Input$DateTimeFilter<TRes> get createdAt =>
      CopyWith$Input$DateTimeFilter.stub(_res);

  CopyWith$Input$StringFilter<TRes> get title =>
      CopyWith$Input$StringFilter.stub(_res);

  CopyWith$Input$DateTimeFilter<TRes> get updatedAt =>
      CopyWith$Input$DateTimeFilter.stub(_res);

  CopyWith$Input$UuidFilter<TRes> get uuid =>
      CopyWith$Input$UuidFilter.stub(_res);
}

class Input$BookWhereUniqueInput {
  factory Input$BookWhereUniqueInput({
    List<Input$BookWhereInput>? AND,
    List<Input$BookWhereInput>? NOT,
    List<Input$BookWhereInput>? OR,
    Input$BookRevisionNullableRelationFilter? bookEdited,
    Input$BookRevisionNullableRelationFilter? bookRaw,
    Input$DateTimeFilter? createdAt,
    Input$StringFilter? title,
    Input$DateTimeFilter? updatedAt,
    String? uuid,
  }) =>
      Input$BookWhereUniqueInput._({
        if (AND != null) r'AND': AND,
        if (NOT != null) r'NOT': NOT,
        if (OR != null) r'OR': OR,
        if (bookEdited != null) r'bookEdited': bookEdited,
        if (bookRaw != null) r'bookRaw': bookRaw,
        if (createdAt != null) r'createdAt': createdAt,
        if (title != null) r'title': title,
        if (updatedAt != null) r'updatedAt': updatedAt,
        if (uuid != null) r'uuid': uuid,
      });

  Input$BookWhereUniqueInput._(this._$data);

  factory Input$BookWhereUniqueInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('AND')) {
      final l$AND = data['AND'];
      result$data['AND'] = (l$AND as List<dynamic>?)
          ?.map(
              (e) => Input$BookWhereInput.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('NOT')) {
      final l$NOT = data['NOT'];
      result$data['NOT'] = (l$NOT as List<dynamic>?)
          ?.map(
              (e) => Input$BookWhereInput.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('OR')) {
      final l$OR = data['OR'];
      result$data['OR'] = (l$OR as List<dynamic>?)
          ?.map(
              (e) => Input$BookWhereInput.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('bookEdited')) {
      final l$bookEdited = data['bookEdited'];
      result$data['bookEdited'] = l$bookEdited == null
          ? null
          : Input$BookRevisionNullableRelationFilter.fromJson(
              (l$bookEdited as Map<String, dynamic>));
    }
    if (data.containsKey('bookRaw')) {
      final l$bookRaw = data['bookRaw'];
      result$data['bookRaw'] = l$bookRaw == null
          ? null
          : Input$BookRevisionNullableRelationFilter.fromJson(
              (l$bookRaw as Map<String, dynamic>));
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : Input$DateTimeFilter.fromJson(
              (l$createdAt as Map<String, dynamic>));
    }
    if (data.containsKey('title')) {
      final l$title = data['title'];
      result$data['title'] = l$title == null
          ? null
          : Input$StringFilter.fromJson((l$title as Map<String, dynamic>));
    }
    if (data.containsKey('updatedAt')) {
      final l$updatedAt = data['updatedAt'];
      result$data['updatedAt'] = l$updatedAt == null
          ? null
          : Input$DateTimeFilter.fromJson(
              (l$updatedAt as Map<String, dynamic>));
    }
    if (data.containsKey('uuid')) {
      final l$uuid = data['uuid'];
      result$data['uuid'] = (l$uuid as String?);
    }
    return Input$BookWhereUniqueInput._(result$data);
  }

  Map<String, dynamic> _$data;

  List<Input$BookWhereInput>? get AND =>
      (_$data['AND'] as List<Input$BookWhereInput>?);

  List<Input$BookWhereInput>? get NOT =>
      (_$data['NOT'] as List<Input$BookWhereInput>?);

  List<Input$BookWhereInput>? get OR =>
      (_$data['OR'] as List<Input$BookWhereInput>?);

  Input$BookRevisionNullableRelationFilter? get bookEdited =>
      (_$data['bookEdited'] as Input$BookRevisionNullableRelationFilter?);

  Input$BookRevisionNullableRelationFilter? get bookRaw =>
      (_$data['bookRaw'] as Input$BookRevisionNullableRelationFilter?);

  Input$DateTimeFilter? get createdAt =>
      (_$data['createdAt'] as Input$DateTimeFilter?);

  Input$StringFilter? get title => (_$data['title'] as Input$StringFilter?);

  Input$DateTimeFilter? get updatedAt =>
      (_$data['updatedAt'] as Input$DateTimeFilter?);

  String? get uuid => (_$data['uuid'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('AND')) {
      final l$AND = AND;
      result$data['AND'] = l$AND?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('NOT')) {
      final l$NOT = NOT;
      result$data['NOT'] = l$NOT?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('OR')) {
      final l$OR = OR;
      result$data['OR'] = l$OR?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('bookEdited')) {
      final l$bookEdited = bookEdited;
      result$data['bookEdited'] = l$bookEdited?.toJson();
    }
    if (_$data.containsKey('bookRaw')) {
      final l$bookRaw = bookRaw;
      result$data['bookRaw'] = l$bookRaw?.toJson();
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toJson();
    }
    if (_$data.containsKey('title')) {
      final l$title = title;
      result$data['title'] = l$title?.toJson();
    }
    if (_$data.containsKey('updatedAt')) {
      final l$updatedAt = updatedAt;
      result$data['updatedAt'] = l$updatedAt?.toJson();
    }
    if (_$data.containsKey('uuid')) {
      final l$uuid = uuid;
      result$data['uuid'] = l$uuid;
    }
    return result$data;
  }

  CopyWith$Input$BookWhereUniqueInput<Input$BookWhereUniqueInput>
      get copyWith => CopyWith$Input$BookWhereUniqueInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$BookWhereUniqueInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$AND = AND;
    final lOther$AND = other.AND;
    if (_$data.containsKey('AND') != other._$data.containsKey('AND')) {
      return false;
    }
    if (l$AND != null && lOther$AND != null) {
      if (l$AND.length != lOther$AND.length) {
        return false;
      }
      for (int i = 0; i < l$AND.length; i++) {
        final l$AND$entry = l$AND[i];
        final lOther$AND$entry = lOther$AND[i];
        if (l$AND$entry != lOther$AND$entry) {
          return false;
        }
      }
    } else if (l$AND != lOther$AND) {
      return false;
    }
    final l$NOT = NOT;
    final lOther$NOT = other.NOT;
    if (_$data.containsKey('NOT') != other._$data.containsKey('NOT')) {
      return false;
    }
    if (l$NOT != null && lOther$NOT != null) {
      if (l$NOT.length != lOther$NOT.length) {
        return false;
      }
      for (int i = 0; i < l$NOT.length; i++) {
        final l$NOT$entry = l$NOT[i];
        final lOther$NOT$entry = lOther$NOT[i];
        if (l$NOT$entry != lOther$NOT$entry) {
          return false;
        }
      }
    } else if (l$NOT != lOther$NOT) {
      return false;
    }
    final l$OR = OR;
    final lOther$OR = other.OR;
    if (_$data.containsKey('OR') != other._$data.containsKey('OR')) {
      return false;
    }
    if (l$OR != null && lOther$OR != null) {
      if (l$OR.length != lOther$OR.length) {
        return false;
      }
      for (int i = 0; i < l$OR.length; i++) {
        final l$OR$entry = l$OR[i];
        final lOther$OR$entry = lOther$OR[i];
        if (l$OR$entry != lOther$OR$entry) {
          return false;
        }
      }
    } else if (l$OR != lOther$OR) {
      return false;
    }
    final l$bookEdited = bookEdited;
    final lOther$bookEdited = other.bookEdited;
    if (_$data.containsKey('bookEdited') !=
        other._$data.containsKey('bookEdited')) {
      return false;
    }
    if (l$bookEdited != lOther$bookEdited) {
      return false;
    }
    final l$bookRaw = bookRaw;
    final lOther$bookRaw = other.bookRaw;
    if (_$data.containsKey('bookRaw') != other._$data.containsKey('bookRaw')) {
      return false;
    }
    if (l$bookRaw != lOther$bookRaw) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$title = title;
    final lOther$title = other.title;
    if (_$data.containsKey('title') != other._$data.containsKey('title')) {
      return false;
    }
    if (l$title != lOther$title) {
      return false;
    }
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (_$data.containsKey('updatedAt') !=
        other._$data.containsKey('updatedAt')) {
      return false;
    }
    if (l$updatedAt != lOther$updatedAt) {
      return false;
    }
    final l$uuid = uuid;
    final lOther$uuid = other.uuid;
    if (_$data.containsKey('uuid') != other._$data.containsKey('uuid')) {
      return false;
    }
    if (l$uuid != lOther$uuid) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$AND = AND;
    final l$NOT = NOT;
    final l$OR = OR;
    final l$bookEdited = bookEdited;
    final l$bookRaw = bookRaw;
    final l$createdAt = createdAt;
    final l$title = title;
    final l$updatedAt = updatedAt;
    final l$uuid = uuid;
    return Object.hashAll([
      _$data.containsKey('AND')
          ? l$AND == null
              ? null
              : Object.hashAll(l$AND.map((v) => v))
          : const {},
      _$data.containsKey('NOT')
          ? l$NOT == null
              ? null
              : Object.hashAll(l$NOT.map((v) => v))
          : const {},
      _$data.containsKey('OR')
          ? l$OR == null
              ? null
              : Object.hashAll(l$OR.map((v) => v))
          : const {},
      _$data.containsKey('bookEdited') ? l$bookEdited : const {},
      _$data.containsKey('bookRaw') ? l$bookRaw : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('title') ? l$title : const {},
      _$data.containsKey('updatedAt') ? l$updatedAt : const {},
      _$data.containsKey('uuid') ? l$uuid : const {},
    ]);
  }
}

abstract class CopyWith$Input$BookWhereUniqueInput<TRes> {
  factory CopyWith$Input$BookWhereUniqueInput(
    Input$BookWhereUniqueInput instance,
    TRes Function(Input$BookWhereUniqueInput) then,
  ) = _CopyWithImpl$Input$BookWhereUniqueInput;

  factory CopyWith$Input$BookWhereUniqueInput.stub(TRes res) =
      _CopyWithStubImpl$Input$BookWhereUniqueInput;

  TRes call({
    List<Input$BookWhereInput>? AND,
    List<Input$BookWhereInput>? NOT,
    List<Input$BookWhereInput>? OR,
    Input$BookRevisionNullableRelationFilter? bookEdited,
    Input$BookRevisionNullableRelationFilter? bookRaw,
    Input$DateTimeFilter? createdAt,
    Input$StringFilter? title,
    Input$DateTimeFilter? updatedAt,
    String? uuid,
  });
  TRes AND(
      Iterable<Input$BookWhereInput>? Function(
              Iterable<CopyWith$Input$BookWhereInput<Input$BookWhereInput>>?)
          _fn);
  TRes NOT(
      Iterable<Input$BookWhereInput>? Function(
              Iterable<CopyWith$Input$BookWhereInput<Input$BookWhereInput>>?)
          _fn);
  TRes OR(
      Iterable<Input$BookWhereInput>? Function(
              Iterable<CopyWith$Input$BookWhereInput<Input$BookWhereInput>>?)
          _fn);
  CopyWith$Input$BookRevisionNullableRelationFilter<TRes> get bookEdited;
  CopyWith$Input$BookRevisionNullableRelationFilter<TRes> get bookRaw;
  CopyWith$Input$DateTimeFilter<TRes> get createdAt;
  CopyWith$Input$StringFilter<TRes> get title;
  CopyWith$Input$DateTimeFilter<TRes> get updatedAt;
}

class _CopyWithImpl$Input$BookWhereUniqueInput<TRes>
    implements CopyWith$Input$BookWhereUniqueInput<TRes> {
  _CopyWithImpl$Input$BookWhereUniqueInput(
    this._instance,
    this._then,
  );

  final Input$BookWhereUniqueInput _instance;

  final TRes Function(Input$BookWhereUniqueInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? AND = _undefined,
    Object? NOT = _undefined,
    Object? OR = _undefined,
    Object? bookEdited = _undefined,
    Object? bookRaw = _undefined,
    Object? createdAt = _undefined,
    Object? title = _undefined,
    Object? updatedAt = _undefined,
    Object? uuid = _undefined,
  }) =>
      _then(Input$BookWhereUniqueInput._({
        ..._instance._$data,
        if (AND != _undefined) 'AND': (AND as List<Input$BookWhereInput>?),
        if (NOT != _undefined) 'NOT': (NOT as List<Input$BookWhereInput>?),
        if (OR != _undefined) 'OR': (OR as List<Input$BookWhereInput>?),
        if (bookEdited != _undefined)
          'bookEdited':
              (bookEdited as Input$BookRevisionNullableRelationFilter?),
        if (bookRaw != _undefined)
          'bookRaw': (bookRaw as Input$BookRevisionNullableRelationFilter?),
        if (createdAt != _undefined)
          'createdAt': (createdAt as Input$DateTimeFilter?),
        if (title != _undefined) 'title': (title as Input$StringFilter?),
        if (updatedAt != _undefined)
          'updatedAt': (updatedAt as Input$DateTimeFilter?),
        if (uuid != _undefined) 'uuid': (uuid as String?),
      }));

  TRes AND(
          Iterable<Input$BookWhereInput>? Function(
                  Iterable<
                      CopyWith$Input$BookWhereInput<Input$BookWhereInput>>?)
              _fn) =>
      call(
          AND: _fn(_instance.AND?.map((e) => CopyWith$Input$BookWhereInput(
                e,
                (i) => i,
              )))?.toList());

  TRes NOT(
          Iterable<Input$BookWhereInput>? Function(
                  Iterable<
                      CopyWith$Input$BookWhereInput<Input$BookWhereInput>>?)
              _fn) =>
      call(
          NOT: _fn(_instance.NOT?.map((e) => CopyWith$Input$BookWhereInput(
                e,
                (i) => i,
              )))?.toList());

  TRes OR(
          Iterable<Input$BookWhereInput>? Function(
                  Iterable<
                      CopyWith$Input$BookWhereInput<Input$BookWhereInput>>?)
              _fn) =>
      call(
          OR: _fn(_instance.OR?.map((e) => CopyWith$Input$BookWhereInput(
                e,
                (i) => i,
              )))?.toList());

  CopyWith$Input$BookRevisionNullableRelationFilter<TRes> get bookEdited {
    final local$bookEdited = _instance.bookEdited;
    return local$bookEdited == null
        ? CopyWith$Input$BookRevisionNullableRelationFilter.stub(
            _then(_instance))
        : CopyWith$Input$BookRevisionNullableRelationFilter(
            local$bookEdited, (e) => call(bookEdited: e));
  }

  CopyWith$Input$BookRevisionNullableRelationFilter<TRes> get bookRaw {
    final local$bookRaw = _instance.bookRaw;
    return local$bookRaw == null
        ? CopyWith$Input$BookRevisionNullableRelationFilter.stub(
            _then(_instance))
        : CopyWith$Input$BookRevisionNullableRelationFilter(
            local$bookRaw, (e) => call(bookRaw: e));
  }

  CopyWith$Input$DateTimeFilter<TRes> get createdAt {
    final local$createdAt = _instance.createdAt;
    return local$createdAt == null
        ? CopyWith$Input$DateTimeFilter.stub(_then(_instance))
        : CopyWith$Input$DateTimeFilter(
            local$createdAt, (e) => call(createdAt: e));
  }

  CopyWith$Input$StringFilter<TRes> get title {
    final local$title = _instance.title;
    return local$title == null
        ? CopyWith$Input$StringFilter.stub(_then(_instance))
        : CopyWith$Input$StringFilter(local$title, (e) => call(title: e));
  }

  CopyWith$Input$DateTimeFilter<TRes> get updatedAt {
    final local$updatedAt = _instance.updatedAt;
    return local$updatedAt == null
        ? CopyWith$Input$DateTimeFilter.stub(_then(_instance))
        : CopyWith$Input$DateTimeFilter(
            local$updatedAt, (e) => call(updatedAt: e));
  }
}

class _CopyWithStubImpl$Input$BookWhereUniqueInput<TRes>
    implements CopyWith$Input$BookWhereUniqueInput<TRes> {
  _CopyWithStubImpl$Input$BookWhereUniqueInput(this._res);

  TRes _res;

  call({
    List<Input$BookWhereInput>? AND,
    List<Input$BookWhereInput>? NOT,
    List<Input$BookWhereInput>? OR,
    Input$BookRevisionNullableRelationFilter? bookEdited,
    Input$BookRevisionNullableRelationFilter? bookRaw,
    Input$DateTimeFilter? createdAt,
    Input$StringFilter? title,
    Input$DateTimeFilter? updatedAt,
    String? uuid,
  }) =>
      _res;

  AND(_fn) => _res;

  NOT(_fn) => _res;

  OR(_fn) => _res;

  CopyWith$Input$BookRevisionNullableRelationFilter<TRes> get bookEdited =>
      CopyWith$Input$BookRevisionNullableRelationFilter.stub(_res);

  CopyWith$Input$BookRevisionNullableRelationFilter<TRes> get bookRaw =>
      CopyWith$Input$BookRevisionNullableRelationFilter.stub(_res);

  CopyWith$Input$DateTimeFilter<TRes> get createdAt =>
      CopyWith$Input$DateTimeFilter.stub(_res);

  CopyWith$Input$StringFilter<TRes> get title =>
      CopyWith$Input$StringFilter.stub(_res);

  CopyWith$Input$DateTimeFilter<TRes> get updatedAt =>
      CopyWith$Input$DateTimeFilter.stub(_res);
}

class Input$BoolFieldUpdateOperationsInput {
  factory Input$BoolFieldUpdateOperationsInput({bool? $set}) =>
      Input$BoolFieldUpdateOperationsInput._({
        if ($set != null) r'set': $set,
      });

  Input$BoolFieldUpdateOperationsInput._(this._$data);

  factory Input$BoolFieldUpdateOperationsInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('set')) {
      final l$$set = data['set'];
      result$data['set'] = (l$$set as bool?);
    }
    return Input$BoolFieldUpdateOperationsInput._(result$data);
  }

  Map<String, dynamic> _$data;

  bool? get $set => (_$data['set'] as bool?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('set')) {
      final l$$set = $set;
      result$data['set'] = l$$set;
    }
    return result$data;
  }

  CopyWith$Input$BoolFieldUpdateOperationsInput<
          Input$BoolFieldUpdateOperationsInput>
      get copyWith => CopyWith$Input$BoolFieldUpdateOperationsInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$BoolFieldUpdateOperationsInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$$set = $set;
    final lOther$$set = other.$set;
    if (_$data.containsKey('set') != other._$data.containsKey('set')) {
      return false;
    }
    if (l$$set != lOther$$set) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$$set = $set;
    return Object.hashAll([_$data.containsKey('set') ? l$$set : const {}]);
  }
}

abstract class CopyWith$Input$BoolFieldUpdateOperationsInput<TRes> {
  factory CopyWith$Input$BoolFieldUpdateOperationsInput(
    Input$BoolFieldUpdateOperationsInput instance,
    TRes Function(Input$BoolFieldUpdateOperationsInput) then,
  ) = _CopyWithImpl$Input$BoolFieldUpdateOperationsInput;

  factory CopyWith$Input$BoolFieldUpdateOperationsInput.stub(TRes res) =
      _CopyWithStubImpl$Input$BoolFieldUpdateOperationsInput;

  TRes call({bool? $set});
}

class _CopyWithImpl$Input$BoolFieldUpdateOperationsInput<TRes>
    implements CopyWith$Input$BoolFieldUpdateOperationsInput<TRes> {
  _CopyWithImpl$Input$BoolFieldUpdateOperationsInput(
    this._instance,
    this._then,
  );

  final Input$BoolFieldUpdateOperationsInput _instance;

  final TRes Function(Input$BoolFieldUpdateOperationsInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({Object? $set = _undefined}) =>
      _then(Input$BoolFieldUpdateOperationsInput._({
        ..._instance._$data,
        if ($set != _undefined) 'set': ($set as bool?),
      }));
}

class _CopyWithStubImpl$Input$BoolFieldUpdateOperationsInput<TRes>
    implements CopyWith$Input$BoolFieldUpdateOperationsInput<TRes> {
  _CopyWithStubImpl$Input$BoolFieldUpdateOperationsInput(this._res);

  TRes _res;

  call({bool? $set}) => _res;
}

class Input$BoolFilter {
  factory Input$BoolFilter({
    bool? equals,
    Input$NestedBoolFilter? not,
  }) =>
      Input$BoolFilter._({
        if (equals != null) r'equals': equals,
        if (not != null) r'not': not,
      });

  Input$BoolFilter._(this._$data);

  factory Input$BoolFilter.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('equals')) {
      final l$equals = data['equals'];
      result$data['equals'] = (l$equals as bool?);
    }
    if (data.containsKey('not')) {
      final l$not = data['not'];
      result$data['not'] = l$not == null
          ? null
          : Input$NestedBoolFilter.fromJson((l$not as Map<String, dynamic>));
    }
    return Input$BoolFilter._(result$data);
  }

  Map<String, dynamic> _$data;

  bool? get equals => (_$data['equals'] as bool?);

  Input$NestedBoolFilter? get not => (_$data['not'] as Input$NestedBoolFilter?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('equals')) {
      final l$equals = equals;
      result$data['equals'] = l$equals;
    }
    if (_$data.containsKey('not')) {
      final l$not = not;
      result$data['not'] = l$not?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$BoolFilter<Input$BoolFilter> get copyWith =>
      CopyWith$Input$BoolFilter(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$BoolFilter) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$equals = equals;
    final lOther$equals = other.equals;
    if (_$data.containsKey('equals') != other._$data.containsKey('equals')) {
      return false;
    }
    if (l$equals != lOther$equals) {
      return false;
    }
    final l$not = not;
    final lOther$not = other.not;
    if (_$data.containsKey('not') != other._$data.containsKey('not')) {
      return false;
    }
    if (l$not != lOther$not) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$equals = equals;
    final l$not = not;
    return Object.hashAll([
      _$data.containsKey('equals') ? l$equals : const {},
      _$data.containsKey('not') ? l$not : const {},
    ]);
  }
}

abstract class CopyWith$Input$BoolFilter<TRes> {
  factory CopyWith$Input$BoolFilter(
    Input$BoolFilter instance,
    TRes Function(Input$BoolFilter) then,
  ) = _CopyWithImpl$Input$BoolFilter;

  factory CopyWith$Input$BoolFilter.stub(TRes res) =
      _CopyWithStubImpl$Input$BoolFilter;

  TRes call({
    bool? equals,
    Input$NestedBoolFilter? not,
  });
  CopyWith$Input$NestedBoolFilter<TRes> get not;
}

class _CopyWithImpl$Input$BoolFilter<TRes>
    implements CopyWith$Input$BoolFilter<TRes> {
  _CopyWithImpl$Input$BoolFilter(
    this._instance,
    this._then,
  );

  final Input$BoolFilter _instance;

  final TRes Function(Input$BoolFilter) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? equals = _undefined,
    Object? not = _undefined,
  }) =>
      _then(Input$BoolFilter._({
        ..._instance._$data,
        if (equals != _undefined) 'equals': (equals as bool?),
        if (not != _undefined) 'not': (not as Input$NestedBoolFilter?),
      }));

  CopyWith$Input$NestedBoolFilter<TRes> get not {
    final local$not = _instance.not;
    return local$not == null
        ? CopyWith$Input$NestedBoolFilter.stub(_then(_instance))
        : CopyWith$Input$NestedBoolFilter(local$not, (e) => call(not: e));
  }
}

class _CopyWithStubImpl$Input$BoolFilter<TRes>
    implements CopyWith$Input$BoolFilter<TRes> {
  _CopyWithStubImpl$Input$BoolFilter(this._res);

  TRes _res;

  call({
    bool? equals,
    Input$NestedBoolFilter? not,
  }) =>
      _res;

  CopyWith$Input$NestedBoolFilter<TRes> get not =>
      CopyWith$Input$NestedBoolFilter.stub(_res);
}

class Input$BoolWithAggregatesFilter {
  factory Input$BoolWithAggregatesFilter({
    Input$NestedIntFilter? $_count,
    Input$NestedBoolFilter? $_max,
    Input$NestedBoolFilter? $_min,
    bool? equals,
    Input$NestedBoolWithAggregatesFilter? not,
  }) =>
      Input$BoolWithAggregatesFilter._({
        if ($_count != null) r'_count': $_count,
        if ($_max != null) r'_max': $_max,
        if ($_min != null) r'_min': $_min,
        if (equals != null) r'equals': equals,
        if (not != null) r'not': not,
      });

  Input$BoolWithAggregatesFilter._(this._$data);

  factory Input$BoolWithAggregatesFilter.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('_count')) {
      final l$$_count = data['_count'];
      result$data['_count'] = l$$_count == null
          ? null
          : Input$NestedIntFilter.fromJson((l$$_count as Map<String, dynamic>));
    }
    if (data.containsKey('_max')) {
      final l$$_max = data['_max'];
      result$data['_max'] = l$$_max == null
          ? null
          : Input$NestedBoolFilter.fromJson((l$$_max as Map<String, dynamic>));
    }
    if (data.containsKey('_min')) {
      final l$$_min = data['_min'];
      result$data['_min'] = l$$_min == null
          ? null
          : Input$NestedBoolFilter.fromJson((l$$_min as Map<String, dynamic>));
    }
    if (data.containsKey('equals')) {
      final l$equals = data['equals'];
      result$data['equals'] = (l$equals as bool?);
    }
    if (data.containsKey('not')) {
      final l$not = data['not'];
      result$data['not'] = l$not == null
          ? null
          : Input$NestedBoolWithAggregatesFilter.fromJson(
              (l$not as Map<String, dynamic>));
    }
    return Input$BoolWithAggregatesFilter._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$NestedIntFilter? get $_count =>
      (_$data['_count'] as Input$NestedIntFilter?);

  Input$NestedBoolFilter? get $_max =>
      (_$data['_max'] as Input$NestedBoolFilter?);

  Input$NestedBoolFilter? get $_min =>
      (_$data['_min'] as Input$NestedBoolFilter?);

  bool? get equals => (_$data['equals'] as bool?);

  Input$NestedBoolWithAggregatesFilter? get not =>
      (_$data['not'] as Input$NestedBoolWithAggregatesFilter?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('_count')) {
      final l$$_count = $_count;
      result$data['_count'] = l$$_count?.toJson();
    }
    if (_$data.containsKey('_max')) {
      final l$$_max = $_max;
      result$data['_max'] = l$$_max?.toJson();
    }
    if (_$data.containsKey('_min')) {
      final l$$_min = $_min;
      result$data['_min'] = l$$_min?.toJson();
    }
    if (_$data.containsKey('equals')) {
      final l$equals = equals;
      result$data['equals'] = l$equals;
    }
    if (_$data.containsKey('not')) {
      final l$not = not;
      result$data['not'] = l$not?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$BoolWithAggregatesFilter<Input$BoolWithAggregatesFilter>
      get copyWith => CopyWith$Input$BoolWithAggregatesFilter(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$BoolWithAggregatesFilter) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$$_count = $_count;
    final lOther$$_count = other.$_count;
    if (_$data.containsKey('_count') != other._$data.containsKey('_count')) {
      return false;
    }
    if (l$$_count != lOther$$_count) {
      return false;
    }
    final l$$_max = $_max;
    final lOther$$_max = other.$_max;
    if (_$data.containsKey('_max') != other._$data.containsKey('_max')) {
      return false;
    }
    if (l$$_max != lOther$$_max) {
      return false;
    }
    final l$$_min = $_min;
    final lOther$$_min = other.$_min;
    if (_$data.containsKey('_min') != other._$data.containsKey('_min')) {
      return false;
    }
    if (l$$_min != lOther$$_min) {
      return false;
    }
    final l$equals = equals;
    final lOther$equals = other.equals;
    if (_$data.containsKey('equals') != other._$data.containsKey('equals')) {
      return false;
    }
    if (l$equals != lOther$equals) {
      return false;
    }
    final l$not = not;
    final lOther$not = other.not;
    if (_$data.containsKey('not') != other._$data.containsKey('not')) {
      return false;
    }
    if (l$not != lOther$not) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$$_count = $_count;
    final l$$_max = $_max;
    final l$$_min = $_min;
    final l$equals = equals;
    final l$not = not;
    return Object.hashAll([
      _$data.containsKey('_count') ? l$$_count : const {},
      _$data.containsKey('_max') ? l$$_max : const {},
      _$data.containsKey('_min') ? l$$_min : const {},
      _$data.containsKey('equals') ? l$equals : const {},
      _$data.containsKey('not') ? l$not : const {},
    ]);
  }
}

abstract class CopyWith$Input$BoolWithAggregatesFilter<TRes> {
  factory CopyWith$Input$BoolWithAggregatesFilter(
    Input$BoolWithAggregatesFilter instance,
    TRes Function(Input$BoolWithAggregatesFilter) then,
  ) = _CopyWithImpl$Input$BoolWithAggregatesFilter;

  factory CopyWith$Input$BoolWithAggregatesFilter.stub(TRes res) =
      _CopyWithStubImpl$Input$BoolWithAggregatesFilter;

  TRes call({
    Input$NestedIntFilter? $_count,
    Input$NestedBoolFilter? $_max,
    Input$NestedBoolFilter? $_min,
    bool? equals,
    Input$NestedBoolWithAggregatesFilter? not,
  });
  CopyWith$Input$NestedIntFilter<TRes> get $_count;
  CopyWith$Input$NestedBoolFilter<TRes> get $_max;
  CopyWith$Input$NestedBoolFilter<TRes> get $_min;
  CopyWith$Input$NestedBoolWithAggregatesFilter<TRes> get not;
}

class _CopyWithImpl$Input$BoolWithAggregatesFilter<TRes>
    implements CopyWith$Input$BoolWithAggregatesFilter<TRes> {
  _CopyWithImpl$Input$BoolWithAggregatesFilter(
    this._instance,
    this._then,
  );

  final Input$BoolWithAggregatesFilter _instance;

  final TRes Function(Input$BoolWithAggregatesFilter) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? $_count = _undefined,
    Object? $_max = _undefined,
    Object? $_min = _undefined,
    Object? equals = _undefined,
    Object? not = _undefined,
  }) =>
      _then(Input$BoolWithAggregatesFilter._({
        ..._instance._$data,
        if ($_count != _undefined)
          '_count': ($_count as Input$NestedIntFilter?),
        if ($_max != _undefined) '_max': ($_max as Input$NestedBoolFilter?),
        if ($_min != _undefined) '_min': ($_min as Input$NestedBoolFilter?),
        if (equals != _undefined) 'equals': (equals as bool?),
        if (not != _undefined)
          'not': (not as Input$NestedBoolWithAggregatesFilter?),
      }));

  CopyWith$Input$NestedIntFilter<TRes> get $_count {
    final local$$_count = _instance.$_count;
    return local$$_count == null
        ? CopyWith$Input$NestedIntFilter.stub(_then(_instance))
        : CopyWith$Input$NestedIntFilter(
            local$$_count, (e) => call($_count: e));
  }

  CopyWith$Input$NestedBoolFilter<TRes> get $_max {
    final local$$_max = _instance.$_max;
    return local$$_max == null
        ? CopyWith$Input$NestedBoolFilter.stub(_then(_instance))
        : CopyWith$Input$NestedBoolFilter(local$$_max, (e) => call($_max: e));
  }

  CopyWith$Input$NestedBoolFilter<TRes> get $_min {
    final local$$_min = _instance.$_min;
    return local$$_min == null
        ? CopyWith$Input$NestedBoolFilter.stub(_then(_instance))
        : CopyWith$Input$NestedBoolFilter(local$$_min, (e) => call($_min: e));
  }

  CopyWith$Input$NestedBoolWithAggregatesFilter<TRes> get not {
    final local$not = _instance.not;
    return local$not == null
        ? CopyWith$Input$NestedBoolWithAggregatesFilter.stub(_then(_instance))
        : CopyWith$Input$NestedBoolWithAggregatesFilter(
            local$not, (e) => call(not: e));
  }
}

class _CopyWithStubImpl$Input$BoolWithAggregatesFilter<TRes>
    implements CopyWith$Input$BoolWithAggregatesFilter<TRes> {
  _CopyWithStubImpl$Input$BoolWithAggregatesFilter(this._res);

  TRes _res;

  call({
    Input$NestedIntFilter? $_count,
    Input$NestedBoolFilter? $_max,
    Input$NestedBoolFilter? $_min,
    bool? equals,
    Input$NestedBoolWithAggregatesFilter? not,
  }) =>
      _res;

  CopyWith$Input$NestedIntFilter<TRes> get $_count =>
      CopyWith$Input$NestedIntFilter.stub(_res);

  CopyWith$Input$NestedBoolFilter<TRes> get $_max =>
      CopyWith$Input$NestedBoolFilter.stub(_res);

  CopyWith$Input$NestedBoolFilter<TRes> get $_min =>
      CopyWith$Input$NestedBoolFilter.stub(_res);

  CopyWith$Input$NestedBoolWithAggregatesFilter<TRes> get not =>
      CopyWith$Input$NestedBoolWithAggregatesFilter.stub(_res);
}

class Input$DateTimeFieldUpdateOperationsInput {
  factory Input$DateTimeFieldUpdateOperationsInput({String? $set}) =>
      Input$DateTimeFieldUpdateOperationsInput._({
        if ($set != null) r'set': $set,
      });

  Input$DateTimeFieldUpdateOperationsInput._(this._$data);

  factory Input$DateTimeFieldUpdateOperationsInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('set')) {
      final l$$set = data['set'];
      result$data['set'] = (l$$set as String?);
    }
    return Input$DateTimeFieldUpdateOperationsInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get $set => (_$data['set'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('set')) {
      final l$$set = $set;
      result$data['set'] = l$$set;
    }
    return result$data;
  }

  CopyWith$Input$DateTimeFieldUpdateOperationsInput<
          Input$DateTimeFieldUpdateOperationsInput>
      get copyWith => CopyWith$Input$DateTimeFieldUpdateOperationsInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$DateTimeFieldUpdateOperationsInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$$set = $set;
    final lOther$$set = other.$set;
    if (_$data.containsKey('set') != other._$data.containsKey('set')) {
      return false;
    }
    if (l$$set != lOther$$set) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$$set = $set;
    return Object.hashAll([_$data.containsKey('set') ? l$$set : const {}]);
  }
}

abstract class CopyWith$Input$DateTimeFieldUpdateOperationsInput<TRes> {
  factory CopyWith$Input$DateTimeFieldUpdateOperationsInput(
    Input$DateTimeFieldUpdateOperationsInput instance,
    TRes Function(Input$DateTimeFieldUpdateOperationsInput) then,
  ) = _CopyWithImpl$Input$DateTimeFieldUpdateOperationsInput;

  factory CopyWith$Input$DateTimeFieldUpdateOperationsInput.stub(TRes res) =
      _CopyWithStubImpl$Input$DateTimeFieldUpdateOperationsInput;

  TRes call({String? $set});
}

class _CopyWithImpl$Input$DateTimeFieldUpdateOperationsInput<TRes>
    implements CopyWith$Input$DateTimeFieldUpdateOperationsInput<TRes> {
  _CopyWithImpl$Input$DateTimeFieldUpdateOperationsInput(
    this._instance,
    this._then,
  );

  final Input$DateTimeFieldUpdateOperationsInput _instance;

  final TRes Function(Input$DateTimeFieldUpdateOperationsInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({Object? $set = _undefined}) =>
      _then(Input$DateTimeFieldUpdateOperationsInput._({
        ..._instance._$data,
        if ($set != _undefined) 'set': ($set as String?),
      }));
}

class _CopyWithStubImpl$Input$DateTimeFieldUpdateOperationsInput<TRes>
    implements CopyWith$Input$DateTimeFieldUpdateOperationsInput<TRes> {
  _CopyWithStubImpl$Input$DateTimeFieldUpdateOperationsInput(this._res);

  TRes _res;

  call({String? $set}) => _res;
}

class Input$DateTimeFilter {
  factory Input$DateTimeFilter({
    String? equals,
    String? gt,
    String? gte,
    List<String>? $in,
    String? lt,
    String? lte,
    Input$NestedDateTimeFilter? not,
    List<String>? notIn,
  }) =>
      Input$DateTimeFilter._({
        if (equals != null) r'equals': equals,
        if (gt != null) r'gt': gt,
        if (gte != null) r'gte': gte,
        if ($in != null) r'in': $in,
        if (lt != null) r'lt': lt,
        if (lte != null) r'lte': lte,
        if (not != null) r'not': not,
        if (notIn != null) r'notIn': notIn,
      });

  Input$DateTimeFilter._(this._$data);

  factory Input$DateTimeFilter.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('equals')) {
      final l$equals = data['equals'];
      result$data['equals'] = (l$equals as String?);
    }
    if (data.containsKey('gt')) {
      final l$gt = data['gt'];
      result$data['gt'] = (l$gt as String?);
    }
    if (data.containsKey('gte')) {
      final l$gte = data['gte'];
      result$data['gte'] = (l$gte as String?);
    }
    if (data.containsKey('in')) {
      final l$$in = data['in'];
      result$data['in'] =
          (l$$in as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    if (data.containsKey('lt')) {
      final l$lt = data['lt'];
      result$data['lt'] = (l$lt as String?);
    }
    if (data.containsKey('lte')) {
      final l$lte = data['lte'];
      result$data['lte'] = (l$lte as String?);
    }
    if (data.containsKey('not')) {
      final l$not = data['not'];
      result$data['not'] = l$not == null
          ? null
          : Input$NestedDateTimeFilter.fromJson(
              (l$not as Map<String, dynamic>));
    }
    if (data.containsKey('notIn')) {
      final l$notIn = data['notIn'];
      result$data['notIn'] =
          (l$notIn as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    return Input$DateTimeFilter._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get equals => (_$data['equals'] as String?);

  String? get gt => (_$data['gt'] as String?);

  String? get gte => (_$data['gte'] as String?);

  List<String>? get $in => (_$data['in'] as List<String>?);

  String? get lt => (_$data['lt'] as String?);

  String? get lte => (_$data['lte'] as String?);

  Input$NestedDateTimeFilter? get not =>
      (_$data['not'] as Input$NestedDateTimeFilter?);

  List<String>? get notIn => (_$data['notIn'] as List<String>?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('equals')) {
      final l$equals = equals;
      result$data['equals'] = l$equals;
    }
    if (_$data.containsKey('gt')) {
      final l$gt = gt;
      result$data['gt'] = l$gt;
    }
    if (_$data.containsKey('gte')) {
      final l$gte = gte;
      result$data['gte'] = l$gte;
    }
    if (_$data.containsKey('in')) {
      final l$$in = $in;
      result$data['in'] = l$$in?.map((e) => e).toList();
    }
    if (_$data.containsKey('lt')) {
      final l$lt = lt;
      result$data['lt'] = l$lt;
    }
    if (_$data.containsKey('lte')) {
      final l$lte = lte;
      result$data['lte'] = l$lte;
    }
    if (_$data.containsKey('not')) {
      final l$not = not;
      result$data['not'] = l$not?.toJson();
    }
    if (_$data.containsKey('notIn')) {
      final l$notIn = notIn;
      result$data['notIn'] = l$notIn?.map((e) => e).toList();
    }
    return result$data;
  }

  CopyWith$Input$DateTimeFilter<Input$DateTimeFilter> get copyWith =>
      CopyWith$Input$DateTimeFilter(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$DateTimeFilter) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$equals = equals;
    final lOther$equals = other.equals;
    if (_$data.containsKey('equals') != other._$data.containsKey('equals')) {
      return false;
    }
    if (l$equals != lOther$equals) {
      return false;
    }
    final l$gt = gt;
    final lOther$gt = other.gt;
    if (_$data.containsKey('gt') != other._$data.containsKey('gt')) {
      return false;
    }
    if (l$gt != lOther$gt) {
      return false;
    }
    final l$gte = gte;
    final lOther$gte = other.gte;
    if (_$data.containsKey('gte') != other._$data.containsKey('gte')) {
      return false;
    }
    if (l$gte != lOther$gte) {
      return false;
    }
    final l$$in = $in;
    final lOther$$in = other.$in;
    if (_$data.containsKey('in') != other._$data.containsKey('in')) {
      return false;
    }
    if (l$$in != null && lOther$$in != null) {
      if (l$$in.length != lOther$$in.length) {
        return false;
      }
      for (int i = 0; i < l$$in.length; i++) {
        final l$$in$entry = l$$in[i];
        final lOther$$in$entry = lOther$$in[i];
        if (l$$in$entry != lOther$$in$entry) {
          return false;
        }
      }
    } else if (l$$in != lOther$$in) {
      return false;
    }
    final l$lt = lt;
    final lOther$lt = other.lt;
    if (_$data.containsKey('lt') != other._$data.containsKey('lt')) {
      return false;
    }
    if (l$lt != lOther$lt) {
      return false;
    }
    final l$lte = lte;
    final lOther$lte = other.lte;
    if (_$data.containsKey('lte') != other._$data.containsKey('lte')) {
      return false;
    }
    if (l$lte != lOther$lte) {
      return false;
    }
    final l$not = not;
    final lOther$not = other.not;
    if (_$data.containsKey('not') != other._$data.containsKey('not')) {
      return false;
    }
    if (l$not != lOther$not) {
      return false;
    }
    final l$notIn = notIn;
    final lOther$notIn = other.notIn;
    if (_$data.containsKey('notIn') != other._$data.containsKey('notIn')) {
      return false;
    }
    if (l$notIn != null && lOther$notIn != null) {
      if (l$notIn.length != lOther$notIn.length) {
        return false;
      }
      for (int i = 0; i < l$notIn.length; i++) {
        final l$notIn$entry = l$notIn[i];
        final lOther$notIn$entry = lOther$notIn[i];
        if (l$notIn$entry != lOther$notIn$entry) {
          return false;
        }
      }
    } else if (l$notIn != lOther$notIn) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$equals = equals;
    final l$gt = gt;
    final l$gte = gte;
    final l$$in = $in;
    final l$lt = lt;
    final l$lte = lte;
    final l$not = not;
    final l$notIn = notIn;
    return Object.hashAll([
      _$data.containsKey('equals') ? l$equals : const {},
      _$data.containsKey('gt') ? l$gt : const {},
      _$data.containsKey('gte') ? l$gte : const {},
      _$data.containsKey('in')
          ? l$$in == null
              ? null
              : Object.hashAll(l$$in.map((v) => v))
          : const {},
      _$data.containsKey('lt') ? l$lt : const {},
      _$data.containsKey('lte') ? l$lte : const {},
      _$data.containsKey('not') ? l$not : const {},
      _$data.containsKey('notIn')
          ? l$notIn == null
              ? null
              : Object.hashAll(l$notIn.map((v) => v))
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$DateTimeFilter<TRes> {
  factory CopyWith$Input$DateTimeFilter(
    Input$DateTimeFilter instance,
    TRes Function(Input$DateTimeFilter) then,
  ) = _CopyWithImpl$Input$DateTimeFilter;

  factory CopyWith$Input$DateTimeFilter.stub(TRes res) =
      _CopyWithStubImpl$Input$DateTimeFilter;

  TRes call({
    String? equals,
    String? gt,
    String? gte,
    List<String>? $in,
    String? lt,
    String? lte,
    Input$NestedDateTimeFilter? not,
    List<String>? notIn,
  });
  CopyWith$Input$NestedDateTimeFilter<TRes> get not;
}

class _CopyWithImpl$Input$DateTimeFilter<TRes>
    implements CopyWith$Input$DateTimeFilter<TRes> {
  _CopyWithImpl$Input$DateTimeFilter(
    this._instance,
    this._then,
  );

  final Input$DateTimeFilter _instance;

  final TRes Function(Input$DateTimeFilter) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? equals = _undefined,
    Object? gt = _undefined,
    Object? gte = _undefined,
    Object? $in = _undefined,
    Object? lt = _undefined,
    Object? lte = _undefined,
    Object? not = _undefined,
    Object? notIn = _undefined,
  }) =>
      _then(Input$DateTimeFilter._({
        ..._instance._$data,
        if (equals != _undefined) 'equals': (equals as String?),
        if (gt != _undefined) 'gt': (gt as String?),
        if (gte != _undefined) 'gte': (gte as String?),
        if ($in != _undefined) 'in': ($in as List<String>?),
        if (lt != _undefined) 'lt': (lt as String?),
        if (lte != _undefined) 'lte': (lte as String?),
        if (not != _undefined) 'not': (not as Input$NestedDateTimeFilter?),
        if (notIn != _undefined) 'notIn': (notIn as List<String>?),
      }));

  CopyWith$Input$NestedDateTimeFilter<TRes> get not {
    final local$not = _instance.not;
    return local$not == null
        ? CopyWith$Input$NestedDateTimeFilter.stub(_then(_instance))
        : CopyWith$Input$NestedDateTimeFilter(local$not, (e) => call(not: e));
  }
}

class _CopyWithStubImpl$Input$DateTimeFilter<TRes>
    implements CopyWith$Input$DateTimeFilter<TRes> {
  _CopyWithStubImpl$Input$DateTimeFilter(this._res);

  TRes _res;

  call({
    String? equals,
    String? gt,
    String? gte,
    List<String>? $in,
    String? lt,
    String? lte,
    Input$NestedDateTimeFilter? not,
    List<String>? notIn,
  }) =>
      _res;

  CopyWith$Input$NestedDateTimeFilter<TRes> get not =>
      CopyWith$Input$NestedDateTimeFilter.stub(_res);
}

class Input$DateTimeWithAggregatesFilter {
  factory Input$DateTimeWithAggregatesFilter({
    Input$NestedIntFilter? $_count,
    Input$NestedDateTimeFilter? $_max,
    Input$NestedDateTimeFilter? $_min,
    String? equals,
    String? gt,
    String? gte,
    List<String>? $in,
    String? lt,
    String? lte,
    Input$NestedDateTimeWithAggregatesFilter? not,
    List<String>? notIn,
  }) =>
      Input$DateTimeWithAggregatesFilter._({
        if ($_count != null) r'_count': $_count,
        if ($_max != null) r'_max': $_max,
        if ($_min != null) r'_min': $_min,
        if (equals != null) r'equals': equals,
        if (gt != null) r'gt': gt,
        if (gte != null) r'gte': gte,
        if ($in != null) r'in': $in,
        if (lt != null) r'lt': lt,
        if (lte != null) r'lte': lte,
        if (not != null) r'not': not,
        if (notIn != null) r'notIn': notIn,
      });

  Input$DateTimeWithAggregatesFilter._(this._$data);

  factory Input$DateTimeWithAggregatesFilter.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('_count')) {
      final l$$_count = data['_count'];
      result$data['_count'] = l$$_count == null
          ? null
          : Input$NestedIntFilter.fromJson((l$$_count as Map<String, dynamic>));
    }
    if (data.containsKey('_max')) {
      final l$$_max = data['_max'];
      result$data['_max'] = l$$_max == null
          ? null
          : Input$NestedDateTimeFilter.fromJson(
              (l$$_max as Map<String, dynamic>));
    }
    if (data.containsKey('_min')) {
      final l$$_min = data['_min'];
      result$data['_min'] = l$$_min == null
          ? null
          : Input$NestedDateTimeFilter.fromJson(
              (l$$_min as Map<String, dynamic>));
    }
    if (data.containsKey('equals')) {
      final l$equals = data['equals'];
      result$data['equals'] = (l$equals as String?);
    }
    if (data.containsKey('gt')) {
      final l$gt = data['gt'];
      result$data['gt'] = (l$gt as String?);
    }
    if (data.containsKey('gte')) {
      final l$gte = data['gte'];
      result$data['gte'] = (l$gte as String?);
    }
    if (data.containsKey('in')) {
      final l$$in = data['in'];
      result$data['in'] =
          (l$$in as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    if (data.containsKey('lt')) {
      final l$lt = data['lt'];
      result$data['lt'] = (l$lt as String?);
    }
    if (data.containsKey('lte')) {
      final l$lte = data['lte'];
      result$data['lte'] = (l$lte as String?);
    }
    if (data.containsKey('not')) {
      final l$not = data['not'];
      result$data['not'] = l$not == null
          ? null
          : Input$NestedDateTimeWithAggregatesFilter.fromJson(
              (l$not as Map<String, dynamic>));
    }
    if (data.containsKey('notIn')) {
      final l$notIn = data['notIn'];
      result$data['notIn'] =
          (l$notIn as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    return Input$DateTimeWithAggregatesFilter._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$NestedIntFilter? get $_count =>
      (_$data['_count'] as Input$NestedIntFilter?);

  Input$NestedDateTimeFilter? get $_max =>
      (_$data['_max'] as Input$NestedDateTimeFilter?);

  Input$NestedDateTimeFilter? get $_min =>
      (_$data['_min'] as Input$NestedDateTimeFilter?);

  String? get equals => (_$data['equals'] as String?);

  String? get gt => (_$data['gt'] as String?);

  String? get gte => (_$data['gte'] as String?);

  List<String>? get $in => (_$data['in'] as List<String>?);

  String? get lt => (_$data['lt'] as String?);

  String? get lte => (_$data['lte'] as String?);

  Input$NestedDateTimeWithAggregatesFilter? get not =>
      (_$data['not'] as Input$NestedDateTimeWithAggregatesFilter?);

  List<String>? get notIn => (_$data['notIn'] as List<String>?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('_count')) {
      final l$$_count = $_count;
      result$data['_count'] = l$$_count?.toJson();
    }
    if (_$data.containsKey('_max')) {
      final l$$_max = $_max;
      result$data['_max'] = l$$_max?.toJson();
    }
    if (_$data.containsKey('_min')) {
      final l$$_min = $_min;
      result$data['_min'] = l$$_min?.toJson();
    }
    if (_$data.containsKey('equals')) {
      final l$equals = equals;
      result$data['equals'] = l$equals;
    }
    if (_$data.containsKey('gt')) {
      final l$gt = gt;
      result$data['gt'] = l$gt;
    }
    if (_$data.containsKey('gte')) {
      final l$gte = gte;
      result$data['gte'] = l$gte;
    }
    if (_$data.containsKey('in')) {
      final l$$in = $in;
      result$data['in'] = l$$in?.map((e) => e).toList();
    }
    if (_$data.containsKey('lt')) {
      final l$lt = lt;
      result$data['lt'] = l$lt;
    }
    if (_$data.containsKey('lte')) {
      final l$lte = lte;
      result$data['lte'] = l$lte;
    }
    if (_$data.containsKey('not')) {
      final l$not = not;
      result$data['not'] = l$not?.toJson();
    }
    if (_$data.containsKey('notIn')) {
      final l$notIn = notIn;
      result$data['notIn'] = l$notIn?.map((e) => e).toList();
    }
    return result$data;
  }

  CopyWith$Input$DateTimeWithAggregatesFilter<
          Input$DateTimeWithAggregatesFilter>
      get copyWith => CopyWith$Input$DateTimeWithAggregatesFilter(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$DateTimeWithAggregatesFilter) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$$_count = $_count;
    final lOther$$_count = other.$_count;
    if (_$data.containsKey('_count') != other._$data.containsKey('_count')) {
      return false;
    }
    if (l$$_count != lOther$$_count) {
      return false;
    }
    final l$$_max = $_max;
    final lOther$$_max = other.$_max;
    if (_$data.containsKey('_max') != other._$data.containsKey('_max')) {
      return false;
    }
    if (l$$_max != lOther$$_max) {
      return false;
    }
    final l$$_min = $_min;
    final lOther$$_min = other.$_min;
    if (_$data.containsKey('_min') != other._$data.containsKey('_min')) {
      return false;
    }
    if (l$$_min != lOther$$_min) {
      return false;
    }
    final l$equals = equals;
    final lOther$equals = other.equals;
    if (_$data.containsKey('equals') != other._$data.containsKey('equals')) {
      return false;
    }
    if (l$equals != lOther$equals) {
      return false;
    }
    final l$gt = gt;
    final lOther$gt = other.gt;
    if (_$data.containsKey('gt') != other._$data.containsKey('gt')) {
      return false;
    }
    if (l$gt != lOther$gt) {
      return false;
    }
    final l$gte = gte;
    final lOther$gte = other.gte;
    if (_$data.containsKey('gte') != other._$data.containsKey('gte')) {
      return false;
    }
    if (l$gte != lOther$gte) {
      return false;
    }
    final l$$in = $in;
    final lOther$$in = other.$in;
    if (_$data.containsKey('in') != other._$data.containsKey('in')) {
      return false;
    }
    if (l$$in != null && lOther$$in != null) {
      if (l$$in.length != lOther$$in.length) {
        return false;
      }
      for (int i = 0; i < l$$in.length; i++) {
        final l$$in$entry = l$$in[i];
        final lOther$$in$entry = lOther$$in[i];
        if (l$$in$entry != lOther$$in$entry) {
          return false;
        }
      }
    } else if (l$$in != lOther$$in) {
      return false;
    }
    final l$lt = lt;
    final lOther$lt = other.lt;
    if (_$data.containsKey('lt') != other._$data.containsKey('lt')) {
      return false;
    }
    if (l$lt != lOther$lt) {
      return false;
    }
    final l$lte = lte;
    final lOther$lte = other.lte;
    if (_$data.containsKey('lte') != other._$data.containsKey('lte')) {
      return false;
    }
    if (l$lte != lOther$lte) {
      return false;
    }
    final l$not = not;
    final lOther$not = other.not;
    if (_$data.containsKey('not') != other._$data.containsKey('not')) {
      return false;
    }
    if (l$not != lOther$not) {
      return false;
    }
    final l$notIn = notIn;
    final lOther$notIn = other.notIn;
    if (_$data.containsKey('notIn') != other._$data.containsKey('notIn')) {
      return false;
    }
    if (l$notIn != null && lOther$notIn != null) {
      if (l$notIn.length != lOther$notIn.length) {
        return false;
      }
      for (int i = 0; i < l$notIn.length; i++) {
        final l$notIn$entry = l$notIn[i];
        final lOther$notIn$entry = lOther$notIn[i];
        if (l$notIn$entry != lOther$notIn$entry) {
          return false;
        }
      }
    } else if (l$notIn != lOther$notIn) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$$_count = $_count;
    final l$$_max = $_max;
    final l$$_min = $_min;
    final l$equals = equals;
    final l$gt = gt;
    final l$gte = gte;
    final l$$in = $in;
    final l$lt = lt;
    final l$lte = lte;
    final l$not = not;
    final l$notIn = notIn;
    return Object.hashAll([
      _$data.containsKey('_count') ? l$$_count : const {},
      _$data.containsKey('_max') ? l$$_max : const {},
      _$data.containsKey('_min') ? l$$_min : const {},
      _$data.containsKey('equals') ? l$equals : const {},
      _$data.containsKey('gt') ? l$gt : const {},
      _$data.containsKey('gte') ? l$gte : const {},
      _$data.containsKey('in')
          ? l$$in == null
              ? null
              : Object.hashAll(l$$in.map((v) => v))
          : const {},
      _$data.containsKey('lt') ? l$lt : const {},
      _$data.containsKey('lte') ? l$lte : const {},
      _$data.containsKey('not') ? l$not : const {},
      _$data.containsKey('notIn')
          ? l$notIn == null
              ? null
              : Object.hashAll(l$notIn.map((v) => v))
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$DateTimeWithAggregatesFilter<TRes> {
  factory CopyWith$Input$DateTimeWithAggregatesFilter(
    Input$DateTimeWithAggregatesFilter instance,
    TRes Function(Input$DateTimeWithAggregatesFilter) then,
  ) = _CopyWithImpl$Input$DateTimeWithAggregatesFilter;

  factory CopyWith$Input$DateTimeWithAggregatesFilter.stub(TRes res) =
      _CopyWithStubImpl$Input$DateTimeWithAggregatesFilter;

  TRes call({
    Input$NestedIntFilter? $_count,
    Input$NestedDateTimeFilter? $_max,
    Input$NestedDateTimeFilter? $_min,
    String? equals,
    String? gt,
    String? gte,
    List<String>? $in,
    String? lt,
    String? lte,
    Input$NestedDateTimeWithAggregatesFilter? not,
    List<String>? notIn,
  });
  CopyWith$Input$NestedIntFilter<TRes> get $_count;
  CopyWith$Input$NestedDateTimeFilter<TRes> get $_max;
  CopyWith$Input$NestedDateTimeFilter<TRes> get $_min;
  CopyWith$Input$NestedDateTimeWithAggregatesFilter<TRes> get not;
}

class _CopyWithImpl$Input$DateTimeWithAggregatesFilter<TRes>
    implements CopyWith$Input$DateTimeWithAggregatesFilter<TRes> {
  _CopyWithImpl$Input$DateTimeWithAggregatesFilter(
    this._instance,
    this._then,
  );

  final Input$DateTimeWithAggregatesFilter _instance;

  final TRes Function(Input$DateTimeWithAggregatesFilter) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? $_count = _undefined,
    Object? $_max = _undefined,
    Object? $_min = _undefined,
    Object? equals = _undefined,
    Object? gt = _undefined,
    Object? gte = _undefined,
    Object? $in = _undefined,
    Object? lt = _undefined,
    Object? lte = _undefined,
    Object? not = _undefined,
    Object? notIn = _undefined,
  }) =>
      _then(Input$DateTimeWithAggregatesFilter._({
        ..._instance._$data,
        if ($_count != _undefined)
          '_count': ($_count as Input$NestedIntFilter?),
        if ($_max != _undefined) '_max': ($_max as Input$NestedDateTimeFilter?),
        if ($_min != _undefined) '_min': ($_min as Input$NestedDateTimeFilter?),
        if (equals != _undefined) 'equals': (equals as String?),
        if (gt != _undefined) 'gt': (gt as String?),
        if (gte != _undefined) 'gte': (gte as String?),
        if ($in != _undefined) 'in': ($in as List<String>?),
        if (lt != _undefined) 'lt': (lt as String?),
        if (lte != _undefined) 'lte': (lte as String?),
        if (not != _undefined)
          'not': (not as Input$NestedDateTimeWithAggregatesFilter?),
        if (notIn != _undefined) 'notIn': (notIn as List<String>?),
      }));

  CopyWith$Input$NestedIntFilter<TRes> get $_count {
    final local$$_count = _instance.$_count;
    return local$$_count == null
        ? CopyWith$Input$NestedIntFilter.stub(_then(_instance))
        : CopyWith$Input$NestedIntFilter(
            local$$_count, (e) => call($_count: e));
  }

  CopyWith$Input$NestedDateTimeFilter<TRes> get $_max {
    final local$$_max = _instance.$_max;
    return local$$_max == null
        ? CopyWith$Input$NestedDateTimeFilter.stub(_then(_instance))
        : CopyWith$Input$NestedDateTimeFilter(
            local$$_max, (e) => call($_max: e));
  }

  CopyWith$Input$NestedDateTimeFilter<TRes> get $_min {
    final local$$_min = _instance.$_min;
    return local$$_min == null
        ? CopyWith$Input$NestedDateTimeFilter.stub(_then(_instance))
        : CopyWith$Input$NestedDateTimeFilter(
            local$$_min, (e) => call($_min: e));
  }

  CopyWith$Input$NestedDateTimeWithAggregatesFilter<TRes> get not {
    final local$not = _instance.not;
    return local$not == null
        ? CopyWith$Input$NestedDateTimeWithAggregatesFilter.stub(
            _then(_instance))
        : CopyWith$Input$NestedDateTimeWithAggregatesFilter(
            local$not, (e) => call(not: e));
  }
}

class _CopyWithStubImpl$Input$DateTimeWithAggregatesFilter<TRes>
    implements CopyWith$Input$DateTimeWithAggregatesFilter<TRes> {
  _CopyWithStubImpl$Input$DateTimeWithAggregatesFilter(this._res);

  TRes _res;

  call({
    Input$NestedIntFilter? $_count,
    Input$NestedDateTimeFilter? $_max,
    Input$NestedDateTimeFilter? $_min,
    String? equals,
    String? gt,
    String? gte,
    List<String>? $in,
    String? lt,
    String? lte,
    Input$NestedDateTimeWithAggregatesFilter? not,
    List<String>? notIn,
  }) =>
      _res;

  CopyWith$Input$NestedIntFilter<TRes> get $_count =>
      CopyWith$Input$NestedIntFilter.stub(_res);

  CopyWith$Input$NestedDateTimeFilter<TRes> get $_max =>
      CopyWith$Input$NestedDateTimeFilter.stub(_res);

  CopyWith$Input$NestedDateTimeFilter<TRes> get $_min =>
      CopyWith$Input$NestedDateTimeFilter.stub(_res);

  CopyWith$Input$NestedDateTimeWithAggregatesFilter<TRes> get not =>
      CopyWith$Input$NestedDateTimeWithAggregatesFilter.stub(_res);
}

class Input$IntNullableFilter {
  factory Input$IntNullableFilter({
    int? equals,
    int? gt,
    int? gte,
    List<int>? $in,
    int? lt,
    int? lte,
    Input$NestedIntNullableFilter? not,
    List<int>? notIn,
  }) =>
      Input$IntNullableFilter._({
        if (equals != null) r'equals': equals,
        if (gt != null) r'gt': gt,
        if (gte != null) r'gte': gte,
        if ($in != null) r'in': $in,
        if (lt != null) r'lt': lt,
        if (lte != null) r'lte': lte,
        if (not != null) r'not': not,
        if (notIn != null) r'notIn': notIn,
      });

  Input$IntNullableFilter._(this._$data);

  factory Input$IntNullableFilter.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('equals')) {
      final l$equals = data['equals'];
      result$data['equals'] = (l$equals as int?);
    }
    if (data.containsKey('gt')) {
      final l$gt = data['gt'];
      result$data['gt'] = (l$gt as int?);
    }
    if (data.containsKey('gte')) {
      final l$gte = data['gte'];
      result$data['gte'] = (l$gte as int?);
    }
    if (data.containsKey('in')) {
      final l$$in = data['in'];
      result$data['in'] =
          (l$$in as List<dynamic>?)?.map((e) => (e as int)).toList();
    }
    if (data.containsKey('lt')) {
      final l$lt = data['lt'];
      result$data['lt'] = (l$lt as int?);
    }
    if (data.containsKey('lte')) {
      final l$lte = data['lte'];
      result$data['lte'] = (l$lte as int?);
    }
    if (data.containsKey('not')) {
      final l$not = data['not'];
      result$data['not'] = l$not == null
          ? null
          : Input$NestedIntNullableFilter.fromJson(
              (l$not as Map<String, dynamic>));
    }
    if (data.containsKey('notIn')) {
      final l$notIn = data['notIn'];
      result$data['notIn'] =
          (l$notIn as List<dynamic>?)?.map((e) => (e as int)).toList();
    }
    return Input$IntNullableFilter._(result$data);
  }

  Map<String, dynamic> _$data;

  int? get equals => (_$data['equals'] as int?);

  int? get gt => (_$data['gt'] as int?);

  int? get gte => (_$data['gte'] as int?);

  List<int>? get $in => (_$data['in'] as List<int>?);

  int? get lt => (_$data['lt'] as int?);

  int? get lte => (_$data['lte'] as int?);

  Input$NestedIntNullableFilter? get not =>
      (_$data['not'] as Input$NestedIntNullableFilter?);

  List<int>? get notIn => (_$data['notIn'] as List<int>?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('equals')) {
      final l$equals = equals;
      result$data['equals'] = l$equals;
    }
    if (_$data.containsKey('gt')) {
      final l$gt = gt;
      result$data['gt'] = l$gt;
    }
    if (_$data.containsKey('gte')) {
      final l$gte = gte;
      result$data['gte'] = l$gte;
    }
    if (_$data.containsKey('in')) {
      final l$$in = $in;
      result$data['in'] = l$$in?.map((e) => e).toList();
    }
    if (_$data.containsKey('lt')) {
      final l$lt = lt;
      result$data['lt'] = l$lt;
    }
    if (_$data.containsKey('lte')) {
      final l$lte = lte;
      result$data['lte'] = l$lte;
    }
    if (_$data.containsKey('not')) {
      final l$not = not;
      result$data['not'] = l$not?.toJson();
    }
    if (_$data.containsKey('notIn')) {
      final l$notIn = notIn;
      result$data['notIn'] = l$notIn?.map((e) => e).toList();
    }
    return result$data;
  }

  CopyWith$Input$IntNullableFilter<Input$IntNullableFilter> get copyWith =>
      CopyWith$Input$IntNullableFilter(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$IntNullableFilter) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$equals = equals;
    final lOther$equals = other.equals;
    if (_$data.containsKey('equals') != other._$data.containsKey('equals')) {
      return false;
    }
    if (l$equals != lOther$equals) {
      return false;
    }
    final l$gt = gt;
    final lOther$gt = other.gt;
    if (_$data.containsKey('gt') != other._$data.containsKey('gt')) {
      return false;
    }
    if (l$gt != lOther$gt) {
      return false;
    }
    final l$gte = gte;
    final lOther$gte = other.gte;
    if (_$data.containsKey('gte') != other._$data.containsKey('gte')) {
      return false;
    }
    if (l$gte != lOther$gte) {
      return false;
    }
    final l$$in = $in;
    final lOther$$in = other.$in;
    if (_$data.containsKey('in') != other._$data.containsKey('in')) {
      return false;
    }
    if (l$$in != null && lOther$$in != null) {
      if (l$$in.length != lOther$$in.length) {
        return false;
      }
      for (int i = 0; i < l$$in.length; i++) {
        final l$$in$entry = l$$in[i];
        final lOther$$in$entry = lOther$$in[i];
        if (l$$in$entry != lOther$$in$entry) {
          return false;
        }
      }
    } else if (l$$in != lOther$$in) {
      return false;
    }
    final l$lt = lt;
    final lOther$lt = other.lt;
    if (_$data.containsKey('lt') != other._$data.containsKey('lt')) {
      return false;
    }
    if (l$lt != lOther$lt) {
      return false;
    }
    final l$lte = lte;
    final lOther$lte = other.lte;
    if (_$data.containsKey('lte') != other._$data.containsKey('lte')) {
      return false;
    }
    if (l$lte != lOther$lte) {
      return false;
    }
    final l$not = not;
    final lOther$not = other.not;
    if (_$data.containsKey('not') != other._$data.containsKey('not')) {
      return false;
    }
    if (l$not != lOther$not) {
      return false;
    }
    final l$notIn = notIn;
    final lOther$notIn = other.notIn;
    if (_$data.containsKey('notIn') != other._$data.containsKey('notIn')) {
      return false;
    }
    if (l$notIn != null && lOther$notIn != null) {
      if (l$notIn.length != lOther$notIn.length) {
        return false;
      }
      for (int i = 0; i < l$notIn.length; i++) {
        final l$notIn$entry = l$notIn[i];
        final lOther$notIn$entry = lOther$notIn[i];
        if (l$notIn$entry != lOther$notIn$entry) {
          return false;
        }
      }
    } else if (l$notIn != lOther$notIn) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$equals = equals;
    final l$gt = gt;
    final l$gte = gte;
    final l$$in = $in;
    final l$lt = lt;
    final l$lte = lte;
    final l$not = not;
    final l$notIn = notIn;
    return Object.hashAll([
      _$data.containsKey('equals') ? l$equals : const {},
      _$data.containsKey('gt') ? l$gt : const {},
      _$data.containsKey('gte') ? l$gte : const {},
      _$data.containsKey('in')
          ? l$$in == null
              ? null
              : Object.hashAll(l$$in.map((v) => v))
          : const {},
      _$data.containsKey('lt') ? l$lt : const {},
      _$data.containsKey('lte') ? l$lte : const {},
      _$data.containsKey('not') ? l$not : const {},
      _$data.containsKey('notIn')
          ? l$notIn == null
              ? null
              : Object.hashAll(l$notIn.map((v) => v))
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$IntNullableFilter<TRes> {
  factory CopyWith$Input$IntNullableFilter(
    Input$IntNullableFilter instance,
    TRes Function(Input$IntNullableFilter) then,
  ) = _CopyWithImpl$Input$IntNullableFilter;

  factory CopyWith$Input$IntNullableFilter.stub(TRes res) =
      _CopyWithStubImpl$Input$IntNullableFilter;

  TRes call({
    int? equals,
    int? gt,
    int? gte,
    List<int>? $in,
    int? lt,
    int? lte,
    Input$NestedIntNullableFilter? not,
    List<int>? notIn,
  });
  CopyWith$Input$NestedIntNullableFilter<TRes> get not;
}

class _CopyWithImpl$Input$IntNullableFilter<TRes>
    implements CopyWith$Input$IntNullableFilter<TRes> {
  _CopyWithImpl$Input$IntNullableFilter(
    this._instance,
    this._then,
  );

  final Input$IntNullableFilter _instance;

  final TRes Function(Input$IntNullableFilter) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? equals = _undefined,
    Object? gt = _undefined,
    Object? gte = _undefined,
    Object? $in = _undefined,
    Object? lt = _undefined,
    Object? lte = _undefined,
    Object? not = _undefined,
    Object? notIn = _undefined,
  }) =>
      _then(Input$IntNullableFilter._({
        ..._instance._$data,
        if (equals != _undefined) 'equals': (equals as int?),
        if (gt != _undefined) 'gt': (gt as int?),
        if (gte != _undefined) 'gte': (gte as int?),
        if ($in != _undefined) 'in': ($in as List<int>?),
        if (lt != _undefined) 'lt': (lt as int?),
        if (lte != _undefined) 'lte': (lte as int?),
        if (not != _undefined) 'not': (not as Input$NestedIntNullableFilter?),
        if (notIn != _undefined) 'notIn': (notIn as List<int>?),
      }));

  CopyWith$Input$NestedIntNullableFilter<TRes> get not {
    final local$not = _instance.not;
    return local$not == null
        ? CopyWith$Input$NestedIntNullableFilter.stub(_then(_instance))
        : CopyWith$Input$NestedIntNullableFilter(
            local$not, (e) => call(not: e));
  }
}

class _CopyWithStubImpl$Input$IntNullableFilter<TRes>
    implements CopyWith$Input$IntNullableFilter<TRes> {
  _CopyWithStubImpl$Input$IntNullableFilter(this._res);

  TRes _res;

  call({
    int? equals,
    int? gt,
    int? gte,
    List<int>? $in,
    int? lt,
    int? lte,
    Input$NestedIntNullableFilter? not,
    List<int>? notIn,
  }) =>
      _res;

  CopyWith$Input$NestedIntNullableFilter<TRes> get not =>
      CopyWith$Input$NestedIntNullableFilter.stub(_res);
}

class Input$IntNullableWithAggregatesFilter {
  factory Input$IntNullableWithAggregatesFilter({
    Input$NestedFloatNullableFilter? $_avg,
    Input$NestedIntNullableFilter? $_count,
    Input$NestedIntNullableFilter? $_max,
    Input$NestedIntNullableFilter? $_min,
    Input$NestedIntNullableFilter? $_sum,
    int? equals,
    int? gt,
    int? gte,
    List<int>? $in,
    int? lt,
    int? lte,
    Input$NestedIntNullableWithAggregatesFilter? not,
    List<int>? notIn,
  }) =>
      Input$IntNullableWithAggregatesFilter._({
        if ($_avg != null) r'_avg': $_avg,
        if ($_count != null) r'_count': $_count,
        if ($_max != null) r'_max': $_max,
        if ($_min != null) r'_min': $_min,
        if ($_sum != null) r'_sum': $_sum,
        if (equals != null) r'equals': equals,
        if (gt != null) r'gt': gt,
        if (gte != null) r'gte': gte,
        if ($in != null) r'in': $in,
        if (lt != null) r'lt': lt,
        if (lte != null) r'lte': lte,
        if (not != null) r'not': not,
        if (notIn != null) r'notIn': notIn,
      });

  Input$IntNullableWithAggregatesFilter._(this._$data);

  factory Input$IntNullableWithAggregatesFilter.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('_avg')) {
      final l$$_avg = data['_avg'];
      result$data['_avg'] = l$$_avg == null
          ? null
          : Input$NestedFloatNullableFilter.fromJson(
              (l$$_avg as Map<String, dynamic>));
    }
    if (data.containsKey('_count')) {
      final l$$_count = data['_count'];
      result$data['_count'] = l$$_count == null
          ? null
          : Input$NestedIntNullableFilter.fromJson(
              (l$$_count as Map<String, dynamic>));
    }
    if (data.containsKey('_max')) {
      final l$$_max = data['_max'];
      result$data['_max'] = l$$_max == null
          ? null
          : Input$NestedIntNullableFilter.fromJson(
              (l$$_max as Map<String, dynamic>));
    }
    if (data.containsKey('_min')) {
      final l$$_min = data['_min'];
      result$data['_min'] = l$$_min == null
          ? null
          : Input$NestedIntNullableFilter.fromJson(
              (l$$_min as Map<String, dynamic>));
    }
    if (data.containsKey('_sum')) {
      final l$$_sum = data['_sum'];
      result$data['_sum'] = l$$_sum == null
          ? null
          : Input$NestedIntNullableFilter.fromJson(
              (l$$_sum as Map<String, dynamic>));
    }
    if (data.containsKey('equals')) {
      final l$equals = data['equals'];
      result$data['equals'] = (l$equals as int?);
    }
    if (data.containsKey('gt')) {
      final l$gt = data['gt'];
      result$data['gt'] = (l$gt as int?);
    }
    if (data.containsKey('gte')) {
      final l$gte = data['gte'];
      result$data['gte'] = (l$gte as int?);
    }
    if (data.containsKey('in')) {
      final l$$in = data['in'];
      result$data['in'] =
          (l$$in as List<dynamic>?)?.map((e) => (e as int)).toList();
    }
    if (data.containsKey('lt')) {
      final l$lt = data['lt'];
      result$data['lt'] = (l$lt as int?);
    }
    if (data.containsKey('lte')) {
      final l$lte = data['lte'];
      result$data['lte'] = (l$lte as int?);
    }
    if (data.containsKey('not')) {
      final l$not = data['not'];
      result$data['not'] = l$not == null
          ? null
          : Input$NestedIntNullableWithAggregatesFilter.fromJson(
              (l$not as Map<String, dynamic>));
    }
    if (data.containsKey('notIn')) {
      final l$notIn = data['notIn'];
      result$data['notIn'] =
          (l$notIn as List<dynamic>?)?.map((e) => (e as int)).toList();
    }
    return Input$IntNullableWithAggregatesFilter._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$NestedFloatNullableFilter? get $_avg =>
      (_$data['_avg'] as Input$NestedFloatNullableFilter?);

  Input$NestedIntNullableFilter? get $_count =>
      (_$data['_count'] as Input$NestedIntNullableFilter?);

  Input$NestedIntNullableFilter? get $_max =>
      (_$data['_max'] as Input$NestedIntNullableFilter?);

  Input$NestedIntNullableFilter? get $_min =>
      (_$data['_min'] as Input$NestedIntNullableFilter?);

  Input$NestedIntNullableFilter? get $_sum =>
      (_$data['_sum'] as Input$NestedIntNullableFilter?);

  int? get equals => (_$data['equals'] as int?);

  int? get gt => (_$data['gt'] as int?);

  int? get gte => (_$data['gte'] as int?);

  List<int>? get $in => (_$data['in'] as List<int>?);

  int? get lt => (_$data['lt'] as int?);

  int? get lte => (_$data['lte'] as int?);

  Input$NestedIntNullableWithAggregatesFilter? get not =>
      (_$data['not'] as Input$NestedIntNullableWithAggregatesFilter?);

  List<int>? get notIn => (_$data['notIn'] as List<int>?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('_avg')) {
      final l$$_avg = $_avg;
      result$data['_avg'] = l$$_avg?.toJson();
    }
    if (_$data.containsKey('_count')) {
      final l$$_count = $_count;
      result$data['_count'] = l$$_count?.toJson();
    }
    if (_$data.containsKey('_max')) {
      final l$$_max = $_max;
      result$data['_max'] = l$$_max?.toJson();
    }
    if (_$data.containsKey('_min')) {
      final l$$_min = $_min;
      result$data['_min'] = l$$_min?.toJson();
    }
    if (_$data.containsKey('_sum')) {
      final l$$_sum = $_sum;
      result$data['_sum'] = l$$_sum?.toJson();
    }
    if (_$data.containsKey('equals')) {
      final l$equals = equals;
      result$data['equals'] = l$equals;
    }
    if (_$data.containsKey('gt')) {
      final l$gt = gt;
      result$data['gt'] = l$gt;
    }
    if (_$data.containsKey('gte')) {
      final l$gte = gte;
      result$data['gte'] = l$gte;
    }
    if (_$data.containsKey('in')) {
      final l$$in = $in;
      result$data['in'] = l$$in?.map((e) => e).toList();
    }
    if (_$data.containsKey('lt')) {
      final l$lt = lt;
      result$data['lt'] = l$lt;
    }
    if (_$data.containsKey('lte')) {
      final l$lte = lte;
      result$data['lte'] = l$lte;
    }
    if (_$data.containsKey('not')) {
      final l$not = not;
      result$data['not'] = l$not?.toJson();
    }
    if (_$data.containsKey('notIn')) {
      final l$notIn = notIn;
      result$data['notIn'] = l$notIn?.map((e) => e).toList();
    }
    return result$data;
  }

  CopyWith$Input$IntNullableWithAggregatesFilter<
          Input$IntNullableWithAggregatesFilter>
      get copyWith => CopyWith$Input$IntNullableWithAggregatesFilter(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$IntNullableWithAggregatesFilter) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$$_avg = $_avg;
    final lOther$$_avg = other.$_avg;
    if (_$data.containsKey('_avg') != other._$data.containsKey('_avg')) {
      return false;
    }
    if (l$$_avg != lOther$$_avg) {
      return false;
    }
    final l$$_count = $_count;
    final lOther$$_count = other.$_count;
    if (_$data.containsKey('_count') != other._$data.containsKey('_count')) {
      return false;
    }
    if (l$$_count != lOther$$_count) {
      return false;
    }
    final l$$_max = $_max;
    final lOther$$_max = other.$_max;
    if (_$data.containsKey('_max') != other._$data.containsKey('_max')) {
      return false;
    }
    if (l$$_max != lOther$$_max) {
      return false;
    }
    final l$$_min = $_min;
    final lOther$$_min = other.$_min;
    if (_$data.containsKey('_min') != other._$data.containsKey('_min')) {
      return false;
    }
    if (l$$_min != lOther$$_min) {
      return false;
    }
    final l$$_sum = $_sum;
    final lOther$$_sum = other.$_sum;
    if (_$data.containsKey('_sum') != other._$data.containsKey('_sum')) {
      return false;
    }
    if (l$$_sum != lOther$$_sum) {
      return false;
    }
    final l$equals = equals;
    final lOther$equals = other.equals;
    if (_$data.containsKey('equals') != other._$data.containsKey('equals')) {
      return false;
    }
    if (l$equals != lOther$equals) {
      return false;
    }
    final l$gt = gt;
    final lOther$gt = other.gt;
    if (_$data.containsKey('gt') != other._$data.containsKey('gt')) {
      return false;
    }
    if (l$gt != lOther$gt) {
      return false;
    }
    final l$gte = gte;
    final lOther$gte = other.gte;
    if (_$data.containsKey('gte') != other._$data.containsKey('gte')) {
      return false;
    }
    if (l$gte != lOther$gte) {
      return false;
    }
    final l$$in = $in;
    final lOther$$in = other.$in;
    if (_$data.containsKey('in') != other._$data.containsKey('in')) {
      return false;
    }
    if (l$$in != null && lOther$$in != null) {
      if (l$$in.length != lOther$$in.length) {
        return false;
      }
      for (int i = 0; i < l$$in.length; i++) {
        final l$$in$entry = l$$in[i];
        final lOther$$in$entry = lOther$$in[i];
        if (l$$in$entry != lOther$$in$entry) {
          return false;
        }
      }
    } else if (l$$in != lOther$$in) {
      return false;
    }
    final l$lt = lt;
    final lOther$lt = other.lt;
    if (_$data.containsKey('lt') != other._$data.containsKey('lt')) {
      return false;
    }
    if (l$lt != lOther$lt) {
      return false;
    }
    final l$lte = lte;
    final lOther$lte = other.lte;
    if (_$data.containsKey('lte') != other._$data.containsKey('lte')) {
      return false;
    }
    if (l$lte != lOther$lte) {
      return false;
    }
    final l$not = not;
    final lOther$not = other.not;
    if (_$data.containsKey('not') != other._$data.containsKey('not')) {
      return false;
    }
    if (l$not != lOther$not) {
      return false;
    }
    final l$notIn = notIn;
    final lOther$notIn = other.notIn;
    if (_$data.containsKey('notIn') != other._$data.containsKey('notIn')) {
      return false;
    }
    if (l$notIn != null && lOther$notIn != null) {
      if (l$notIn.length != lOther$notIn.length) {
        return false;
      }
      for (int i = 0; i < l$notIn.length; i++) {
        final l$notIn$entry = l$notIn[i];
        final lOther$notIn$entry = lOther$notIn[i];
        if (l$notIn$entry != lOther$notIn$entry) {
          return false;
        }
      }
    } else if (l$notIn != lOther$notIn) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$$_avg = $_avg;
    final l$$_count = $_count;
    final l$$_max = $_max;
    final l$$_min = $_min;
    final l$$_sum = $_sum;
    final l$equals = equals;
    final l$gt = gt;
    final l$gte = gte;
    final l$$in = $in;
    final l$lt = lt;
    final l$lte = lte;
    final l$not = not;
    final l$notIn = notIn;
    return Object.hashAll([
      _$data.containsKey('_avg') ? l$$_avg : const {},
      _$data.containsKey('_count') ? l$$_count : const {},
      _$data.containsKey('_max') ? l$$_max : const {},
      _$data.containsKey('_min') ? l$$_min : const {},
      _$data.containsKey('_sum') ? l$$_sum : const {},
      _$data.containsKey('equals') ? l$equals : const {},
      _$data.containsKey('gt') ? l$gt : const {},
      _$data.containsKey('gte') ? l$gte : const {},
      _$data.containsKey('in')
          ? l$$in == null
              ? null
              : Object.hashAll(l$$in.map((v) => v))
          : const {},
      _$data.containsKey('lt') ? l$lt : const {},
      _$data.containsKey('lte') ? l$lte : const {},
      _$data.containsKey('not') ? l$not : const {},
      _$data.containsKey('notIn')
          ? l$notIn == null
              ? null
              : Object.hashAll(l$notIn.map((v) => v))
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$IntNullableWithAggregatesFilter<TRes> {
  factory CopyWith$Input$IntNullableWithAggregatesFilter(
    Input$IntNullableWithAggregatesFilter instance,
    TRes Function(Input$IntNullableWithAggregatesFilter) then,
  ) = _CopyWithImpl$Input$IntNullableWithAggregatesFilter;

  factory CopyWith$Input$IntNullableWithAggregatesFilter.stub(TRes res) =
      _CopyWithStubImpl$Input$IntNullableWithAggregatesFilter;

  TRes call({
    Input$NestedFloatNullableFilter? $_avg,
    Input$NestedIntNullableFilter? $_count,
    Input$NestedIntNullableFilter? $_max,
    Input$NestedIntNullableFilter? $_min,
    Input$NestedIntNullableFilter? $_sum,
    int? equals,
    int? gt,
    int? gte,
    List<int>? $in,
    int? lt,
    int? lte,
    Input$NestedIntNullableWithAggregatesFilter? not,
    List<int>? notIn,
  });
  CopyWith$Input$NestedFloatNullableFilter<TRes> get $_avg;
  CopyWith$Input$NestedIntNullableFilter<TRes> get $_count;
  CopyWith$Input$NestedIntNullableFilter<TRes> get $_max;
  CopyWith$Input$NestedIntNullableFilter<TRes> get $_min;
  CopyWith$Input$NestedIntNullableFilter<TRes> get $_sum;
  CopyWith$Input$NestedIntNullableWithAggregatesFilter<TRes> get not;
}

class _CopyWithImpl$Input$IntNullableWithAggregatesFilter<TRes>
    implements CopyWith$Input$IntNullableWithAggregatesFilter<TRes> {
  _CopyWithImpl$Input$IntNullableWithAggregatesFilter(
    this._instance,
    this._then,
  );

  final Input$IntNullableWithAggregatesFilter _instance;

  final TRes Function(Input$IntNullableWithAggregatesFilter) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? $_avg = _undefined,
    Object? $_count = _undefined,
    Object? $_max = _undefined,
    Object? $_min = _undefined,
    Object? $_sum = _undefined,
    Object? equals = _undefined,
    Object? gt = _undefined,
    Object? gte = _undefined,
    Object? $in = _undefined,
    Object? lt = _undefined,
    Object? lte = _undefined,
    Object? not = _undefined,
    Object? notIn = _undefined,
  }) =>
      _then(Input$IntNullableWithAggregatesFilter._({
        ..._instance._$data,
        if ($_avg != _undefined)
          '_avg': ($_avg as Input$NestedFloatNullableFilter?),
        if ($_count != _undefined)
          '_count': ($_count as Input$NestedIntNullableFilter?),
        if ($_max != _undefined)
          '_max': ($_max as Input$NestedIntNullableFilter?),
        if ($_min != _undefined)
          '_min': ($_min as Input$NestedIntNullableFilter?),
        if ($_sum != _undefined)
          '_sum': ($_sum as Input$NestedIntNullableFilter?),
        if (equals != _undefined) 'equals': (equals as int?),
        if (gt != _undefined) 'gt': (gt as int?),
        if (gte != _undefined) 'gte': (gte as int?),
        if ($in != _undefined) 'in': ($in as List<int>?),
        if (lt != _undefined) 'lt': (lt as int?),
        if (lte != _undefined) 'lte': (lte as int?),
        if (not != _undefined)
          'not': (not as Input$NestedIntNullableWithAggregatesFilter?),
        if (notIn != _undefined) 'notIn': (notIn as List<int>?),
      }));

  CopyWith$Input$NestedFloatNullableFilter<TRes> get $_avg {
    final local$$_avg = _instance.$_avg;
    return local$$_avg == null
        ? CopyWith$Input$NestedFloatNullableFilter.stub(_then(_instance))
        : CopyWith$Input$NestedFloatNullableFilter(
            local$$_avg, (e) => call($_avg: e));
  }

  CopyWith$Input$NestedIntNullableFilter<TRes> get $_count {
    final local$$_count = _instance.$_count;
    return local$$_count == null
        ? CopyWith$Input$NestedIntNullableFilter.stub(_then(_instance))
        : CopyWith$Input$NestedIntNullableFilter(
            local$$_count, (e) => call($_count: e));
  }

  CopyWith$Input$NestedIntNullableFilter<TRes> get $_max {
    final local$$_max = _instance.$_max;
    return local$$_max == null
        ? CopyWith$Input$NestedIntNullableFilter.stub(_then(_instance))
        : CopyWith$Input$NestedIntNullableFilter(
            local$$_max, (e) => call($_max: e));
  }

  CopyWith$Input$NestedIntNullableFilter<TRes> get $_min {
    final local$$_min = _instance.$_min;
    return local$$_min == null
        ? CopyWith$Input$NestedIntNullableFilter.stub(_then(_instance))
        : CopyWith$Input$NestedIntNullableFilter(
            local$$_min, (e) => call($_min: e));
  }

  CopyWith$Input$NestedIntNullableFilter<TRes> get $_sum {
    final local$$_sum = _instance.$_sum;
    return local$$_sum == null
        ? CopyWith$Input$NestedIntNullableFilter.stub(_then(_instance))
        : CopyWith$Input$NestedIntNullableFilter(
            local$$_sum, (e) => call($_sum: e));
  }

  CopyWith$Input$NestedIntNullableWithAggregatesFilter<TRes> get not {
    final local$not = _instance.not;
    return local$not == null
        ? CopyWith$Input$NestedIntNullableWithAggregatesFilter.stub(
            _then(_instance))
        : CopyWith$Input$NestedIntNullableWithAggregatesFilter(
            local$not, (e) => call(not: e));
  }
}

class _CopyWithStubImpl$Input$IntNullableWithAggregatesFilter<TRes>
    implements CopyWith$Input$IntNullableWithAggregatesFilter<TRes> {
  _CopyWithStubImpl$Input$IntNullableWithAggregatesFilter(this._res);

  TRes _res;

  call({
    Input$NestedFloatNullableFilter? $_avg,
    Input$NestedIntNullableFilter? $_count,
    Input$NestedIntNullableFilter? $_max,
    Input$NestedIntNullableFilter? $_min,
    Input$NestedIntNullableFilter? $_sum,
    int? equals,
    int? gt,
    int? gte,
    List<int>? $in,
    int? lt,
    int? lte,
    Input$NestedIntNullableWithAggregatesFilter? not,
    List<int>? notIn,
  }) =>
      _res;

  CopyWith$Input$NestedFloatNullableFilter<TRes> get $_avg =>
      CopyWith$Input$NestedFloatNullableFilter.stub(_res);

  CopyWith$Input$NestedIntNullableFilter<TRes> get $_count =>
      CopyWith$Input$NestedIntNullableFilter.stub(_res);

  CopyWith$Input$NestedIntNullableFilter<TRes> get $_max =>
      CopyWith$Input$NestedIntNullableFilter.stub(_res);

  CopyWith$Input$NestedIntNullableFilter<TRes> get $_min =>
      CopyWith$Input$NestedIntNullableFilter.stub(_res);

  CopyWith$Input$NestedIntNullableFilter<TRes> get $_sum =>
      CopyWith$Input$NestedIntNullableFilter.stub(_res);

  CopyWith$Input$NestedIntNullableWithAggregatesFilter<TRes> get not =>
      CopyWith$Input$NestedIntNullableWithAggregatesFilter.stub(_res);
}

class Input$NestedBoolFilter {
  factory Input$NestedBoolFilter({
    bool? equals,
    Input$NestedBoolFilter? not,
  }) =>
      Input$NestedBoolFilter._({
        if (equals != null) r'equals': equals,
        if (not != null) r'not': not,
      });

  Input$NestedBoolFilter._(this._$data);

  factory Input$NestedBoolFilter.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('equals')) {
      final l$equals = data['equals'];
      result$data['equals'] = (l$equals as bool?);
    }
    if (data.containsKey('not')) {
      final l$not = data['not'];
      result$data['not'] = l$not == null
          ? null
          : Input$NestedBoolFilter.fromJson((l$not as Map<String, dynamic>));
    }
    return Input$NestedBoolFilter._(result$data);
  }

  Map<String, dynamic> _$data;

  bool? get equals => (_$data['equals'] as bool?);

  Input$NestedBoolFilter? get not => (_$data['not'] as Input$NestedBoolFilter?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('equals')) {
      final l$equals = equals;
      result$data['equals'] = l$equals;
    }
    if (_$data.containsKey('not')) {
      final l$not = not;
      result$data['not'] = l$not?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$NestedBoolFilter<Input$NestedBoolFilter> get copyWith =>
      CopyWith$Input$NestedBoolFilter(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$NestedBoolFilter) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$equals = equals;
    final lOther$equals = other.equals;
    if (_$data.containsKey('equals') != other._$data.containsKey('equals')) {
      return false;
    }
    if (l$equals != lOther$equals) {
      return false;
    }
    final l$not = not;
    final lOther$not = other.not;
    if (_$data.containsKey('not') != other._$data.containsKey('not')) {
      return false;
    }
    if (l$not != lOther$not) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$equals = equals;
    final l$not = not;
    return Object.hashAll([
      _$data.containsKey('equals') ? l$equals : const {},
      _$data.containsKey('not') ? l$not : const {},
    ]);
  }
}

abstract class CopyWith$Input$NestedBoolFilter<TRes> {
  factory CopyWith$Input$NestedBoolFilter(
    Input$NestedBoolFilter instance,
    TRes Function(Input$NestedBoolFilter) then,
  ) = _CopyWithImpl$Input$NestedBoolFilter;

  factory CopyWith$Input$NestedBoolFilter.stub(TRes res) =
      _CopyWithStubImpl$Input$NestedBoolFilter;

  TRes call({
    bool? equals,
    Input$NestedBoolFilter? not,
  });
  CopyWith$Input$NestedBoolFilter<TRes> get not;
}

class _CopyWithImpl$Input$NestedBoolFilter<TRes>
    implements CopyWith$Input$NestedBoolFilter<TRes> {
  _CopyWithImpl$Input$NestedBoolFilter(
    this._instance,
    this._then,
  );

  final Input$NestedBoolFilter _instance;

  final TRes Function(Input$NestedBoolFilter) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? equals = _undefined,
    Object? not = _undefined,
  }) =>
      _then(Input$NestedBoolFilter._({
        ..._instance._$data,
        if (equals != _undefined) 'equals': (equals as bool?),
        if (not != _undefined) 'not': (not as Input$NestedBoolFilter?),
      }));

  CopyWith$Input$NestedBoolFilter<TRes> get not {
    final local$not = _instance.not;
    return local$not == null
        ? CopyWith$Input$NestedBoolFilter.stub(_then(_instance))
        : CopyWith$Input$NestedBoolFilter(local$not, (e) => call(not: e));
  }
}

class _CopyWithStubImpl$Input$NestedBoolFilter<TRes>
    implements CopyWith$Input$NestedBoolFilter<TRes> {
  _CopyWithStubImpl$Input$NestedBoolFilter(this._res);

  TRes _res;

  call({
    bool? equals,
    Input$NestedBoolFilter? not,
  }) =>
      _res;

  CopyWith$Input$NestedBoolFilter<TRes> get not =>
      CopyWith$Input$NestedBoolFilter.stub(_res);
}

class Input$NestedBoolWithAggregatesFilter {
  factory Input$NestedBoolWithAggregatesFilter({
    Input$NestedIntFilter? $_count,
    Input$NestedBoolFilter? $_max,
    Input$NestedBoolFilter? $_min,
    bool? equals,
    Input$NestedBoolWithAggregatesFilter? not,
  }) =>
      Input$NestedBoolWithAggregatesFilter._({
        if ($_count != null) r'_count': $_count,
        if ($_max != null) r'_max': $_max,
        if ($_min != null) r'_min': $_min,
        if (equals != null) r'equals': equals,
        if (not != null) r'not': not,
      });

  Input$NestedBoolWithAggregatesFilter._(this._$data);

  factory Input$NestedBoolWithAggregatesFilter.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('_count')) {
      final l$$_count = data['_count'];
      result$data['_count'] = l$$_count == null
          ? null
          : Input$NestedIntFilter.fromJson((l$$_count as Map<String, dynamic>));
    }
    if (data.containsKey('_max')) {
      final l$$_max = data['_max'];
      result$data['_max'] = l$$_max == null
          ? null
          : Input$NestedBoolFilter.fromJson((l$$_max as Map<String, dynamic>));
    }
    if (data.containsKey('_min')) {
      final l$$_min = data['_min'];
      result$data['_min'] = l$$_min == null
          ? null
          : Input$NestedBoolFilter.fromJson((l$$_min as Map<String, dynamic>));
    }
    if (data.containsKey('equals')) {
      final l$equals = data['equals'];
      result$data['equals'] = (l$equals as bool?);
    }
    if (data.containsKey('not')) {
      final l$not = data['not'];
      result$data['not'] = l$not == null
          ? null
          : Input$NestedBoolWithAggregatesFilter.fromJson(
              (l$not as Map<String, dynamic>));
    }
    return Input$NestedBoolWithAggregatesFilter._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$NestedIntFilter? get $_count =>
      (_$data['_count'] as Input$NestedIntFilter?);

  Input$NestedBoolFilter? get $_max =>
      (_$data['_max'] as Input$NestedBoolFilter?);

  Input$NestedBoolFilter? get $_min =>
      (_$data['_min'] as Input$NestedBoolFilter?);

  bool? get equals => (_$data['equals'] as bool?);

  Input$NestedBoolWithAggregatesFilter? get not =>
      (_$data['not'] as Input$NestedBoolWithAggregatesFilter?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('_count')) {
      final l$$_count = $_count;
      result$data['_count'] = l$$_count?.toJson();
    }
    if (_$data.containsKey('_max')) {
      final l$$_max = $_max;
      result$data['_max'] = l$$_max?.toJson();
    }
    if (_$data.containsKey('_min')) {
      final l$$_min = $_min;
      result$data['_min'] = l$$_min?.toJson();
    }
    if (_$data.containsKey('equals')) {
      final l$equals = equals;
      result$data['equals'] = l$equals;
    }
    if (_$data.containsKey('not')) {
      final l$not = not;
      result$data['not'] = l$not?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$NestedBoolWithAggregatesFilter<
          Input$NestedBoolWithAggregatesFilter>
      get copyWith => CopyWith$Input$NestedBoolWithAggregatesFilter(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$NestedBoolWithAggregatesFilter) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$$_count = $_count;
    final lOther$$_count = other.$_count;
    if (_$data.containsKey('_count') != other._$data.containsKey('_count')) {
      return false;
    }
    if (l$$_count != lOther$$_count) {
      return false;
    }
    final l$$_max = $_max;
    final lOther$$_max = other.$_max;
    if (_$data.containsKey('_max') != other._$data.containsKey('_max')) {
      return false;
    }
    if (l$$_max != lOther$$_max) {
      return false;
    }
    final l$$_min = $_min;
    final lOther$$_min = other.$_min;
    if (_$data.containsKey('_min') != other._$data.containsKey('_min')) {
      return false;
    }
    if (l$$_min != lOther$$_min) {
      return false;
    }
    final l$equals = equals;
    final lOther$equals = other.equals;
    if (_$data.containsKey('equals') != other._$data.containsKey('equals')) {
      return false;
    }
    if (l$equals != lOther$equals) {
      return false;
    }
    final l$not = not;
    final lOther$not = other.not;
    if (_$data.containsKey('not') != other._$data.containsKey('not')) {
      return false;
    }
    if (l$not != lOther$not) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$$_count = $_count;
    final l$$_max = $_max;
    final l$$_min = $_min;
    final l$equals = equals;
    final l$not = not;
    return Object.hashAll([
      _$data.containsKey('_count') ? l$$_count : const {},
      _$data.containsKey('_max') ? l$$_max : const {},
      _$data.containsKey('_min') ? l$$_min : const {},
      _$data.containsKey('equals') ? l$equals : const {},
      _$data.containsKey('not') ? l$not : const {},
    ]);
  }
}

abstract class CopyWith$Input$NestedBoolWithAggregatesFilter<TRes> {
  factory CopyWith$Input$NestedBoolWithAggregatesFilter(
    Input$NestedBoolWithAggregatesFilter instance,
    TRes Function(Input$NestedBoolWithAggregatesFilter) then,
  ) = _CopyWithImpl$Input$NestedBoolWithAggregatesFilter;

  factory CopyWith$Input$NestedBoolWithAggregatesFilter.stub(TRes res) =
      _CopyWithStubImpl$Input$NestedBoolWithAggregatesFilter;

  TRes call({
    Input$NestedIntFilter? $_count,
    Input$NestedBoolFilter? $_max,
    Input$NestedBoolFilter? $_min,
    bool? equals,
    Input$NestedBoolWithAggregatesFilter? not,
  });
  CopyWith$Input$NestedIntFilter<TRes> get $_count;
  CopyWith$Input$NestedBoolFilter<TRes> get $_max;
  CopyWith$Input$NestedBoolFilter<TRes> get $_min;
  CopyWith$Input$NestedBoolWithAggregatesFilter<TRes> get not;
}

class _CopyWithImpl$Input$NestedBoolWithAggregatesFilter<TRes>
    implements CopyWith$Input$NestedBoolWithAggregatesFilter<TRes> {
  _CopyWithImpl$Input$NestedBoolWithAggregatesFilter(
    this._instance,
    this._then,
  );

  final Input$NestedBoolWithAggregatesFilter _instance;

  final TRes Function(Input$NestedBoolWithAggregatesFilter) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? $_count = _undefined,
    Object? $_max = _undefined,
    Object? $_min = _undefined,
    Object? equals = _undefined,
    Object? not = _undefined,
  }) =>
      _then(Input$NestedBoolWithAggregatesFilter._({
        ..._instance._$data,
        if ($_count != _undefined)
          '_count': ($_count as Input$NestedIntFilter?),
        if ($_max != _undefined) '_max': ($_max as Input$NestedBoolFilter?),
        if ($_min != _undefined) '_min': ($_min as Input$NestedBoolFilter?),
        if (equals != _undefined) 'equals': (equals as bool?),
        if (not != _undefined)
          'not': (not as Input$NestedBoolWithAggregatesFilter?),
      }));

  CopyWith$Input$NestedIntFilter<TRes> get $_count {
    final local$$_count = _instance.$_count;
    return local$$_count == null
        ? CopyWith$Input$NestedIntFilter.stub(_then(_instance))
        : CopyWith$Input$NestedIntFilter(
            local$$_count, (e) => call($_count: e));
  }

  CopyWith$Input$NestedBoolFilter<TRes> get $_max {
    final local$$_max = _instance.$_max;
    return local$$_max == null
        ? CopyWith$Input$NestedBoolFilter.stub(_then(_instance))
        : CopyWith$Input$NestedBoolFilter(local$$_max, (e) => call($_max: e));
  }

  CopyWith$Input$NestedBoolFilter<TRes> get $_min {
    final local$$_min = _instance.$_min;
    return local$$_min == null
        ? CopyWith$Input$NestedBoolFilter.stub(_then(_instance))
        : CopyWith$Input$NestedBoolFilter(local$$_min, (e) => call($_min: e));
  }

  CopyWith$Input$NestedBoolWithAggregatesFilter<TRes> get not {
    final local$not = _instance.not;
    return local$not == null
        ? CopyWith$Input$NestedBoolWithAggregatesFilter.stub(_then(_instance))
        : CopyWith$Input$NestedBoolWithAggregatesFilter(
            local$not, (e) => call(not: e));
  }
}

class _CopyWithStubImpl$Input$NestedBoolWithAggregatesFilter<TRes>
    implements CopyWith$Input$NestedBoolWithAggregatesFilter<TRes> {
  _CopyWithStubImpl$Input$NestedBoolWithAggregatesFilter(this._res);

  TRes _res;

  call({
    Input$NestedIntFilter? $_count,
    Input$NestedBoolFilter? $_max,
    Input$NestedBoolFilter? $_min,
    bool? equals,
    Input$NestedBoolWithAggregatesFilter? not,
  }) =>
      _res;

  CopyWith$Input$NestedIntFilter<TRes> get $_count =>
      CopyWith$Input$NestedIntFilter.stub(_res);

  CopyWith$Input$NestedBoolFilter<TRes> get $_max =>
      CopyWith$Input$NestedBoolFilter.stub(_res);

  CopyWith$Input$NestedBoolFilter<TRes> get $_min =>
      CopyWith$Input$NestedBoolFilter.stub(_res);

  CopyWith$Input$NestedBoolWithAggregatesFilter<TRes> get not =>
      CopyWith$Input$NestedBoolWithAggregatesFilter.stub(_res);
}

class Input$NestedDateTimeFilter {
  factory Input$NestedDateTimeFilter({
    String? equals,
    String? gt,
    String? gte,
    List<String>? $in,
    String? lt,
    String? lte,
    Input$NestedDateTimeFilter? not,
    List<String>? notIn,
  }) =>
      Input$NestedDateTimeFilter._({
        if (equals != null) r'equals': equals,
        if (gt != null) r'gt': gt,
        if (gte != null) r'gte': gte,
        if ($in != null) r'in': $in,
        if (lt != null) r'lt': lt,
        if (lte != null) r'lte': lte,
        if (not != null) r'not': not,
        if (notIn != null) r'notIn': notIn,
      });

  Input$NestedDateTimeFilter._(this._$data);

  factory Input$NestedDateTimeFilter.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('equals')) {
      final l$equals = data['equals'];
      result$data['equals'] = (l$equals as String?);
    }
    if (data.containsKey('gt')) {
      final l$gt = data['gt'];
      result$data['gt'] = (l$gt as String?);
    }
    if (data.containsKey('gte')) {
      final l$gte = data['gte'];
      result$data['gte'] = (l$gte as String?);
    }
    if (data.containsKey('in')) {
      final l$$in = data['in'];
      result$data['in'] =
          (l$$in as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    if (data.containsKey('lt')) {
      final l$lt = data['lt'];
      result$data['lt'] = (l$lt as String?);
    }
    if (data.containsKey('lte')) {
      final l$lte = data['lte'];
      result$data['lte'] = (l$lte as String?);
    }
    if (data.containsKey('not')) {
      final l$not = data['not'];
      result$data['not'] = l$not == null
          ? null
          : Input$NestedDateTimeFilter.fromJson(
              (l$not as Map<String, dynamic>));
    }
    if (data.containsKey('notIn')) {
      final l$notIn = data['notIn'];
      result$data['notIn'] =
          (l$notIn as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    return Input$NestedDateTimeFilter._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get equals => (_$data['equals'] as String?);

  String? get gt => (_$data['gt'] as String?);

  String? get gte => (_$data['gte'] as String?);

  List<String>? get $in => (_$data['in'] as List<String>?);

  String? get lt => (_$data['lt'] as String?);

  String? get lte => (_$data['lte'] as String?);

  Input$NestedDateTimeFilter? get not =>
      (_$data['not'] as Input$NestedDateTimeFilter?);

  List<String>? get notIn => (_$data['notIn'] as List<String>?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('equals')) {
      final l$equals = equals;
      result$data['equals'] = l$equals;
    }
    if (_$data.containsKey('gt')) {
      final l$gt = gt;
      result$data['gt'] = l$gt;
    }
    if (_$data.containsKey('gte')) {
      final l$gte = gte;
      result$data['gte'] = l$gte;
    }
    if (_$data.containsKey('in')) {
      final l$$in = $in;
      result$data['in'] = l$$in?.map((e) => e).toList();
    }
    if (_$data.containsKey('lt')) {
      final l$lt = lt;
      result$data['lt'] = l$lt;
    }
    if (_$data.containsKey('lte')) {
      final l$lte = lte;
      result$data['lte'] = l$lte;
    }
    if (_$data.containsKey('not')) {
      final l$not = not;
      result$data['not'] = l$not?.toJson();
    }
    if (_$data.containsKey('notIn')) {
      final l$notIn = notIn;
      result$data['notIn'] = l$notIn?.map((e) => e).toList();
    }
    return result$data;
  }

  CopyWith$Input$NestedDateTimeFilter<Input$NestedDateTimeFilter>
      get copyWith => CopyWith$Input$NestedDateTimeFilter(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$NestedDateTimeFilter) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$equals = equals;
    final lOther$equals = other.equals;
    if (_$data.containsKey('equals') != other._$data.containsKey('equals')) {
      return false;
    }
    if (l$equals != lOther$equals) {
      return false;
    }
    final l$gt = gt;
    final lOther$gt = other.gt;
    if (_$data.containsKey('gt') != other._$data.containsKey('gt')) {
      return false;
    }
    if (l$gt != lOther$gt) {
      return false;
    }
    final l$gte = gte;
    final lOther$gte = other.gte;
    if (_$data.containsKey('gte') != other._$data.containsKey('gte')) {
      return false;
    }
    if (l$gte != lOther$gte) {
      return false;
    }
    final l$$in = $in;
    final lOther$$in = other.$in;
    if (_$data.containsKey('in') != other._$data.containsKey('in')) {
      return false;
    }
    if (l$$in != null && lOther$$in != null) {
      if (l$$in.length != lOther$$in.length) {
        return false;
      }
      for (int i = 0; i < l$$in.length; i++) {
        final l$$in$entry = l$$in[i];
        final lOther$$in$entry = lOther$$in[i];
        if (l$$in$entry != lOther$$in$entry) {
          return false;
        }
      }
    } else if (l$$in != lOther$$in) {
      return false;
    }
    final l$lt = lt;
    final lOther$lt = other.lt;
    if (_$data.containsKey('lt') != other._$data.containsKey('lt')) {
      return false;
    }
    if (l$lt != lOther$lt) {
      return false;
    }
    final l$lte = lte;
    final lOther$lte = other.lte;
    if (_$data.containsKey('lte') != other._$data.containsKey('lte')) {
      return false;
    }
    if (l$lte != lOther$lte) {
      return false;
    }
    final l$not = not;
    final lOther$not = other.not;
    if (_$data.containsKey('not') != other._$data.containsKey('not')) {
      return false;
    }
    if (l$not != lOther$not) {
      return false;
    }
    final l$notIn = notIn;
    final lOther$notIn = other.notIn;
    if (_$data.containsKey('notIn') != other._$data.containsKey('notIn')) {
      return false;
    }
    if (l$notIn != null && lOther$notIn != null) {
      if (l$notIn.length != lOther$notIn.length) {
        return false;
      }
      for (int i = 0; i < l$notIn.length; i++) {
        final l$notIn$entry = l$notIn[i];
        final lOther$notIn$entry = lOther$notIn[i];
        if (l$notIn$entry != lOther$notIn$entry) {
          return false;
        }
      }
    } else if (l$notIn != lOther$notIn) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$equals = equals;
    final l$gt = gt;
    final l$gte = gte;
    final l$$in = $in;
    final l$lt = lt;
    final l$lte = lte;
    final l$not = not;
    final l$notIn = notIn;
    return Object.hashAll([
      _$data.containsKey('equals') ? l$equals : const {},
      _$data.containsKey('gt') ? l$gt : const {},
      _$data.containsKey('gte') ? l$gte : const {},
      _$data.containsKey('in')
          ? l$$in == null
              ? null
              : Object.hashAll(l$$in.map((v) => v))
          : const {},
      _$data.containsKey('lt') ? l$lt : const {},
      _$data.containsKey('lte') ? l$lte : const {},
      _$data.containsKey('not') ? l$not : const {},
      _$data.containsKey('notIn')
          ? l$notIn == null
              ? null
              : Object.hashAll(l$notIn.map((v) => v))
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$NestedDateTimeFilter<TRes> {
  factory CopyWith$Input$NestedDateTimeFilter(
    Input$NestedDateTimeFilter instance,
    TRes Function(Input$NestedDateTimeFilter) then,
  ) = _CopyWithImpl$Input$NestedDateTimeFilter;

  factory CopyWith$Input$NestedDateTimeFilter.stub(TRes res) =
      _CopyWithStubImpl$Input$NestedDateTimeFilter;

  TRes call({
    String? equals,
    String? gt,
    String? gte,
    List<String>? $in,
    String? lt,
    String? lte,
    Input$NestedDateTimeFilter? not,
    List<String>? notIn,
  });
  CopyWith$Input$NestedDateTimeFilter<TRes> get not;
}

class _CopyWithImpl$Input$NestedDateTimeFilter<TRes>
    implements CopyWith$Input$NestedDateTimeFilter<TRes> {
  _CopyWithImpl$Input$NestedDateTimeFilter(
    this._instance,
    this._then,
  );

  final Input$NestedDateTimeFilter _instance;

  final TRes Function(Input$NestedDateTimeFilter) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? equals = _undefined,
    Object? gt = _undefined,
    Object? gte = _undefined,
    Object? $in = _undefined,
    Object? lt = _undefined,
    Object? lte = _undefined,
    Object? not = _undefined,
    Object? notIn = _undefined,
  }) =>
      _then(Input$NestedDateTimeFilter._({
        ..._instance._$data,
        if (equals != _undefined) 'equals': (equals as String?),
        if (gt != _undefined) 'gt': (gt as String?),
        if (gte != _undefined) 'gte': (gte as String?),
        if ($in != _undefined) 'in': ($in as List<String>?),
        if (lt != _undefined) 'lt': (lt as String?),
        if (lte != _undefined) 'lte': (lte as String?),
        if (not != _undefined) 'not': (not as Input$NestedDateTimeFilter?),
        if (notIn != _undefined) 'notIn': (notIn as List<String>?),
      }));

  CopyWith$Input$NestedDateTimeFilter<TRes> get not {
    final local$not = _instance.not;
    return local$not == null
        ? CopyWith$Input$NestedDateTimeFilter.stub(_then(_instance))
        : CopyWith$Input$NestedDateTimeFilter(local$not, (e) => call(not: e));
  }
}

class _CopyWithStubImpl$Input$NestedDateTimeFilter<TRes>
    implements CopyWith$Input$NestedDateTimeFilter<TRes> {
  _CopyWithStubImpl$Input$NestedDateTimeFilter(this._res);

  TRes _res;

  call({
    String? equals,
    String? gt,
    String? gte,
    List<String>? $in,
    String? lt,
    String? lte,
    Input$NestedDateTimeFilter? not,
    List<String>? notIn,
  }) =>
      _res;

  CopyWith$Input$NestedDateTimeFilter<TRes> get not =>
      CopyWith$Input$NestedDateTimeFilter.stub(_res);
}

class Input$NestedDateTimeWithAggregatesFilter {
  factory Input$NestedDateTimeWithAggregatesFilter({
    Input$NestedIntFilter? $_count,
    Input$NestedDateTimeFilter? $_max,
    Input$NestedDateTimeFilter? $_min,
    String? equals,
    String? gt,
    String? gte,
    List<String>? $in,
    String? lt,
    String? lte,
    Input$NestedDateTimeWithAggregatesFilter? not,
    List<String>? notIn,
  }) =>
      Input$NestedDateTimeWithAggregatesFilter._({
        if ($_count != null) r'_count': $_count,
        if ($_max != null) r'_max': $_max,
        if ($_min != null) r'_min': $_min,
        if (equals != null) r'equals': equals,
        if (gt != null) r'gt': gt,
        if (gte != null) r'gte': gte,
        if ($in != null) r'in': $in,
        if (lt != null) r'lt': lt,
        if (lte != null) r'lte': lte,
        if (not != null) r'not': not,
        if (notIn != null) r'notIn': notIn,
      });

  Input$NestedDateTimeWithAggregatesFilter._(this._$data);

  factory Input$NestedDateTimeWithAggregatesFilter.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('_count')) {
      final l$$_count = data['_count'];
      result$data['_count'] = l$$_count == null
          ? null
          : Input$NestedIntFilter.fromJson((l$$_count as Map<String, dynamic>));
    }
    if (data.containsKey('_max')) {
      final l$$_max = data['_max'];
      result$data['_max'] = l$$_max == null
          ? null
          : Input$NestedDateTimeFilter.fromJson(
              (l$$_max as Map<String, dynamic>));
    }
    if (data.containsKey('_min')) {
      final l$$_min = data['_min'];
      result$data['_min'] = l$$_min == null
          ? null
          : Input$NestedDateTimeFilter.fromJson(
              (l$$_min as Map<String, dynamic>));
    }
    if (data.containsKey('equals')) {
      final l$equals = data['equals'];
      result$data['equals'] = (l$equals as String?);
    }
    if (data.containsKey('gt')) {
      final l$gt = data['gt'];
      result$data['gt'] = (l$gt as String?);
    }
    if (data.containsKey('gte')) {
      final l$gte = data['gte'];
      result$data['gte'] = (l$gte as String?);
    }
    if (data.containsKey('in')) {
      final l$$in = data['in'];
      result$data['in'] =
          (l$$in as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    if (data.containsKey('lt')) {
      final l$lt = data['lt'];
      result$data['lt'] = (l$lt as String?);
    }
    if (data.containsKey('lte')) {
      final l$lte = data['lte'];
      result$data['lte'] = (l$lte as String?);
    }
    if (data.containsKey('not')) {
      final l$not = data['not'];
      result$data['not'] = l$not == null
          ? null
          : Input$NestedDateTimeWithAggregatesFilter.fromJson(
              (l$not as Map<String, dynamic>));
    }
    if (data.containsKey('notIn')) {
      final l$notIn = data['notIn'];
      result$data['notIn'] =
          (l$notIn as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    return Input$NestedDateTimeWithAggregatesFilter._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$NestedIntFilter? get $_count =>
      (_$data['_count'] as Input$NestedIntFilter?);

  Input$NestedDateTimeFilter? get $_max =>
      (_$data['_max'] as Input$NestedDateTimeFilter?);

  Input$NestedDateTimeFilter? get $_min =>
      (_$data['_min'] as Input$NestedDateTimeFilter?);

  String? get equals => (_$data['equals'] as String?);

  String? get gt => (_$data['gt'] as String?);

  String? get gte => (_$data['gte'] as String?);

  List<String>? get $in => (_$data['in'] as List<String>?);

  String? get lt => (_$data['lt'] as String?);

  String? get lte => (_$data['lte'] as String?);

  Input$NestedDateTimeWithAggregatesFilter? get not =>
      (_$data['not'] as Input$NestedDateTimeWithAggregatesFilter?);

  List<String>? get notIn => (_$data['notIn'] as List<String>?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('_count')) {
      final l$$_count = $_count;
      result$data['_count'] = l$$_count?.toJson();
    }
    if (_$data.containsKey('_max')) {
      final l$$_max = $_max;
      result$data['_max'] = l$$_max?.toJson();
    }
    if (_$data.containsKey('_min')) {
      final l$$_min = $_min;
      result$data['_min'] = l$$_min?.toJson();
    }
    if (_$data.containsKey('equals')) {
      final l$equals = equals;
      result$data['equals'] = l$equals;
    }
    if (_$data.containsKey('gt')) {
      final l$gt = gt;
      result$data['gt'] = l$gt;
    }
    if (_$data.containsKey('gte')) {
      final l$gte = gte;
      result$data['gte'] = l$gte;
    }
    if (_$data.containsKey('in')) {
      final l$$in = $in;
      result$data['in'] = l$$in?.map((e) => e).toList();
    }
    if (_$data.containsKey('lt')) {
      final l$lt = lt;
      result$data['lt'] = l$lt;
    }
    if (_$data.containsKey('lte')) {
      final l$lte = lte;
      result$data['lte'] = l$lte;
    }
    if (_$data.containsKey('not')) {
      final l$not = not;
      result$data['not'] = l$not?.toJson();
    }
    if (_$data.containsKey('notIn')) {
      final l$notIn = notIn;
      result$data['notIn'] = l$notIn?.map((e) => e).toList();
    }
    return result$data;
  }

  CopyWith$Input$NestedDateTimeWithAggregatesFilter<
          Input$NestedDateTimeWithAggregatesFilter>
      get copyWith => CopyWith$Input$NestedDateTimeWithAggregatesFilter(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$NestedDateTimeWithAggregatesFilter) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$$_count = $_count;
    final lOther$$_count = other.$_count;
    if (_$data.containsKey('_count') != other._$data.containsKey('_count')) {
      return false;
    }
    if (l$$_count != lOther$$_count) {
      return false;
    }
    final l$$_max = $_max;
    final lOther$$_max = other.$_max;
    if (_$data.containsKey('_max') != other._$data.containsKey('_max')) {
      return false;
    }
    if (l$$_max != lOther$$_max) {
      return false;
    }
    final l$$_min = $_min;
    final lOther$$_min = other.$_min;
    if (_$data.containsKey('_min') != other._$data.containsKey('_min')) {
      return false;
    }
    if (l$$_min != lOther$$_min) {
      return false;
    }
    final l$equals = equals;
    final lOther$equals = other.equals;
    if (_$data.containsKey('equals') != other._$data.containsKey('equals')) {
      return false;
    }
    if (l$equals != lOther$equals) {
      return false;
    }
    final l$gt = gt;
    final lOther$gt = other.gt;
    if (_$data.containsKey('gt') != other._$data.containsKey('gt')) {
      return false;
    }
    if (l$gt != lOther$gt) {
      return false;
    }
    final l$gte = gte;
    final lOther$gte = other.gte;
    if (_$data.containsKey('gte') != other._$data.containsKey('gte')) {
      return false;
    }
    if (l$gte != lOther$gte) {
      return false;
    }
    final l$$in = $in;
    final lOther$$in = other.$in;
    if (_$data.containsKey('in') != other._$data.containsKey('in')) {
      return false;
    }
    if (l$$in != null && lOther$$in != null) {
      if (l$$in.length != lOther$$in.length) {
        return false;
      }
      for (int i = 0; i < l$$in.length; i++) {
        final l$$in$entry = l$$in[i];
        final lOther$$in$entry = lOther$$in[i];
        if (l$$in$entry != lOther$$in$entry) {
          return false;
        }
      }
    } else if (l$$in != lOther$$in) {
      return false;
    }
    final l$lt = lt;
    final lOther$lt = other.lt;
    if (_$data.containsKey('lt') != other._$data.containsKey('lt')) {
      return false;
    }
    if (l$lt != lOther$lt) {
      return false;
    }
    final l$lte = lte;
    final lOther$lte = other.lte;
    if (_$data.containsKey('lte') != other._$data.containsKey('lte')) {
      return false;
    }
    if (l$lte != lOther$lte) {
      return false;
    }
    final l$not = not;
    final lOther$not = other.not;
    if (_$data.containsKey('not') != other._$data.containsKey('not')) {
      return false;
    }
    if (l$not != lOther$not) {
      return false;
    }
    final l$notIn = notIn;
    final lOther$notIn = other.notIn;
    if (_$data.containsKey('notIn') != other._$data.containsKey('notIn')) {
      return false;
    }
    if (l$notIn != null && lOther$notIn != null) {
      if (l$notIn.length != lOther$notIn.length) {
        return false;
      }
      for (int i = 0; i < l$notIn.length; i++) {
        final l$notIn$entry = l$notIn[i];
        final lOther$notIn$entry = lOther$notIn[i];
        if (l$notIn$entry != lOther$notIn$entry) {
          return false;
        }
      }
    } else if (l$notIn != lOther$notIn) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$$_count = $_count;
    final l$$_max = $_max;
    final l$$_min = $_min;
    final l$equals = equals;
    final l$gt = gt;
    final l$gte = gte;
    final l$$in = $in;
    final l$lt = lt;
    final l$lte = lte;
    final l$not = not;
    final l$notIn = notIn;
    return Object.hashAll([
      _$data.containsKey('_count') ? l$$_count : const {},
      _$data.containsKey('_max') ? l$$_max : const {},
      _$data.containsKey('_min') ? l$$_min : const {},
      _$data.containsKey('equals') ? l$equals : const {},
      _$data.containsKey('gt') ? l$gt : const {},
      _$data.containsKey('gte') ? l$gte : const {},
      _$data.containsKey('in')
          ? l$$in == null
              ? null
              : Object.hashAll(l$$in.map((v) => v))
          : const {},
      _$data.containsKey('lt') ? l$lt : const {},
      _$data.containsKey('lte') ? l$lte : const {},
      _$data.containsKey('not') ? l$not : const {},
      _$data.containsKey('notIn')
          ? l$notIn == null
              ? null
              : Object.hashAll(l$notIn.map((v) => v))
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$NestedDateTimeWithAggregatesFilter<TRes> {
  factory CopyWith$Input$NestedDateTimeWithAggregatesFilter(
    Input$NestedDateTimeWithAggregatesFilter instance,
    TRes Function(Input$NestedDateTimeWithAggregatesFilter) then,
  ) = _CopyWithImpl$Input$NestedDateTimeWithAggregatesFilter;

  factory CopyWith$Input$NestedDateTimeWithAggregatesFilter.stub(TRes res) =
      _CopyWithStubImpl$Input$NestedDateTimeWithAggregatesFilter;

  TRes call({
    Input$NestedIntFilter? $_count,
    Input$NestedDateTimeFilter? $_max,
    Input$NestedDateTimeFilter? $_min,
    String? equals,
    String? gt,
    String? gte,
    List<String>? $in,
    String? lt,
    String? lte,
    Input$NestedDateTimeWithAggregatesFilter? not,
    List<String>? notIn,
  });
  CopyWith$Input$NestedIntFilter<TRes> get $_count;
  CopyWith$Input$NestedDateTimeFilter<TRes> get $_max;
  CopyWith$Input$NestedDateTimeFilter<TRes> get $_min;
  CopyWith$Input$NestedDateTimeWithAggregatesFilter<TRes> get not;
}

class _CopyWithImpl$Input$NestedDateTimeWithAggregatesFilter<TRes>
    implements CopyWith$Input$NestedDateTimeWithAggregatesFilter<TRes> {
  _CopyWithImpl$Input$NestedDateTimeWithAggregatesFilter(
    this._instance,
    this._then,
  );

  final Input$NestedDateTimeWithAggregatesFilter _instance;

  final TRes Function(Input$NestedDateTimeWithAggregatesFilter) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? $_count = _undefined,
    Object? $_max = _undefined,
    Object? $_min = _undefined,
    Object? equals = _undefined,
    Object? gt = _undefined,
    Object? gte = _undefined,
    Object? $in = _undefined,
    Object? lt = _undefined,
    Object? lte = _undefined,
    Object? not = _undefined,
    Object? notIn = _undefined,
  }) =>
      _then(Input$NestedDateTimeWithAggregatesFilter._({
        ..._instance._$data,
        if ($_count != _undefined)
          '_count': ($_count as Input$NestedIntFilter?),
        if ($_max != _undefined) '_max': ($_max as Input$NestedDateTimeFilter?),
        if ($_min != _undefined) '_min': ($_min as Input$NestedDateTimeFilter?),
        if (equals != _undefined) 'equals': (equals as String?),
        if (gt != _undefined) 'gt': (gt as String?),
        if (gte != _undefined) 'gte': (gte as String?),
        if ($in != _undefined) 'in': ($in as List<String>?),
        if (lt != _undefined) 'lt': (lt as String?),
        if (lte != _undefined) 'lte': (lte as String?),
        if (not != _undefined)
          'not': (not as Input$NestedDateTimeWithAggregatesFilter?),
        if (notIn != _undefined) 'notIn': (notIn as List<String>?),
      }));

  CopyWith$Input$NestedIntFilter<TRes> get $_count {
    final local$$_count = _instance.$_count;
    return local$$_count == null
        ? CopyWith$Input$NestedIntFilter.stub(_then(_instance))
        : CopyWith$Input$NestedIntFilter(
            local$$_count, (e) => call($_count: e));
  }

  CopyWith$Input$NestedDateTimeFilter<TRes> get $_max {
    final local$$_max = _instance.$_max;
    return local$$_max == null
        ? CopyWith$Input$NestedDateTimeFilter.stub(_then(_instance))
        : CopyWith$Input$NestedDateTimeFilter(
            local$$_max, (e) => call($_max: e));
  }

  CopyWith$Input$NestedDateTimeFilter<TRes> get $_min {
    final local$$_min = _instance.$_min;
    return local$$_min == null
        ? CopyWith$Input$NestedDateTimeFilter.stub(_then(_instance))
        : CopyWith$Input$NestedDateTimeFilter(
            local$$_min, (e) => call($_min: e));
  }

  CopyWith$Input$NestedDateTimeWithAggregatesFilter<TRes> get not {
    final local$not = _instance.not;
    return local$not == null
        ? CopyWith$Input$NestedDateTimeWithAggregatesFilter.stub(
            _then(_instance))
        : CopyWith$Input$NestedDateTimeWithAggregatesFilter(
            local$not, (e) => call(not: e));
  }
}

class _CopyWithStubImpl$Input$NestedDateTimeWithAggregatesFilter<TRes>
    implements CopyWith$Input$NestedDateTimeWithAggregatesFilter<TRes> {
  _CopyWithStubImpl$Input$NestedDateTimeWithAggregatesFilter(this._res);

  TRes _res;

  call({
    Input$NestedIntFilter? $_count,
    Input$NestedDateTimeFilter? $_max,
    Input$NestedDateTimeFilter? $_min,
    String? equals,
    String? gt,
    String? gte,
    List<String>? $in,
    String? lt,
    String? lte,
    Input$NestedDateTimeWithAggregatesFilter? not,
    List<String>? notIn,
  }) =>
      _res;

  CopyWith$Input$NestedIntFilter<TRes> get $_count =>
      CopyWith$Input$NestedIntFilter.stub(_res);

  CopyWith$Input$NestedDateTimeFilter<TRes> get $_max =>
      CopyWith$Input$NestedDateTimeFilter.stub(_res);

  CopyWith$Input$NestedDateTimeFilter<TRes> get $_min =>
      CopyWith$Input$NestedDateTimeFilter.stub(_res);

  CopyWith$Input$NestedDateTimeWithAggregatesFilter<TRes> get not =>
      CopyWith$Input$NestedDateTimeWithAggregatesFilter.stub(_res);
}

class Input$NestedFloatNullableFilter {
  factory Input$NestedFloatNullableFilter({
    double? equals,
    double? gt,
    double? gte,
    List<double>? $in,
    double? lt,
    double? lte,
    Input$NestedFloatNullableFilter? not,
    List<double>? notIn,
  }) =>
      Input$NestedFloatNullableFilter._({
        if (equals != null) r'equals': equals,
        if (gt != null) r'gt': gt,
        if (gte != null) r'gte': gte,
        if ($in != null) r'in': $in,
        if (lt != null) r'lt': lt,
        if (lte != null) r'lte': lte,
        if (not != null) r'not': not,
        if (notIn != null) r'notIn': notIn,
      });

  Input$NestedFloatNullableFilter._(this._$data);

  factory Input$NestedFloatNullableFilter.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('equals')) {
      final l$equals = data['equals'];
      result$data['equals'] = (l$equals as num?)?.toDouble();
    }
    if (data.containsKey('gt')) {
      final l$gt = data['gt'];
      result$data['gt'] = (l$gt as num?)?.toDouble();
    }
    if (data.containsKey('gte')) {
      final l$gte = data['gte'];
      result$data['gte'] = (l$gte as num?)?.toDouble();
    }
    if (data.containsKey('in')) {
      final l$$in = data['in'];
      result$data['in'] =
          (l$$in as List<dynamic>?)?.map((e) => (e as num).toDouble()).toList();
    }
    if (data.containsKey('lt')) {
      final l$lt = data['lt'];
      result$data['lt'] = (l$lt as num?)?.toDouble();
    }
    if (data.containsKey('lte')) {
      final l$lte = data['lte'];
      result$data['lte'] = (l$lte as num?)?.toDouble();
    }
    if (data.containsKey('not')) {
      final l$not = data['not'];
      result$data['not'] = l$not == null
          ? null
          : Input$NestedFloatNullableFilter.fromJson(
              (l$not as Map<String, dynamic>));
    }
    if (data.containsKey('notIn')) {
      final l$notIn = data['notIn'];
      result$data['notIn'] = (l$notIn as List<dynamic>?)
          ?.map((e) => (e as num).toDouble())
          .toList();
    }
    return Input$NestedFloatNullableFilter._(result$data);
  }

  Map<String, dynamic> _$data;

  double? get equals => (_$data['equals'] as double?);

  double? get gt => (_$data['gt'] as double?);

  double? get gte => (_$data['gte'] as double?);

  List<double>? get $in => (_$data['in'] as List<double>?);

  double? get lt => (_$data['lt'] as double?);

  double? get lte => (_$data['lte'] as double?);

  Input$NestedFloatNullableFilter? get not =>
      (_$data['not'] as Input$NestedFloatNullableFilter?);

  List<double>? get notIn => (_$data['notIn'] as List<double>?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('equals')) {
      final l$equals = equals;
      result$data['equals'] = l$equals;
    }
    if (_$data.containsKey('gt')) {
      final l$gt = gt;
      result$data['gt'] = l$gt;
    }
    if (_$data.containsKey('gte')) {
      final l$gte = gte;
      result$data['gte'] = l$gte;
    }
    if (_$data.containsKey('in')) {
      final l$$in = $in;
      result$data['in'] = l$$in?.map((e) => e).toList();
    }
    if (_$data.containsKey('lt')) {
      final l$lt = lt;
      result$data['lt'] = l$lt;
    }
    if (_$data.containsKey('lte')) {
      final l$lte = lte;
      result$data['lte'] = l$lte;
    }
    if (_$data.containsKey('not')) {
      final l$not = not;
      result$data['not'] = l$not?.toJson();
    }
    if (_$data.containsKey('notIn')) {
      final l$notIn = notIn;
      result$data['notIn'] = l$notIn?.map((e) => e).toList();
    }
    return result$data;
  }

  CopyWith$Input$NestedFloatNullableFilter<Input$NestedFloatNullableFilter>
      get copyWith => CopyWith$Input$NestedFloatNullableFilter(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$NestedFloatNullableFilter) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$equals = equals;
    final lOther$equals = other.equals;
    if (_$data.containsKey('equals') != other._$data.containsKey('equals')) {
      return false;
    }
    if (l$equals != lOther$equals) {
      return false;
    }
    final l$gt = gt;
    final lOther$gt = other.gt;
    if (_$data.containsKey('gt') != other._$data.containsKey('gt')) {
      return false;
    }
    if (l$gt != lOther$gt) {
      return false;
    }
    final l$gte = gte;
    final lOther$gte = other.gte;
    if (_$data.containsKey('gte') != other._$data.containsKey('gte')) {
      return false;
    }
    if (l$gte != lOther$gte) {
      return false;
    }
    final l$$in = $in;
    final lOther$$in = other.$in;
    if (_$data.containsKey('in') != other._$data.containsKey('in')) {
      return false;
    }
    if (l$$in != null && lOther$$in != null) {
      if (l$$in.length != lOther$$in.length) {
        return false;
      }
      for (int i = 0; i < l$$in.length; i++) {
        final l$$in$entry = l$$in[i];
        final lOther$$in$entry = lOther$$in[i];
        if (l$$in$entry != lOther$$in$entry) {
          return false;
        }
      }
    } else if (l$$in != lOther$$in) {
      return false;
    }
    final l$lt = lt;
    final lOther$lt = other.lt;
    if (_$data.containsKey('lt') != other._$data.containsKey('lt')) {
      return false;
    }
    if (l$lt != lOther$lt) {
      return false;
    }
    final l$lte = lte;
    final lOther$lte = other.lte;
    if (_$data.containsKey('lte') != other._$data.containsKey('lte')) {
      return false;
    }
    if (l$lte != lOther$lte) {
      return false;
    }
    final l$not = not;
    final lOther$not = other.not;
    if (_$data.containsKey('not') != other._$data.containsKey('not')) {
      return false;
    }
    if (l$not != lOther$not) {
      return false;
    }
    final l$notIn = notIn;
    final lOther$notIn = other.notIn;
    if (_$data.containsKey('notIn') != other._$data.containsKey('notIn')) {
      return false;
    }
    if (l$notIn != null && lOther$notIn != null) {
      if (l$notIn.length != lOther$notIn.length) {
        return false;
      }
      for (int i = 0; i < l$notIn.length; i++) {
        final l$notIn$entry = l$notIn[i];
        final lOther$notIn$entry = lOther$notIn[i];
        if (l$notIn$entry != lOther$notIn$entry) {
          return false;
        }
      }
    } else if (l$notIn != lOther$notIn) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$equals = equals;
    final l$gt = gt;
    final l$gte = gte;
    final l$$in = $in;
    final l$lt = lt;
    final l$lte = lte;
    final l$not = not;
    final l$notIn = notIn;
    return Object.hashAll([
      _$data.containsKey('equals') ? l$equals : const {},
      _$data.containsKey('gt') ? l$gt : const {},
      _$data.containsKey('gte') ? l$gte : const {},
      _$data.containsKey('in')
          ? l$$in == null
              ? null
              : Object.hashAll(l$$in.map((v) => v))
          : const {},
      _$data.containsKey('lt') ? l$lt : const {},
      _$data.containsKey('lte') ? l$lte : const {},
      _$data.containsKey('not') ? l$not : const {},
      _$data.containsKey('notIn')
          ? l$notIn == null
              ? null
              : Object.hashAll(l$notIn.map((v) => v))
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$NestedFloatNullableFilter<TRes> {
  factory CopyWith$Input$NestedFloatNullableFilter(
    Input$NestedFloatNullableFilter instance,
    TRes Function(Input$NestedFloatNullableFilter) then,
  ) = _CopyWithImpl$Input$NestedFloatNullableFilter;

  factory CopyWith$Input$NestedFloatNullableFilter.stub(TRes res) =
      _CopyWithStubImpl$Input$NestedFloatNullableFilter;

  TRes call({
    double? equals,
    double? gt,
    double? gte,
    List<double>? $in,
    double? lt,
    double? lte,
    Input$NestedFloatNullableFilter? not,
    List<double>? notIn,
  });
  CopyWith$Input$NestedFloatNullableFilter<TRes> get not;
}

class _CopyWithImpl$Input$NestedFloatNullableFilter<TRes>
    implements CopyWith$Input$NestedFloatNullableFilter<TRes> {
  _CopyWithImpl$Input$NestedFloatNullableFilter(
    this._instance,
    this._then,
  );

  final Input$NestedFloatNullableFilter _instance;

  final TRes Function(Input$NestedFloatNullableFilter) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? equals = _undefined,
    Object? gt = _undefined,
    Object? gte = _undefined,
    Object? $in = _undefined,
    Object? lt = _undefined,
    Object? lte = _undefined,
    Object? not = _undefined,
    Object? notIn = _undefined,
  }) =>
      _then(Input$NestedFloatNullableFilter._({
        ..._instance._$data,
        if (equals != _undefined) 'equals': (equals as double?),
        if (gt != _undefined) 'gt': (gt as double?),
        if (gte != _undefined) 'gte': (gte as double?),
        if ($in != _undefined) 'in': ($in as List<double>?),
        if (lt != _undefined) 'lt': (lt as double?),
        if (lte != _undefined) 'lte': (lte as double?),
        if (not != _undefined) 'not': (not as Input$NestedFloatNullableFilter?),
        if (notIn != _undefined) 'notIn': (notIn as List<double>?),
      }));

  CopyWith$Input$NestedFloatNullableFilter<TRes> get not {
    final local$not = _instance.not;
    return local$not == null
        ? CopyWith$Input$NestedFloatNullableFilter.stub(_then(_instance))
        : CopyWith$Input$NestedFloatNullableFilter(
            local$not, (e) => call(not: e));
  }
}

class _CopyWithStubImpl$Input$NestedFloatNullableFilter<TRes>
    implements CopyWith$Input$NestedFloatNullableFilter<TRes> {
  _CopyWithStubImpl$Input$NestedFloatNullableFilter(this._res);

  TRes _res;

  call({
    double? equals,
    double? gt,
    double? gte,
    List<double>? $in,
    double? lt,
    double? lte,
    Input$NestedFloatNullableFilter? not,
    List<double>? notIn,
  }) =>
      _res;

  CopyWith$Input$NestedFloatNullableFilter<TRes> get not =>
      CopyWith$Input$NestedFloatNullableFilter.stub(_res);
}

class Input$NestedIntFilter {
  factory Input$NestedIntFilter({
    int? equals,
    int? gt,
    int? gte,
    List<int>? $in,
    int? lt,
    int? lte,
    Input$NestedIntFilter? not,
    List<int>? notIn,
  }) =>
      Input$NestedIntFilter._({
        if (equals != null) r'equals': equals,
        if (gt != null) r'gt': gt,
        if (gte != null) r'gte': gte,
        if ($in != null) r'in': $in,
        if (lt != null) r'lt': lt,
        if (lte != null) r'lte': lte,
        if (not != null) r'not': not,
        if (notIn != null) r'notIn': notIn,
      });

  Input$NestedIntFilter._(this._$data);

  factory Input$NestedIntFilter.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('equals')) {
      final l$equals = data['equals'];
      result$data['equals'] = (l$equals as int?);
    }
    if (data.containsKey('gt')) {
      final l$gt = data['gt'];
      result$data['gt'] = (l$gt as int?);
    }
    if (data.containsKey('gte')) {
      final l$gte = data['gte'];
      result$data['gte'] = (l$gte as int?);
    }
    if (data.containsKey('in')) {
      final l$$in = data['in'];
      result$data['in'] =
          (l$$in as List<dynamic>?)?.map((e) => (e as int)).toList();
    }
    if (data.containsKey('lt')) {
      final l$lt = data['lt'];
      result$data['lt'] = (l$lt as int?);
    }
    if (data.containsKey('lte')) {
      final l$lte = data['lte'];
      result$data['lte'] = (l$lte as int?);
    }
    if (data.containsKey('not')) {
      final l$not = data['not'];
      result$data['not'] = l$not == null
          ? null
          : Input$NestedIntFilter.fromJson((l$not as Map<String, dynamic>));
    }
    if (data.containsKey('notIn')) {
      final l$notIn = data['notIn'];
      result$data['notIn'] =
          (l$notIn as List<dynamic>?)?.map((e) => (e as int)).toList();
    }
    return Input$NestedIntFilter._(result$data);
  }

  Map<String, dynamic> _$data;

  int? get equals => (_$data['equals'] as int?);

  int? get gt => (_$data['gt'] as int?);

  int? get gte => (_$data['gte'] as int?);

  List<int>? get $in => (_$data['in'] as List<int>?);

  int? get lt => (_$data['lt'] as int?);

  int? get lte => (_$data['lte'] as int?);

  Input$NestedIntFilter? get not => (_$data['not'] as Input$NestedIntFilter?);

  List<int>? get notIn => (_$data['notIn'] as List<int>?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('equals')) {
      final l$equals = equals;
      result$data['equals'] = l$equals;
    }
    if (_$data.containsKey('gt')) {
      final l$gt = gt;
      result$data['gt'] = l$gt;
    }
    if (_$data.containsKey('gte')) {
      final l$gte = gte;
      result$data['gte'] = l$gte;
    }
    if (_$data.containsKey('in')) {
      final l$$in = $in;
      result$data['in'] = l$$in?.map((e) => e).toList();
    }
    if (_$data.containsKey('lt')) {
      final l$lt = lt;
      result$data['lt'] = l$lt;
    }
    if (_$data.containsKey('lte')) {
      final l$lte = lte;
      result$data['lte'] = l$lte;
    }
    if (_$data.containsKey('not')) {
      final l$not = not;
      result$data['not'] = l$not?.toJson();
    }
    if (_$data.containsKey('notIn')) {
      final l$notIn = notIn;
      result$data['notIn'] = l$notIn?.map((e) => e).toList();
    }
    return result$data;
  }

  CopyWith$Input$NestedIntFilter<Input$NestedIntFilter> get copyWith =>
      CopyWith$Input$NestedIntFilter(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$NestedIntFilter) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$equals = equals;
    final lOther$equals = other.equals;
    if (_$data.containsKey('equals') != other._$data.containsKey('equals')) {
      return false;
    }
    if (l$equals != lOther$equals) {
      return false;
    }
    final l$gt = gt;
    final lOther$gt = other.gt;
    if (_$data.containsKey('gt') != other._$data.containsKey('gt')) {
      return false;
    }
    if (l$gt != lOther$gt) {
      return false;
    }
    final l$gte = gte;
    final lOther$gte = other.gte;
    if (_$data.containsKey('gte') != other._$data.containsKey('gte')) {
      return false;
    }
    if (l$gte != lOther$gte) {
      return false;
    }
    final l$$in = $in;
    final lOther$$in = other.$in;
    if (_$data.containsKey('in') != other._$data.containsKey('in')) {
      return false;
    }
    if (l$$in != null && lOther$$in != null) {
      if (l$$in.length != lOther$$in.length) {
        return false;
      }
      for (int i = 0; i < l$$in.length; i++) {
        final l$$in$entry = l$$in[i];
        final lOther$$in$entry = lOther$$in[i];
        if (l$$in$entry != lOther$$in$entry) {
          return false;
        }
      }
    } else if (l$$in != lOther$$in) {
      return false;
    }
    final l$lt = lt;
    final lOther$lt = other.lt;
    if (_$data.containsKey('lt') != other._$data.containsKey('lt')) {
      return false;
    }
    if (l$lt != lOther$lt) {
      return false;
    }
    final l$lte = lte;
    final lOther$lte = other.lte;
    if (_$data.containsKey('lte') != other._$data.containsKey('lte')) {
      return false;
    }
    if (l$lte != lOther$lte) {
      return false;
    }
    final l$not = not;
    final lOther$not = other.not;
    if (_$data.containsKey('not') != other._$data.containsKey('not')) {
      return false;
    }
    if (l$not != lOther$not) {
      return false;
    }
    final l$notIn = notIn;
    final lOther$notIn = other.notIn;
    if (_$data.containsKey('notIn') != other._$data.containsKey('notIn')) {
      return false;
    }
    if (l$notIn != null && lOther$notIn != null) {
      if (l$notIn.length != lOther$notIn.length) {
        return false;
      }
      for (int i = 0; i < l$notIn.length; i++) {
        final l$notIn$entry = l$notIn[i];
        final lOther$notIn$entry = lOther$notIn[i];
        if (l$notIn$entry != lOther$notIn$entry) {
          return false;
        }
      }
    } else if (l$notIn != lOther$notIn) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$equals = equals;
    final l$gt = gt;
    final l$gte = gte;
    final l$$in = $in;
    final l$lt = lt;
    final l$lte = lte;
    final l$not = not;
    final l$notIn = notIn;
    return Object.hashAll([
      _$data.containsKey('equals') ? l$equals : const {},
      _$data.containsKey('gt') ? l$gt : const {},
      _$data.containsKey('gte') ? l$gte : const {},
      _$data.containsKey('in')
          ? l$$in == null
              ? null
              : Object.hashAll(l$$in.map((v) => v))
          : const {},
      _$data.containsKey('lt') ? l$lt : const {},
      _$data.containsKey('lte') ? l$lte : const {},
      _$data.containsKey('not') ? l$not : const {},
      _$data.containsKey('notIn')
          ? l$notIn == null
              ? null
              : Object.hashAll(l$notIn.map((v) => v))
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$NestedIntFilter<TRes> {
  factory CopyWith$Input$NestedIntFilter(
    Input$NestedIntFilter instance,
    TRes Function(Input$NestedIntFilter) then,
  ) = _CopyWithImpl$Input$NestedIntFilter;

  factory CopyWith$Input$NestedIntFilter.stub(TRes res) =
      _CopyWithStubImpl$Input$NestedIntFilter;

  TRes call({
    int? equals,
    int? gt,
    int? gte,
    List<int>? $in,
    int? lt,
    int? lte,
    Input$NestedIntFilter? not,
    List<int>? notIn,
  });
  CopyWith$Input$NestedIntFilter<TRes> get not;
}

class _CopyWithImpl$Input$NestedIntFilter<TRes>
    implements CopyWith$Input$NestedIntFilter<TRes> {
  _CopyWithImpl$Input$NestedIntFilter(
    this._instance,
    this._then,
  );

  final Input$NestedIntFilter _instance;

  final TRes Function(Input$NestedIntFilter) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? equals = _undefined,
    Object? gt = _undefined,
    Object? gte = _undefined,
    Object? $in = _undefined,
    Object? lt = _undefined,
    Object? lte = _undefined,
    Object? not = _undefined,
    Object? notIn = _undefined,
  }) =>
      _then(Input$NestedIntFilter._({
        ..._instance._$data,
        if (equals != _undefined) 'equals': (equals as int?),
        if (gt != _undefined) 'gt': (gt as int?),
        if (gte != _undefined) 'gte': (gte as int?),
        if ($in != _undefined) 'in': ($in as List<int>?),
        if (lt != _undefined) 'lt': (lt as int?),
        if (lte != _undefined) 'lte': (lte as int?),
        if (not != _undefined) 'not': (not as Input$NestedIntFilter?),
        if (notIn != _undefined) 'notIn': (notIn as List<int>?),
      }));

  CopyWith$Input$NestedIntFilter<TRes> get not {
    final local$not = _instance.not;
    return local$not == null
        ? CopyWith$Input$NestedIntFilter.stub(_then(_instance))
        : CopyWith$Input$NestedIntFilter(local$not, (e) => call(not: e));
  }
}

class _CopyWithStubImpl$Input$NestedIntFilter<TRes>
    implements CopyWith$Input$NestedIntFilter<TRes> {
  _CopyWithStubImpl$Input$NestedIntFilter(this._res);

  TRes _res;

  call({
    int? equals,
    int? gt,
    int? gte,
    List<int>? $in,
    int? lt,
    int? lte,
    Input$NestedIntFilter? not,
    List<int>? notIn,
  }) =>
      _res;

  CopyWith$Input$NestedIntFilter<TRes> get not =>
      CopyWith$Input$NestedIntFilter.stub(_res);
}

class Input$NestedIntNullableFilter {
  factory Input$NestedIntNullableFilter({
    int? equals,
    int? gt,
    int? gte,
    List<int>? $in,
    int? lt,
    int? lte,
    Input$NestedIntNullableFilter? not,
    List<int>? notIn,
  }) =>
      Input$NestedIntNullableFilter._({
        if (equals != null) r'equals': equals,
        if (gt != null) r'gt': gt,
        if (gte != null) r'gte': gte,
        if ($in != null) r'in': $in,
        if (lt != null) r'lt': lt,
        if (lte != null) r'lte': lte,
        if (not != null) r'not': not,
        if (notIn != null) r'notIn': notIn,
      });

  Input$NestedIntNullableFilter._(this._$data);

  factory Input$NestedIntNullableFilter.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('equals')) {
      final l$equals = data['equals'];
      result$data['equals'] = (l$equals as int?);
    }
    if (data.containsKey('gt')) {
      final l$gt = data['gt'];
      result$data['gt'] = (l$gt as int?);
    }
    if (data.containsKey('gte')) {
      final l$gte = data['gte'];
      result$data['gte'] = (l$gte as int?);
    }
    if (data.containsKey('in')) {
      final l$$in = data['in'];
      result$data['in'] =
          (l$$in as List<dynamic>?)?.map((e) => (e as int)).toList();
    }
    if (data.containsKey('lt')) {
      final l$lt = data['lt'];
      result$data['lt'] = (l$lt as int?);
    }
    if (data.containsKey('lte')) {
      final l$lte = data['lte'];
      result$data['lte'] = (l$lte as int?);
    }
    if (data.containsKey('not')) {
      final l$not = data['not'];
      result$data['not'] = l$not == null
          ? null
          : Input$NestedIntNullableFilter.fromJson(
              (l$not as Map<String, dynamic>));
    }
    if (data.containsKey('notIn')) {
      final l$notIn = data['notIn'];
      result$data['notIn'] =
          (l$notIn as List<dynamic>?)?.map((e) => (e as int)).toList();
    }
    return Input$NestedIntNullableFilter._(result$data);
  }

  Map<String, dynamic> _$data;

  int? get equals => (_$data['equals'] as int?);

  int? get gt => (_$data['gt'] as int?);

  int? get gte => (_$data['gte'] as int?);

  List<int>? get $in => (_$data['in'] as List<int>?);

  int? get lt => (_$data['lt'] as int?);

  int? get lte => (_$data['lte'] as int?);

  Input$NestedIntNullableFilter? get not =>
      (_$data['not'] as Input$NestedIntNullableFilter?);

  List<int>? get notIn => (_$data['notIn'] as List<int>?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('equals')) {
      final l$equals = equals;
      result$data['equals'] = l$equals;
    }
    if (_$data.containsKey('gt')) {
      final l$gt = gt;
      result$data['gt'] = l$gt;
    }
    if (_$data.containsKey('gte')) {
      final l$gte = gte;
      result$data['gte'] = l$gte;
    }
    if (_$data.containsKey('in')) {
      final l$$in = $in;
      result$data['in'] = l$$in?.map((e) => e).toList();
    }
    if (_$data.containsKey('lt')) {
      final l$lt = lt;
      result$data['lt'] = l$lt;
    }
    if (_$data.containsKey('lte')) {
      final l$lte = lte;
      result$data['lte'] = l$lte;
    }
    if (_$data.containsKey('not')) {
      final l$not = not;
      result$data['not'] = l$not?.toJson();
    }
    if (_$data.containsKey('notIn')) {
      final l$notIn = notIn;
      result$data['notIn'] = l$notIn?.map((e) => e).toList();
    }
    return result$data;
  }

  CopyWith$Input$NestedIntNullableFilter<Input$NestedIntNullableFilter>
      get copyWith => CopyWith$Input$NestedIntNullableFilter(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$NestedIntNullableFilter) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$equals = equals;
    final lOther$equals = other.equals;
    if (_$data.containsKey('equals') != other._$data.containsKey('equals')) {
      return false;
    }
    if (l$equals != lOther$equals) {
      return false;
    }
    final l$gt = gt;
    final lOther$gt = other.gt;
    if (_$data.containsKey('gt') != other._$data.containsKey('gt')) {
      return false;
    }
    if (l$gt != lOther$gt) {
      return false;
    }
    final l$gte = gte;
    final lOther$gte = other.gte;
    if (_$data.containsKey('gte') != other._$data.containsKey('gte')) {
      return false;
    }
    if (l$gte != lOther$gte) {
      return false;
    }
    final l$$in = $in;
    final lOther$$in = other.$in;
    if (_$data.containsKey('in') != other._$data.containsKey('in')) {
      return false;
    }
    if (l$$in != null && lOther$$in != null) {
      if (l$$in.length != lOther$$in.length) {
        return false;
      }
      for (int i = 0; i < l$$in.length; i++) {
        final l$$in$entry = l$$in[i];
        final lOther$$in$entry = lOther$$in[i];
        if (l$$in$entry != lOther$$in$entry) {
          return false;
        }
      }
    } else if (l$$in != lOther$$in) {
      return false;
    }
    final l$lt = lt;
    final lOther$lt = other.lt;
    if (_$data.containsKey('lt') != other._$data.containsKey('lt')) {
      return false;
    }
    if (l$lt != lOther$lt) {
      return false;
    }
    final l$lte = lte;
    final lOther$lte = other.lte;
    if (_$data.containsKey('lte') != other._$data.containsKey('lte')) {
      return false;
    }
    if (l$lte != lOther$lte) {
      return false;
    }
    final l$not = not;
    final lOther$not = other.not;
    if (_$data.containsKey('not') != other._$data.containsKey('not')) {
      return false;
    }
    if (l$not != lOther$not) {
      return false;
    }
    final l$notIn = notIn;
    final lOther$notIn = other.notIn;
    if (_$data.containsKey('notIn') != other._$data.containsKey('notIn')) {
      return false;
    }
    if (l$notIn != null && lOther$notIn != null) {
      if (l$notIn.length != lOther$notIn.length) {
        return false;
      }
      for (int i = 0; i < l$notIn.length; i++) {
        final l$notIn$entry = l$notIn[i];
        final lOther$notIn$entry = lOther$notIn[i];
        if (l$notIn$entry != lOther$notIn$entry) {
          return false;
        }
      }
    } else if (l$notIn != lOther$notIn) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$equals = equals;
    final l$gt = gt;
    final l$gte = gte;
    final l$$in = $in;
    final l$lt = lt;
    final l$lte = lte;
    final l$not = not;
    final l$notIn = notIn;
    return Object.hashAll([
      _$data.containsKey('equals') ? l$equals : const {},
      _$data.containsKey('gt') ? l$gt : const {},
      _$data.containsKey('gte') ? l$gte : const {},
      _$data.containsKey('in')
          ? l$$in == null
              ? null
              : Object.hashAll(l$$in.map((v) => v))
          : const {},
      _$data.containsKey('lt') ? l$lt : const {},
      _$data.containsKey('lte') ? l$lte : const {},
      _$data.containsKey('not') ? l$not : const {},
      _$data.containsKey('notIn')
          ? l$notIn == null
              ? null
              : Object.hashAll(l$notIn.map((v) => v))
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$NestedIntNullableFilter<TRes> {
  factory CopyWith$Input$NestedIntNullableFilter(
    Input$NestedIntNullableFilter instance,
    TRes Function(Input$NestedIntNullableFilter) then,
  ) = _CopyWithImpl$Input$NestedIntNullableFilter;

  factory CopyWith$Input$NestedIntNullableFilter.stub(TRes res) =
      _CopyWithStubImpl$Input$NestedIntNullableFilter;

  TRes call({
    int? equals,
    int? gt,
    int? gte,
    List<int>? $in,
    int? lt,
    int? lte,
    Input$NestedIntNullableFilter? not,
    List<int>? notIn,
  });
  CopyWith$Input$NestedIntNullableFilter<TRes> get not;
}

class _CopyWithImpl$Input$NestedIntNullableFilter<TRes>
    implements CopyWith$Input$NestedIntNullableFilter<TRes> {
  _CopyWithImpl$Input$NestedIntNullableFilter(
    this._instance,
    this._then,
  );

  final Input$NestedIntNullableFilter _instance;

  final TRes Function(Input$NestedIntNullableFilter) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? equals = _undefined,
    Object? gt = _undefined,
    Object? gte = _undefined,
    Object? $in = _undefined,
    Object? lt = _undefined,
    Object? lte = _undefined,
    Object? not = _undefined,
    Object? notIn = _undefined,
  }) =>
      _then(Input$NestedIntNullableFilter._({
        ..._instance._$data,
        if (equals != _undefined) 'equals': (equals as int?),
        if (gt != _undefined) 'gt': (gt as int?),
        if (gte != _undefined) 'gte': (gte as int?),
        if ($in != _undefined) 'in': ($in as List<int>?),
        if (lt != _undefined) 'lt': (lt as int?),
        if (lte != _undefined) 'lte': (lte as int?),
        if (not != _undefined) 'not': (not as Input$NestedIntNullableFilter?),
        if (notIn != _undefined) 'notIn': (notIn as List<int>?),
      }));

  CopyWith$Input$NestedIntNullableFilter<TRes> get not {
    final local$not = _instance.not;
    return local$not == null
        ? CopyWith$Input$NestedIntNullableFilter.stub(_then(_instance))
        : CopyWith$Input$NestedIntNullableFilter(
            local$not, (e) => call(not: e));
  }
}

class _CopyWithStubImpl$Input$NestedIntNullableFilter<TRes>
    implements CopyWith$Input$NestedIntNullableFilter<TRes> {
  _CopyWithStubImpl$Input$NestedIntNullableFilter(this._res);

  TRes _res;

  call({
    int? equals,
    int? gt,
    int? gte,
    List<int>? $in,
    int? lt,
    int? lte,
    Input$NestedIntNullableFilter? not,
    List<int>? notIn,
  }) =>
      _res;

  CopyWith$Input$NestedIntNullableFilter<TRes> get not =>
      CopyWith$Input$NestedIntNullableFilter.stub(_res);
}

class Input$NestedIntNullableWithAggregatesFilter {
  factory Input$NestedIntNullableWithAggregatesFilter({
    Input$NestedFloatNullableFilter? $_avg,
    Input$NestedIntNullableFilter? $_count,
    Input$NestedIntNullableFilter? $_max,
    Input$NestedIntNullableFilter? $_min,
    Input$NestedIntNullableFilter? $_sum,
    int? equals,
    int? gt,
    int? gte,
    List<int>? $in,
    int? lt,
    int? lte,
    Input$NestedIntNullableWithAggregatesFilter? not,
    List<int>? notIn,
  }) =>
      Input$NestedIntNullableWithAggregatesFilter._({
        if ($_avg != null) r'_avg': $_avg,
        if ($_count != null) r'_count': $_count,
        if ($_max != null) r'_max': $_max,
        if ($_min != null) r'_min': $_min,
        if ($_sum != null) r'_sum': $_sum,
        if (equals != null) r'equals': equals,
        if (gt != null) r'gt': gt,
        if (gte != null) r'gte': gte,
        if ($in != null) r'in': $in,
        if (lt != null) r'lt': lt,
        if (lte != null) r'lte': lte,
        if (not != null) r'not': not,
        if (notIn != null) r'notIn': notIn,
      });

  Input$NestedIntNullableWithAggregatesFilter._(this._$data);

  factory Input$NestedIntNullableWithAggregatesFilter.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('_avg')) {
      final l$$_avg = data['_avg'];
      result$data['_avg'] = l$$_avg == null
          ? null
          : Input$NestedFloatNullableFilter.fromJson(
              (l$$_avg as Map<String, dynamic>));
    }
    if (data.containsKey('_count')) {
      final l$$_count = data['_count'];
      result$data['_count'] = l$$_count == null
          ? null
          : Input$NestedIntNullableFilter.fromJson(
              (l$$_count as Map<String, dynamic>));
    }
    if (data.containsKey('_max')) {
      final l$$_max = data['_max'];
      result$data['_max'] = l$$_max == null
          ? null
          : Input$NestedIntNullableFilter.fromJson(
              (l$$_max as Map<String, dynamic>));
    }
    if (data.containsKey('_min')) {
      final l$$_min = data['_min'];
      result$data['_min'] = l$$_min == null
          ? null
          : Input$NestedIntNullableFilter.fromJson(
              (l$$_min as Map<String, dynamic>));
    }
    if (data.containsKey('_sum')) {
      final l$$_sum = data['_sum'];
      result$data['_sum'] = l$$_sum == null
          ? null
          : Input$NestedIntNullableFilter.fromJson(
              (l$$_sum as Map<String, dynamic>));
    }
    if (data.containsKey('equals')) {
      final l$equals = data['equals'];
      result$data['equals'] = (l$equals as int?);
    }
    if (data.containsKey('gt')) {
      final l$gt = data['gt'];
      result$data['gt'] = (l$gt as int?);
    }
    if (data.containsKey('gte')) {
      final l$gte = data['gte'];
      result$data['gte'] = (l$gte as int?);
    }
    if (data.containsKey('in')) {
      final l$$in = data['in'];
      result$data['in'] =
          (l$$in as List<dynamic>?)?.map((e) => (e as int)).toList();
    }
    if (data.containsKey('lt')) {
      final l$lt = data['lt'];
      result$data['lt'] = (l$lt as int?);
    }
    if (data.containsKey('lte')) {
      final l$lte = data['lte'];
      result$data['lte'] = (l$lte as int?);
    }
    if (data.containsKey('not')) {
      final l$not = data['not'];
      result$data['not'] = l$not == null
          ? null
          : Input$NestedIntNullableWithAggregatesFilter.fromJson(
              (l$not as Map<String, dynamic>));
    }
    if (data.containsKey('notIn')) {
      final l$notIn = data['notIn'];
      result$data['notIn'] =
          (l$notIn as List<dynamic>?)?.map((e) => (e as int)).toList();
    }
    return Input$NestedIntNullableWithAggregatesFilter._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$NestedFloatNullableFilter? get $_avg =>
      (_$data['_avg'] as Input$NestedFloatNullableFilter?);

  Input$NestedIntNullableFilter? get $_count =>
      (_$data['_count'] as Input$NestedIntNullableFilter?);

  Input$NestedIntNullableFilter? get $_max =>
      (_$data['_max'] as Input$NestedIntNullableFilter?);

  Input$NestedIntNullableFilter? get $_min =>
      (_$data['_min'] as Input$NestedIntNullableFilter?);

  Input$NestedIntNullableFilter? get $_sum =>
      (_$data['_sum'] as Input$NestedIntNullableFilter?);

  int? get equals => (_$data['equals'] as int?);

  int? get gt => (_$data['gt'] as int?);

  int? get gte => (_$data['gte'] as int?);

  List<int>? get $in => (_$data['in'] as List<int>?);

  int? get lt => (_$data['lt'] as int?);

  int? get lte => (_$data['lte'] as int?);

  Input$NestedIntNullableWithAggregatesFilter? get not =>
      (_$data['not'] as Input$NestedIntNullableWithAggregatesFilter?);

  List<int>? get notIn => (_$data['notIn'] as List<int>?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('_avg')) {
      final l$$_avg = $_avg;
      result$data['_avg'] = l$$_avg?.toJson();
    }
    if (_$data.containsKey('_count')) {
      final l$$_count = $_count;
      result$data['_count'] = l$$_count?.toJson();
    }
    if (_$data.containsKey('_max')) {
      final l$$_max = $_max;
      result$data['_max'] = l$$_max?.toJson();
    }
    if (_$data.containsKey('_min')) {
      final l$$_min = $_min;
      result$data['_min'] = l$$_min?.toJson();
    }
    if (_$data.containsKey('_sum')) {
      final l$$_sum = $_sum;
      result$data['_sum'] = l$$_sum?.toJson();
    }
    if (_$data.containsKey('equals')) {
      final l$equals = equals;
      result$data['equals'] = l$equals;
    }
    if (_$data.containsKey('gt')) {
      final l$gt = gt;
      result$data['gt'] = l$gt;
    }
    if (_$data.containsKey('gte')) {
      final l$gte = gte;
      result$data['gte'] = l$gte;
    }
    if (_$data.containsKey('in')) {
      final l$$in = $in;
      result$data['in'] = l$$in?.map((e) => e).toList();
    }
    if (_$data.containsKey('lt')) {
      final l$lt = lt;
      result$data['lt'] = l$lt;
    }
    if (_$data.containsKey('lte')) {
      final l$lte = lte;
      result$data['lte'] = l$lte;
    }
    if (_$data.containsKey('not')) {
      final l$not = not;
      result$data['not'] = l$not?.toJson();
    }
    if (_$data.containsKey('notIn')) {
      final l$notIn = notIn;
      result$data['notIn'] = l$notIn?.map((e) => e).toList();
    }
    return result$data;
  }

  CopyWith$Input$NestedIntNullableWithAggregatesFilter<
          Input$NestedIntNullableWithAggregatesFilter>
      get copyWith => CopyWith$Input$NestedIntNullableWithAggregatesFilter(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$NestedIntNullableWithAggregatesFilter) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$$_avg = $_avg;
    final lOther$$_avg = other.$_avg;
    if (_$data.containsKey('_avg') != other._$data.containsKey('_avg')) {
      return false;
    }
    if (l$$_avg != lOther$$_avg) {
      return false;
    }
    final l$$_count = $_count;
    final lOther$$_count = other.$_count;
    if (_$data.containsKey('_count') != other._$data.containsKey('_count')) {
      return false;
    }
    if (l$$_count != lOther$$_count) {
      return false;
    }
    final l$$_max = $_max;
    final lOther$$_max = other.$_max;
    if (_$data.containsKey('_max') != other._$data.containsKey('_max')) {
      return false;
    }
    if (l$$_max != lOther$$_max) {
      return false;
    }
    final l$$_min = $_min;
    final lOther$$_min = other.$_min;
    if (_$data.containsKey('_min') != other._$data.containsKey('_min')) {
      return false;
    }
    if (l$$_min != lOther$$_min) {
      return false;
    }
    final l$$_sum = $_sum;
    final lOther$$_sum = other.$_sum;
    if (_$data.containsKey('_sum') != other._$data.containsKey('_sum')) {
      return false;
    }
    if (l$$_sum != lOther$$_sum) {
      return false;
    }
    final l$equals = equals;
    final lOther$equals = other.equals;
    if (_$data.containsKey('equals') != other._$data.containsKey('equals')) {
      return false;
    }
    if (l$equals != lOther$equals) {
      return false;
    }
    final l$gt = gt;
    final lOther$gt = other.gt;
    if (_$data.containsKey('gt') != other._$data.containsKey('gt')) {
      return false;
    }
    if (l$gt != lOther$gt) {
      return false;
    }
    final l$gte = gte;
    final lOther$gte = other.gte;
    if (_$data.containsKey('gte') != other._$data.containsKey('gte')) {
      return false;
    }
    if (l$gte != lOther$gte) {
      return false;
    }
    final l$$in = $in;
    final lOther$$in = other.$in;
    if (_$data.containsKey('in') != other._$data.containsKey('in')) {
      return false;
    }
    if (l$$in != null && lOther$$in != null) {
      if (l$$in.length != lOther$$in.length) {
        return false;
      }
      for (int i = 0; i < l$$in.length; i++) {
        final l$$in$entry = l$$in[i];
        final lOther$$in$entry = lOther$$in[i];
        if (l$$in$entry != lOther$$in$entry) {
          return false;
        }
      }
    } else if (l$$in != lOther$$in) {
      return false;
    }
    final l$lt = lt;
    final lOther$lt = other.lt;
    if (_$data.containsKey('lt') != other._$data.containsKey('lt')) {
      return false;
    }
    if (l$lt != lOther$lt) {
      return false;
    }
    final l$lte = lte;
    final lOther$lte = other.lte;
    if (_$data.containsKey('lte') != other._$data.containsKey('lte')) {
      return false;
    }
    if (l$lte != lOther$lte) {
      return false;
    }
    final l$not = not;
    final lOther$not = other.not;
    if (_$data.containsKey('not') != other._$data.containsKey('not')) {
      return false;
    }
    if (l$not != lOther$not) {
      return false;
    }
    final l$notIn = notIn;
    final lOther$notIn = other.notIn;
    if (_$data.containsKey('notIn') != other._$data.containsKey('notIn')) {
      return false;
    }
    if (l$notIn != null && lOther$notIn != null) {
      if (l$notIn.length != lOther$notIn.length) {
        return false;
      }
      for (int i = 0; i < l$notIn.length; i++) {
        final l$notIn$entry = l$notIn[i];
        final lOther$notIn$entry = lOther$notIn[i];
        if (l$notIn$entry != lOther$notIn$entry) {
          return false;
        }
      }
    } else if (l$notIn != lOther$notIn) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$$_avg = $_avg;
    final l$$_count = $_count;
    final l$$_max = $_max;
    final l$$_min = $_min;
    final l$$_sum = $_sum;
    final l$equals = equals;
    final l$gt = gt;
    final l$gte = gte;
    final l$$in = $in;
    final l$lt = lt;
    final l$lte = lte;
    final l$not = not;
    final l$notIn = notIn;
    return Object.hashAll([
      _$data.containsKey('_avg') ? l$$_avg : const {},
      _$data.containsKey('_count') ? l$$_count : const {},
      _$data.containsKey('_max') ? l$$_max : const {},
      _$data.containsKey('_min') ? l$$_min : const {},
      _$data.containsKey('_sum') ? l$$_sum : const {},
      _$data.containsKey('equals') ? l$equals : const {},
      _$data.containsKey('gt') ? l$gt : const {},
      _$data.containsKey('gte') ? l$gte : const {},
      _$data.containsKey('in')
          ? l$$in == null
              ? null
              : Object.hashAll(l$$in.map((v) => v))
          : const {},
      _$data.containsKey('lt') ? l$lt : const {},
      _$data.containsKey('lte') ? l$lte : const {},
      _$data.containsKey('not') ? l$not : const {},
      _$data.containsKey('notIn')
          ? l$notIn == null
              ? null
              : Object.hashAll(l$notIn.map((v) => v))
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$NestedIntNullableWithAggregatesFilter<TRes> {
  factory CopyWith$Input$NestedIntNullableWithAggregatesFilter(
    Input$NestedIntNullableWithAggregatesFilter instance,
    TRes Function(Input$NestedIntNullableWithAggregatesFilter) then,
  ) = _CopyWithImpl$Input$NestedIntNullableWithAggregatesFilter;

  factory CopyWith$Input$NestedIntNullableWithAggregatesFilter.stub(TRes res) =
      _CopyWithStubImpl$Input$NestedIntNullableWithAggregatesFilter;

  TRes call({
    Input$NestedFloatNullableFilter? $_avg,
    Input$NestedIntNullableFilter? $_count,
    Input$NestedIntNullableFilter? $_max,
    Input$NestedIntNullableFilter? $_min,
    Input$NestedIntNullableFilter? $_sum,
    int? equals,
    int? gt,
    int? gte,
    List<int>? $in,
    int? lt,
    int? lte,
    Input$NestedIntNullableWithAggregatesFilter? not,
    List<int>? notIn,
  });
  CopyWith$Input$NestedFloatNullableFilter<TRes> get $_avg;
  CopyWith$Input$NestedIntNullableFilter<TRes> get $_count;
  CopyWith$Input$NestedIntNullableFilter<TRes> get $_max;
  CopyWith$Input$NestedIntNullableFilter<TRes> get $_min;
  CopyWith$Input$NestedIntNullableFilter<TRes> get $_sum;
  CopyWith$Input$NestedIntNullableWithAggregatesFilter<TRes> get not;
}

class _CopyWithImpl$Input$NestedIntNullableWithAggregatesFilter<TRes>
    implements CopyWith$Input$NestedIntNullableWithAggregatesFilter<TRes> {
  _CopyWithImpl$Input$NestedIntNullableWithAggregatesFilter(
    this._instance,
    this._then,
  );

  final Input$NestedIntNullableWithAggregatesFilter _instance;

  final TRes Function(Input$NestedIntNullableWithAggregatesFilter) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? $_avg = _undefined,
    Object? $_count = _undefined,
    Object? $_max = _undefined,
    Object? $_min = _undefined,
    Object? $_sum = _undefined,
    Object? equals = _undefined,
    Object? gt = _undefined,
    Object? gte = _undefined,
    Object? $in = _undefined,
    Object? lt = _undefined,
    Object? lte = _undefined,
    Object? not = _undefined,
    Object? notIn = _undefined,
  }) =>
      _then(Input$NestedIntNullableWithAggregatesFilter._({
        ..._instance._$data,
        if ($_avg != _undefined)
          '_avg': ($_avg as Input$NestedFloatNullableFilter?),
        if ($_count != _undefined)
          '_count': ($_count as Input$NestedIntNullableFilter?),
        if ($_max != _undefined)
          '_max': ($_max as Input$NestedIntNullableFilter?),
        if ($_min != _undefined)
          '_min': ($_min as Input$NestedIntNullableFilter?),
        if ($_sum != _undefined)
          '_sum': ($_sum as Input$NestedIntNullableFilter?),
        if (equals != _undefined) 'equals': (equals as int?),
        if (gt != _undefined) 'gt': (gt as int?),
        if (gte != _undefined) 'gte': (gte as int?),
        if ($in != _undefined) 'in': ($in as List<int>?),
        if (lt != _undefined) 'lt': (lt as int?),
        if (lte != _undefined) 'lte': (lte as int?),
        if (not != _undefined)
          'not': (not as Input$NestedIntNullableWithAggregatesFilter?),
        if (notIn != _undefined) 'notIn': (notIn as List<int>?),
      }));

  CopyWith$Input$NestedFloatNullableFilter<TRes> get $_avg {
    final local$$_avg = _instance.$_avg;
    return local$$_avg == null
        ? CopyWith$Input$NestedFloatNullableFilter.stub(_then(_instance))
        : CopyWith$Input$NestedFloatNullableFilter(
            local$$_avg, (e) => call($_avg: e));
  }

  CopyWith$Input$NestedIntNullableFilter<TRes> get $_count {
    final local$$_count = _instance.$_count;
    return local$$_count == null
        ? CopyWith$Input$NestedIntNullableFilter.stub(_then(_instance))
        : CopyWith$Input$NestedIntNullableFilter(
            local$$_count, (e) => call($_count: e));
  }

  CopyWith$Input$NestedIntNullableFilter<TRes> get $_max {
    final local$$_max = _instance.$_max;
    return local$$_max == null
        ? CopyWith$Input$NestedIntNullableFilter.stub(_then(_instance))
        : CopyWith$Input$NestedIntNullableFilter(
            local$$_max, (e) => call($_max: e));
  }

  CopyWith$Input$NestedIntNullableFilter<TRes> get $_min {
    final local$$_min = _instance.$_min;
    return local$$_min == null
        ? CopyWith$Input$NestedIntNullableFilter.stub(_then(_instance))
        : CopyWith$Input$NestedIntNullableFilter(
            local$$_min, (e) => call($_min: e));
  }

  CopyWith$Input$NestedIntNullableFilter<TRes> get $_sum {
    final local$$_sum = _instance.$_sum;
    return local$$_sum == null
        ? CopyWith$Input$NestedIntNullableFilter.stub(_then(_instance))
        : CopyWith$Input$NestedIntNullableFilter(
            local$$_sum, (e) => call($_sum: e));
  }

  CopyWith$Input$NestedIntNullableWithAggregatesFilter<TRes> get not {
    final local$not = _instance.not;
    return local$not == null
        ? CopyWith$Input$NestedIntNullableWithAggregatesFilter.stub(
            _then(_instance))
        : CopyWith$Input$NestedIntNullableWithAggregatesFilter(
            local$not, (e) => call(not: e));
  }
}

class _CopyWithStubImpl$Input$NestedIntNullableWithAggregatesFilter<TRes>
    implements CopyWith$Input$NestedIntNullableWithAggregatesFilter<TRes> {
  _CopyWithStubImpl$Input$NestedIntNullableWithAggregatesFilter(this._res);

  TRes _res;

  call({
    Input$NestedFloatNullableFilter? $_avg,
    Input$NestedIntNullableFilter? $_count,
    Input$NestedIntNullableFilter? $_max,
    Input$NestedIntNullableFilter? $_min,
    Input$NestedIntNullableFilter? $_sum,
    int? equals,
    int? gt,
    int? gte,
    List<int>? $in,
    int? lt,
    int? lte,
    Input$NestedIntNullableWithAggregatesFilter? not,
    List<int>? notIn,
  }) =>
      _res;

  CopyWith$Input$NestedFloatNullableFilter<TRes> get $_avg =>
      CopyWith$Input$NestedFloatNullableFilter.stub(_res);

  CopyWith$Input$NestedIntNullableFilter<TRes> get $_count =>
      CopyWith$Input$NestedIntNullableFilter.stub(_res);

  CopyWith$Input$NestedIntNullableFilter<TRes> get $_max =>
      CopyWith$Input$NestedIntNullableFilter.stub(_res);

  CopyWith$Input$NestedIntNullableFilter<TRes> get $_min =>
      CopyWith$Input$NestedIntNullableFilter.stub(_res);

  CopyWith$Input$NestedIntNullableFilter<TRes> get $_sum =>
      CopyWith$Input$NestedIntNullableFilter.stub(_res);

  CopyWith$Input$NestedIntNullableWithAggregatesFilter<TRes> get not =>
      CopyWith$Input$NestedIntNullableWithAggregatesFilter.stub(_res);
}

class Input$NestedStringFilter {
  factory Input$NestedStringFilter({
    String? contains,
    String? endsWith,
    String? equals,
    String? gt,
    String? gte,
    List<String>? $in,
    String? lt,
    String? lte,
    Input$NestedStringFilter? not,
    List<String>? notIn,
    String? startsWith,
  }) =>
      Input$NestedStringFilter._({
        if (contains != null) r'contains': contains,
        if (endsWith != null) r'endsWith': endsWith,
        if (equals != null) r'equals': equals,
        if (gt != null) r'gt': gt,
        if (gte != null) r'gte': gte,
        if ($in != null) r'in': $in,
        if (lt != null) r'lt': lt,
        if (lte != null) r'lte': lte,
        if (not != null) r'not': not,
        if (notIn != null) r'notIn': notIn,
        if (startsWith != null) r'startsWith': startsWith,
      });

  Input$NestedStringFilter._(this._$data);

  factory Input$NestedStringFilter.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('contains')) {
      final l$contains = data['contains'];
      result$data['contains'] = (l$contains as String?);
    }
    if (data.containsKey('endsWith')) {
      final l$endsWith = data['endsWith'];
      result$data['endsWith'] = (l$endsWith as String?);
    }
    if (data.containsKey('equals')) {
      final l$equals = data['equals'];
      result$data['equals'] = (l$equals as String?);
    }
    if (data.containsKey('gt')) {
      final l$gt = data['gt'];
      result$data['gt'] = (l$gt as String?);
    }
    if (data.containsKey('gte')) {
      final l$gte = data['gte'];
      result$data['gte'] = (l$gte as String?);
    }
    if (data.containsKey('in')) {
      final l$$in = data['in'];
      result$data['in'] =
          (l$$in as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    if (data.containsKey('lt')) {
      final l$lt = data['lt'];
      result$data['lt'] = (l$lt as String?);
    }
    if (data.containsKey('lte')) {
      final l$lte = data['lte'];
      result$data['lte'] = (l$lte as String?);
    }
    if (data.containsKey('not')) {
      final l$not = data['not'];
      result$data['not'] = l$not == null
          ? null
          : Input$NestedStringFilter.fromJson((l$not as Map<String, dynamic>));
    }
    if (data.containsKey('notIn')) {
      final l$notIn = data['notIn'];
      result$data['notIn'] =
          (l$notIn as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    if (data.containsKey('startsWith')) {
      final l$startsWith = data['startsWith'];
      result$data['startsWith'] = (l$startsWith as String?);
    }
    return Input$NestedStringFilter._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get contains => (_$data['contains'] as String?);

  String? get endsWith => (_$data['endsWith'] as String?);

  String? get equals => (_$data['equals'] as String?);

  String? get gt => (_$data['gt'] as String?);

  String? get gte => (_$data['gte'] as String?);

  List<String>? get $in => (_$data['in'] as List<String>?);

  String? get lt => (_$data['lt'] as String?);

  String? get lte => (_$data['lte'] as String?);

  Input$NestedStringFilter? get not =>
      (_$data['not'] as Input$NestedStringFilter?);

  List<String>? get notIn => (_$data['notIn'] as List<String>?);

  String? get startsWith => (_$data['startsWith'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('contains')) {
      final l$contains = contains;
      result$data['contains'] = l$contains;
    }
    if (_$data.containsKey('endsWith')) {
      final l$endsWith = endsWith;
      result$data['endsWith'] = l$endsWith;
    }
    if (_$data.containsKey('equals')) {
      final l$equals = equals;
      result$data['equals'] = l$equals;
    }
    if (_$data.containsKey('gt')) {
      final l$gt = gt;
      result$data['gt'] = l$gt;
    }
    if (_$data.containsKey('gte')) {
      final l$gte = gte;
      result$data['gte'] = l$gte;
    }
    if (_$data.containsKey('in')) {
      final l$$in = $in;
      result$data['in'] = l$$in?.map((e) => e).toList();
    }
    if (_$data.containsKey('lt')) {
      final l$lt = lt;
      result$data['lt'] = l$lt;
    }
    if (_$data.containsKey('lte')) {
      final l$lte = lte;
      result$data['lte'] = l$lte;
    }
    if (_$data.containsKey('not')) {
      final l$not = not;
      result$data['not'] = l$not?.toJson();
    }
    if (_$data.containsKey('notIn')) {
      final l$notIn = notIn;
      result$data['notIn'] = l$notIn?.map((e) => e).toList();
    }
    if (_$data.containsKey('startsWith')) {
      final l$startsWith = startsWith;
      result$data['startsWith'] = l$startsWith;
    }
    return result$data;
  }

  CopyWith$Input$NestedStringFilter<Input$NestedStringFilter> get copyWith =>
      CopyWith$Input$NestedStringFilter(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$NestedStringFilter) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$contains = contains;
    final lOther$contains = other.contains;
    if (_$data.containsKey('contains') !=
        other._$data.containsKey('contains')) {
      return false;
    }
    if (l$contains != lOther$contains) {
      return false;
    }
    final l$endsWith = endsWith;
    final lOther$endsWith = other.endsWith;
    if (_$data.containsKey('endsWith') !=
        other._$data.containsKey('endsWith')) {
      return false;
    }
    if (l$endsWith != lOther$endsWith) {
      return false;
    }
    final l$equals = equals;
    final lOther$equals = other.equals;
    if (_$data.containsKey('equals') != other._$data.containsKey('equals')) {
      return false;
    }
    if (l$equals != lOther$equals) {
      return false;
    }
    final l$gt = gt;
    final lOther$gt = other.gt;
    if (_$data.containsKey('gt') != other._$data.containsKey('gt')) {
      return false;
    }
    if (l$gt != lOther$gt) {
      return false;
    }
    final l$gte = gte;
    final lOther$gte = other.gte;
    if (_$data.containsKey('gte') != other._$data.containsKey('gte')) {
      return false;
    }
    if (l$gte != lOther$gte) {
      return false;
    }
    final l$$in = $in;
    final lOther$$in = other.$in;
    if (_$data.containsKey('in') != other._$data.containsKey('in')) {
      return false;
    }
    if (l$$in != null && lOther$$in != null) {
      if (l$$in.length != lOther$$in.length) {
        return false;
      }
      for (int i = 0; i < l$$in.length; i++) {
        final l$$in$entry = l$$in[i];
        final lOther$$in$entry = lOther$$in[i];
        if (l$$in$entry != lOther$$in$entry) {
          return false;
        }
      }
    } else if (l$$in != lOther$$in) {
      return false;
    }
    final l$lt = lt;
    final lOther$lt = other.lt;
    if (_$data.containsKey('lt') != other._$data.containsKey('lt')) {
      return false;
    }
    if (l$lt != lOther$lt) {
      return false;
    }
    final l$lte = lte;
    final lOther$lte = other.lte;
    if (_$data.containsKey('lte') != other._$data.containsKey('lte')) {
      return false;
    }
    if (l$lte != lOther$lte) {
      return false;
    }
    final l$not = not;
    final lOther$not = other.not;
    if (_$data.containsKey('not') != other._$data.containsKey('not')) {
      return false;
    }
    if (l$not != lOther$not) {
      return false;
    }
    final l$notIn = notIn;
    final lOther$notIn = other.notIn;
    if (_$data.containsKey('notIn') != other._$data.containsKey('notIn')) {
      return false;
    }
    if (l$notIn != null && lOther$notIn != null) {
      if (l$notIn.length != lOther$notIn.length) {
        return false;
      }
      for (int i = 0; i < l$notIn.length; i++) {
        final l$notIn$entry = l$notIn[i];
        final lOther$notIn$entry = lOther$notIn[i];
        if (l$notIn$entry != lOther$notIn$entry) {
          return false;
        }
      }
    } else if (l$notIn != lOther$notIn) {
      return false;
    }
    final l$startsWith = startsWith;
    final lOther$startsWith = other.startsWith;
    if (_$data.containsKey('startsWith') !=
        other._$data.containsKey('startsWith')) {
      return false;
    }
    if (l$startsWith != lOther$startsWith) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$contains = contains;
    final l$endsWith = endsWith;
    final l$equals = equals;
    final l$gt = gt;
    final l$gte = gte;
    final l$$in = $in;
    final l$lt = lt;
    final l$lte = lte;
    final l$not = not;
    final l$notIn = notIn;
    final l$startsWith = startsWith;
    return Object.hashAll([
      _$data.containsKey('contains') ? l$contains : const {},
      _$data.containsKey('endsWith') ? l$endsWith : const {},
      _$data.containsKey('equals') ? l$equals : const {},
      _$data.containsKey('gt') ? l$gt : const {},
      _$data.containsKey('gte') ? l$gte : const {},
      _$data.containsKey('in')
          ? l$$in == null
              ? null
              : Object.hashAll(l$$in.map((v) => v))
          : const {},
      _$data.containsKey('lt') ? l$lt : const {},
      _$data.containsKey('lte') ? l$lte : const {},
      _$data.containsKey('not') ? l$not : const {},
      _$data.containsKey('notIn')
          ? l$notIn == null
              ? null
              : Object.hashAll(l$notIn.map((v) => v))
          : const {},
      _$data.containsKey('startsWith') ? l$startsWith : const {},
    ]);
  }
}

abstract class CopyWith$Input$NestedStringFilter<TRes> {
  factory CopyWith$Input$NestedStringFilter(
    Input$NestedStringFilter instance,
    TRes Function(Input$NestedStringFilter) then,
  ) = _CopyWithImpl$Input$NestedStringFilter;

  factory CopyWith$Input$NestedStringFilter.stub(TRes res) =
      _CopyWithStubImpl$Input$NestedStringFilter;

  TRes call({
    String? contains,
    String? endsWith,
    String? equals,
    String? gt,
    String? gte,
    List<String>? $in,
    String? lt,
    String? lte,
    Input$NestedStringFilter? not,
    List<String>? notIn,
    String? startsWith,
  });
  CopyWith$Input$NestedStringFilter<TRes> get not;
}

class _CopyWithImpl$Input$NestedStringFilter<TRes>
    implements CopyWith$Input$NestedStringFilter<TRes> {
  _CopyWithImpl$Input$NestedStringFilter(
    this._instance,
    this._then,
  );

  final Input$NestedStringFilter _instance;

  final TRes Function(Input$NestedStringFilter) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? contains = _undefined,
    Object? endsWith = _undefined,
    Object? equals = _undefined,
    Object? gt = _undefined,
    Object? gte = _undefined,
    Object? $in = _undefined,
    Object? lt = _undefined,
    Object? lte = _undefined,
    Object? not = _undefined,
    Object? notIn = _undefined,
    Object? startsWith = _undefined,
  }) =>
      _then(Input$NestedStringFilter._({
        ..._instance._$data,
        if (contains != _undefined) 'contains': (contains as String?),
        if (endsWith != _undefined) 'endsWith': (endsWith as String?),
        if (equals != _undefined) 'equals': (equals as String?),
        if (gt != _undefined) 'gt': (gt as String?),
        if (gte != _undefined) 'gte': (gte as String?),
        if ($in != _undefined) 'in': ($in as List<String>?),
        if (lt != _undefined) 'lt': (lt as String?),
        if (lte != _undefined) 'lte': (lte as String?),
        if (not != _undefined) 'not': (not as Input$NestedStringFilter?),
        if (notIn != _undefined) 'notIn': (notIn as List<String>?),
        if (startsWith != _undefined) 'startsWith': (startsWith as String?),
      }));

  CopyWith$Input$NestedStringFilter<TRes> get not {
    final local$not = _instance.not;
    return local$not == null
        ? CopyWith$Input$NestedStringFilter.stub(_then(_instance))
        : CopyWith$Input$NestedStringFilter(local$not, (e) => call(not: e));
  }
}

class _CopyWithStubImpl$Input$NestedStringFilter<TRes>
    implements CopyWith$Input$NestedStringFilter<TRes> {
  _CopyWithStubImpl$Input$NestedStringFilter(this._res);

  TRes _res;

  call({
    String? contains,
    String? endsWith,
    String? equals,
    String? gt,
    String? gte,
    List<String>? $in,
    String? lt,
    String? lte,
    Input$NestedStringFilter? not,
    List<String>? notIn,
    String? startsWith,
  }) =>
      _res;

  CopyWith$Input$NestedStringFilter<TRes> get not =>
      CopyWith$Input$NestedStringFilter.stub(_res);
}

class Input$NestedStringNullableFilter {
  factory Input$NestedStringNullableFilter({
    String? contains,
    String? endsWith,
    String? equals,
    String? gt,
    String? gte,
    List<String>? $in,
    String? lt,
    String? lte,
    Input$NestedStringNullableFilter? not,
    List<String>? notIn,
    String? startsWith,
  }) =>
      Input$NestedStringNullableFilter._({
        if (contains != null) r'contains': contains,
        if (endsWith != null) r'endsWith': endsWith,
        if (equals != null) r'equals': equals,
        if (gt != null) r'gt': gt,
        if (gte != null) r'gte': gte,
        if ($in != null) r'in': $in,
        if (lt != null) r'lt': lt,
        if (lte != null) r'lte': lte,
        if (not != null) r'not': not,
        if (notIn != null) r'notIn': notIn,
        if (startsWith != null) r'startsWith': startsWith,
      });

  Input$NestedStringNullableFilter._(this._$data);

  factory Input$NestedStringNullableFilter.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('contains')) {
      final l$contains = data['contains'];
      result$data['contains'] = (l$contains as String?);
    }
    if (data.containsKey('endsWith')) {
      final l$endsWith = data['endsWith'];
      result$data['endsWith'] = (l$endsWith as String?);
    }
    if (data.containsKey('equals')) {
      final l$equals = data['equals'];
      result$data['equals'] = (l$equals as String?);
    }
    if (data.containsKey('gt')) {
      final l$gt = data['gt'];
      result$data['gt'] = (l$gt as String?);
    }
    if (data.containsKey('gte')) {
      final l$gte = data['gte'];
      result$data['gte'] = (l$gte as String?);
    }
    if (data.containsKey('in')) {
      final l$$in = data['in'];
      result$data['in'] =
          (l$$in as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    if (data.containsKey('lt')) {
      final l$lt = data['lt'];
      result$data['lt'] = (l$lt as String?);
    }
    if (data.containsKey('lte')) {
      final l$lte = data['lte'];
      result$data['lte'] = (l$lte as String?);
    }
    if (data.containsKey('not')) {
      final l$not = data['not'];
      result$data['not'] = l$not == null
          ? null
          : Input$NestedStringNullableFilter.fromJson(
              (l$not as Map<String, dynamic>));
    }
    if (data.containsKey('notIn')) {
      final l$notIn = data['notIn'];
      result$data['notIn'] =
          (l$notIn as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    if (data.containsKey('startsWith')) {
      final l$startsWith = data['startsWith'];
      result$data['startsWith'] = (l$startsWith as String?);
    }
    return Input$NestedStringNullableFilter._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get contains => (_$data['contains'] as String?);

  String? get endsWith => (_$data['endsWith'] as String?);

  String? get equals => (_$data['equals'] as String?);

  String? get gt => (_$data['gt'] as String?);

  String? get gte => (_$data['gte'] as String?);

  List<String>? get $in => (_$data['in'] as List<String>?);

  String? get lt => (_$data['lt'] as String?);

  String? get lte => (_$data['lte'] as String?);

  Input$NestedStringNullableFilter? get not =>
      (_$data['not'] as Input$NestedStringNullableFilter?);

  List<String>? get notIn => (_$data['notIn'] as List<String>?);

  String? get startsWith => (_$data['startsWith'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('contains')) {
      final l$contains = contains;
      result$data['contains'] = l$contains;
    }
    if (_$data.containsKey('endsWith')) {
      final l$endsWith = endsWith;
      result$data['endsWith'] = l$endsWith;
    }
    if (_$data.containsKey('equals')) {
      final l$equals = equals;
      result$data['equals'] = l$equals;
    }
    if (_$data.containsKey('gt')) {
      final l$gt = gt;
      result$data['gt'] = l$gt;
    }
    if (_$data.containsKey('gte')) {
      final l$gte = gte;
      result$data['gte'] = l$gte;
    }
    if (_$data.containsKey('in')) {
      final l$$in = $in;
      result$data['in'] = l$$in?.map((e) => e).toList();
    }
    if (_$data.containsKey('lt')) {
      final l$lt = lt;
      result$data['lt'] = l$lt;
    }
    if (_$data.containsKey('lte')) {
      final l$lte = lte;
      result$data['lte'] = l$lte;
    }
    if (_$data.containsKey('not')) {
      final l$not = not;
      result$data['not'] = l$not?.toJson();
    }
    if (_$data.containsKey('notIn')) {
      final l$notIn = notIn;
      result$data['notIn'] = l$notIn?.map((e) => e).toList();
    }
    if (_$data.containsKey('startsWith')) {
      final l$startsWith = startsWith;
      result$data['startsWith'] = l$startsWith;
    }
    return result$data;
  }

  CopyWith$Input$NestedStringNullableFilter<Input$NestedStringNullableFilter>
      get copyWith => CopyWith$Input$NestedStringNullableFilter(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$NestedStringNullableFilter) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$contains = contains;
    final lOther$contains = other.contains;
    if (_$data.containsKey('contains') !=
        other._$data.containsKey('contains')) {
      return false;
    }
    if (l$contains != lOther$contains) {
      return false;
    }
    final l$endsWith = endsWith;
    final lOther$endsWith = other.endsWith;
    if (_$data.containsKey('endsWith') !=
        other._$data.containsKey('endsWith')) {
      return false;
    }
    if (l$endsWith != lOther$endsWith) {
      return false;
    }
    final l$equals = equals;
    final lOther$equals = other.equals;
    if (_$data.containsKey('equals') != other._$data.containsKey('equals')) {
      return false;
    }
    if (l$equals != lOther$equals) {
      return false;
    }
    final l$gt = gt;
    final lOther$gt = other.gt;
    if (_$data.containsKey('gt') != other._$data.containsKey('gt')) {
      return false;
    }
    if (l$gt != lOther$gt) {
      return false;
    }
    final l$gte = gte;
    final lOther$gte = other.gte;
    if (_$data.containsKey('gte') != other._$data.containsKey('gte')) {
      return false;
    }
    if (l$gte != lOther$gte) {
      return false;
    }
    final l$$in = $in;
    final lOther$$in = other.$in;
    if (_$data.containsKey('in') != other._$data.containsKey('in')) {
      return false;
    }
    if (l$$in != null && lOther$$in != null) {
      if (l$$in.length != lOther$$in.length) {
        return false;
      }
      for (int i = 0; i < l$$in.length; i++) {
        final l$$in$entry = l$$in[i];
        final lOther$$in$entry = lOther$$in[i];
        if (l$$in$entry != lOther$$in$entry) {
          return false;
        }
      }
    } else if (l$$in != lOther$$in) {
      return false;
    }
    final l$lt = lt;
    final lOther$lt = other.lt;
    if (_$data.containsKey('lt') != other._$data.containsKey('lt')) {
      return false;
    }
    if (l$lt != lOther$lt) {
      return false;
    }
    final l$lte = lte;
    final lOther$lte = other.lte;
    if (_$data.containsKey('lte') != other._$data.containsKey('lte')) {
      return false;
    }
    if (l$lte != lOther$lte) {
      return false;
    }
    final l$not = not;
    final lOther$not = other.not;
    if (_$data.containsKey('not') != other._$data.containsKey('not')) {
      return false;
    }
    if (l$not != lOther$not) {
      return false;
    }
    final l$notIn = notIn;
    final lOther$notIn = other.notIn;
    if (_$data.containsKey('notIn') != other._$data.containsKey('notIn')) {
      return false;
    }
    if (l$notIn != null && lOther$notIn != null) {
      if (l$notIn.length != lOther$notIn.length) {
        return false;
      }
      for (int i = 0; i < l$notIn.length; i++) {
        final l$notIn$entry = l$notIn[i];
        final lOther$notIn$entry = lOther$notIn[i];
        if (l$notIn$entry != lOther$notIn$entry) {
          return false;
        }
      }
    } else if (l$notIn != lOther$notIn) {
      return false;
    }
    final l$startsWith = startsWith;
    final lOther$startsWith = other.startsWith;
    if (_$data.containsKey('startsWith') !=
        other._$data.containsKey('startsWith')) {
      return false;
    }
    if (l$startsWith != lOther$startsWith) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$contains = contains;
    final l$endsWith = endsWith;
    final l$equals = equals;
    final l$gt = gt;
    final l$gte = gte;
    final l$$in = $in;
    final l$lt = lt;
    final l$lte = lte;
    final l$not = not;
    final l$notIn = notIn;
    final l$startsWith = startsWith;
    return Object.hashAll([
      _$data.containsKey('contains') ? l$contains : const {},
      _$data.containsKey('endsWith') ? l$endsWith : const {},
      _$data.containsKey('equals') ? l$equals : const {},
      _$data.containsKey('gt') ? l$gt : const {},
      _$data.containsKey('gte') ? l$gte : const {},
      _$data.containsKey('in')
          ? l$$in == null
              ? null
              : Object.hashAll(l$$in.map((v) => v))
          : const {},
      _$data.containsKey('lt') ? l$lt : const {},
      _$data.containsKey('lte') ? l$lte : const {},
      _$data.containsKey('not') ? l$not : const {},
      _$data.containsKey('notIn')
          ? l$notIn == null
              ? null
              : Object.hashAll(l$notIn.map((v) => v))
          : const {},
      _$data.containsKey('startsWith') ? l$startsWith : const {},
    ]);
  }
}

abstract class CopyWith$Input$NestedStringNullableFilter<TRes> {
  factory CopyWith$Input$NestedStringNullableFilter(
    Input$NestedStringNullableFilter instance,
    TRes Function(Input$NestedStringNullableFilter) then,
  ) = _CopyWithImpl$Input$NestedStringNullableFilter;

  factory CopyWith$Input$NestedStringNullableFilter.stub(TRes res) =
      _CopyWithStubImpl$Input$NestedStringNullableFilter;

  TRes call({
    String? contains,
    String? endsWith,
    String? equals,
    String? gt,
    String? gte,
    List<String>? $in,
    String? lt,
    String? lte,
    Input$NestedStringNullableFilter? not,
    List<String>? notIn,
    String? startsWith,
  });
  CopyWith$Input$NestedStringNullableFilter<TRes> get not;
}

class _CopyWithImpl$Input$NestedStringNullableFilter<TRes>
    implements CopyWith$Input$NestedStringNullableFilter<TRes> {
  _CopyWithImpl$Input$NestedStringNullableFilter(
    this._instance,
    this._then,
  );

  final Input$NestedStringNullableFilter _instance;

  final TRes Function(Input$NestedStringNullableFilter) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? contains = _undefined,
    Object? endsWith = _undefined,
    Object? equals = _undefined,
    Object? gt = _undefined,
    Object? gte = _undefined,
    Object? $in = _undefined,
    Object? lt = _undefined,
    Object? lte = _undefined,
    Object? not = _undefined,
    Object? notIn = _undefined,
    Object? startsWith = _undefined,
  }) =>
      _then(Input$NestedStringNullableFilter._({
        ..._instance._$data,
        if (contains != _undefined) 'contains': (contains as String?),
        if (endsWith != _undefined) 'endsWith': (endsWith as String?),
        if (equals != _undefined) 'equals': (equals as String?),
        if (gt != _undefined) 'gt': (gt as String?),
        if (gte != _undefined) 'gte': (gte as String?),
        if ($in != _undefined) 'in': ($in as List<String>?),
        if (lt != _undefined) 'lt': (lt as String?),
        if (lte != _undefined) 'lte': (lte as String?),
        if (not != _undefined)
          'not': (not as Input$NestedStringNullableFilter?),
        if (notIn != _undefined) 'notIn': (notIn as List<String>?),
        if (startsWith != _undefined) 'startsWith': (startsWith as String?),
      }));

  CopyWith$Input$NestedStringNullableFilter<TRes> get not {
    final local$not = _instance.not;
    return local$not == null
        ? CopyWith$Input$NestedStringNullableFilter.stub(_then(_instance))
        : CopyWith$Input$NestedStringNullableFilter(
            local$not, (e) => call(not: e));
  }
}

class _CopyWithStubImpl$Input$NestedStringNullableFilter<TRes>
    implements CopyWith$Input$NestedStringNullableFilter<TRes> {
  _CopyWithStubImpl$Input$NestedStringNullableFilter(this._res);

  TRes _res;

  call({
    String? contains,
    String? endsWith,
    String? equals,
    String? gt,
    String? gte,
    List<String>? $in,
    String? lt,
    String? lte,
    Input$NestedStringNullableFilter? not,
    List<String>? notIn,
    String? startsWith,
  }) =>
      _res;

  CopyWith$Input$NestedStringNullableFilter<TRes> get not =>
      CopyWith$Input$NestedStringNullableFilter.stub(_res);
}

class Input$NestedStringNullableWithAggregatesFilter {
  factory Input$NestedStringNullableWithAggregatesFilter({
    Input$NestedIntNullableFilter? $_count,
    Input$NestedStringNullableFilter? $_max,
    Input$NestedStringNullableFilter? $_min,
    String? contains,
    String? endsWith,
    String? equals,
    String? gt,
    String? gte,
    List<String>? $in,
    String? lt,
    String? lte,
    Input$NestedStringNullableWithAggregatesFilter? not,
    List<String>? notIn,
    String? startsWith,
  }) =>
      Input$NestedStringNullableWithAggregatesFilter._({
        if ($_count != null) r'_count': $_count,
        if ($_max != null) r'_max': $_max,
        if ($_min != null) r'_min': $_min,
        if (contains != null) r'contains': contains,
        if (endsWith != null) r'endsWith': endsWith,
        if (equals != null) r'equals': equals,
        if (gt != null) r'gt': gt,
        if (gte != null) r'gte': gte,
        if ($in != null) r'in': $in,
        if (lt != null) r'lt': lt,
        if (lte != null) r'lte': lte,
        if (not != null) r'not': not,
        if (notIn != null) r'notIn': notIn,
        if (startsWith != null) r'startsWith': startsWith,
      });

  Input$NestedStringNullableWithAggregatesFilter._(this._$data);

  factory Input$NestedStringNullableWithAggregatesFilter.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('_count')) {
      final l$$_count = data['_count'];
      result$data['_count'] = l$$_count == null
          ? null
          : Input$NestedIntNullableFilter.fromJson(
              (l$$_count as Map<String, dynamic>));
    }
    if (data.containsKey('_max')) {
      final l$$_max = data['_max'];
      result$data['_max'] = l$$_max == null
          ? null
          : Input$NestedStringNullableFilter.fromJson(
              (l$$_max as Map<String, dynamic>));
    }
    if (data.containsKey('_min')) {
      final l$$_min = data['_min'];
      result$data['_min'] = l$$_min == null
          ? null
          : Input$NestedStringNullableFilter.fromJson(
              (l$$_min as Map<String, dynamic>));
    }
    if (data.containsKey('contains')) {
      final l$contains = data['contains'];
      result$data['contains'] = (l$contains as String?);
    }
    if (data.containsKey('endsWith')) {
      final l$endsWith = data['endsWith'];
      result$data['endsWith'] = (l$endsWith as String?);
    }
    if (data.containsKey('equals')) {
      final l$equals = data['equals'];
      result$data['equals'] = (l$equals as String?);
    }
    if (data.containsKey('gt')) {
      final l$gt = data['gt'];
      result$data['gt'] = (l$gt as String?);
    }
    if (data.containsKey('gte')) {
      final l$gte = data['gte'];
      result$data['gte'] = (l$gte as String?);
    }
    if (data.containsKey('in')) {
      final l$$in = data['in'];
      result$data['in'] =
          (l$$in as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    if (data.containsKey('lt')) {
      final l$lt = data['lt'];
      result$data['lt'] = (l$lt as String?);
    }
    if (data.containsKey('lte')) {
      final l$lte = data['lte'];
      result$data['lte'] = (l$lte as String?);
    }
    if (data.containsKey('not')) {
      final l$not = data['not'];
      result$data['not'] = l$not == null
          ? null
          : Input$NestedStringNullableWithAggregatesFilter.fromJson(
              (l$not as Map<String, dynamic>));
    }
    if (data.containsKey('notIn')) {
      final l$notIn = data['notIn'];
      result$data['notIn'] =
          (l$notIn as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    if (data.containsKey('startsWith')) {
      final l$startsWith = data['startsWith'];
      result$data['startsWith'] = (l$startsWith as String?);
    }
    return Input$NestedStringNullableWithAggregatesFilter._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$NestedIntNullableFilter? get $_count =>
      (_$data['_count'] as Input$NestedIntNullableFilter?);

  Input$NestedStringNullableFilter? get $_max =>
      (_$data['_max'] as Input$NestedStringNullableFilter?);

  Input$NestedStringNullableFilter? get $_min =>
      (_$data['_min'] as Input$NestedStringNullableFilter?);

  String? get contains => (_$data['contains'] as String?);

  String? get endsWith => (_$data['endsWith'] as String?);

  String? get equals => (_$data['equals'] as String?);

  String? get gt => (_$data['gt'] as String?);

  String? get gte => (_$data['gte'] as String?);

  List<String>? get $in => (_$data['in'] as List<String>?);

  String? get lt => (_$data['lt'] as String?);

  String? get lte => (_$data['lte'] as String?);

  Input$NestedStringNullableWithAggregatesFilter? get not =>
      (_$data['not'] as Input$NestedStringNullableWithAggregatesFilter?);

  List<String>? get notIn => (_$data['notIn'] as List<String>?);

  String? get startsWith => (_$data['startsWith'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('_count')) {
      final l$$_count = $_count;
      result$data['_count'] = l$$_count?.toJson();
    }
    if (_$data.containsKey('_max')) {
      final l$$_max = $_max;
      result$data['_max'] = l$$_max?.toJson();
    }
    if (_$data.containsKey('_min')) {
      final l$$_min = $_min;
      result$data['_min'] = l$$_min?.toJson();
    }
    if (_$data.containsKey('contains')) {
      final l$contains = contains;
      result$data['contains'] = l$contains;
    }
    if (_$data.containsKey('endsWith')) {
      final l$endsWith = endsWith;
      result$data['endsWith'] = l$endsWith;
    }
    if (_$data.containsKey('equals')) {
      final l$equals = equals;
      result$data['equals'] = l$equals;
    }
    if (_$data.containsKey('gt')) {
      final l$gt = gt;
      result$data['gt'] = l$gt;
    }
    if (_$data.containsKey('gte')) {
      final l$gte = gte;
      result$data['gte'] = l$gte;
    }
    if (_$data.containsKey('in')) {
      final l$$in = $in;
      result$data['in'] = l$$in?.map((e) => e).toList();
    }
    if (_$data.containsKey('lt')) {
      final l$lt = lt;
      result$data['lt'] = l$lt;
    }
    if (_$data.containsKey('lte')) {
      final l$lte = lte;
      result$data['lte'] = l$lte;
    }
    if (_$data.containsKey('not')) {
      final l$not = not;
      result$data['not'] = l$not?.toJson();
    }
    if (_$data.containsKey('notIn')) {
      final l$notIn = notIn;
      result$data['notIn'] = l$notIn?.map((e) => e).toList();
    }
    if (_$data.containsKey('startsWith')) {
      final l$startsWith = startsWith;
      result$data['startsWith'] = l$startsWith;
    }
    return result$data;
  }

  CopyWith$Input$NestedStringNullableWithAggregatesFilter<
          Input$NestedStringNullableWithAggregatesFilter>
      get copyWith => CopyWith$Input$NestedStringNullableWithAggregatesFilter(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$NestedStringNullableWithAggregatesFilter) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$$_count = $_count;
    final lOther$$_count = other.$_count;
    if (_$data.containsKey('_count') != other._$data.containsKey('_count')) {
      return false;
    }
    if (l$$_count != lOther$$_count) {
      return false;
    }
    final l$$_max = $_max;
    final lOther$$_max = other.$_max;
    if (_$data.containsKey('_max') != other._$data.containsKey('_max')) {
      return false;
    }
    if (l$$_max != lOther$$_max) {
      return false;
    }
    final l$$_min = $_min;
    final lOther$$_min = other.$_min;
    if (_$data.containsKey('_min') != other._$data.containsKey('_min')) {
      return false;
    }
    if (l$$_min != lOther$$_min) {
      return false;
    }
    final l$contains = contains;
    final lOther$contains = other.contains;
    if (_$data.containsKey('contains') !=
        other._$data.containsKey('contains')) {
      return false;
    }
    if (l$contains != lOther$contains) {
      return false;
    }
    final l$endsWith = endsWith;
    final lOther$endsWith = other.endsWith;
    if (_$data.containsKey('endsWith') !=
        other._$data.containsKey('endsWith')) {
      return false;
    }
    if (l$endsWith != lOther$endsWith) {
      return false;
    }
    final l$equals = equals;
    final lOther$equals = other.equals;
    if (_$data.containsKey('equals') != other._$data.containsKey('equals')) {
      return false;
    }
    if (l$equals != lOther$equals) {
      return false;
    }
    final l$gt = gt;
    final lOther$gt = other.gt;
    if (_$data.containsKey('gt') != other._$data.containsKey('gt')) {
      return false;
    }
    if (l$gt != lOther$gt) {
      return false;
    }
    final l$gte = gte;
    final lOther$gte = other.gte;
    if (_$data.containsKey('gte') != other._$data.containsKey('gte')) {
      return false;
    }
    if (l$gte != lOther$gte) {
      return false;
    }
    final l$$in = $in;
    final lOther$$in = other.$in;
    if (_$data.containsKey('in') != other._$data.containsKey('in')) {
      return false;
    }
    if (l$$in != null && lOther$$in != null) {
      if (l$$in.length != lOther$$in.length) {
        return false;
      }
      for (int i = 0; i < l$$in.length; i++) {
        final l$$in$entry = l$$in[i];
        final lOther$$in$entry = lOther$$in[i];
        if (l$$in$entry != lOther$$in$entry) {
          return false;
        }
      }
    } else if (l$$in != lOther$$in) {
      return false;
    }
    final l$lt = lt;
    final lOther$lt = other.lt;
    if (_$data.containsKey('lt') != other._$data.containsKey('lt')) {
      return false;
    }
    if (l$lt != lOther$lt) {
      return false;
    }
    final l$lte = lte;
    final lOther$lte = other.lte;
    if (_$data.containsKey('lte') != other._$data.containsKey('lte')) {
      return false;
    }
    if (l$lte != lOther$lte) {
      return false;
    }
    final l$not = not;
    final lOther$not = other.not;
    if (_$data.containsKey('not') != other._$data.containsKey('not')) {
      return false;
    }
    if (l$not != lOther$not) {
      return false;
    }
    final l$notIn = notIn;
    final lOther$notIn = other.notIn;
    if (_$data.containsKey('notIn') != other._$data.containsKey('notIn')) {
      return false;
    }
    if (l$notIn != null && lOther$notIn != null) {
      if (l$notIn.length != lOther$notIn.length) {
        return false;
      }
      for (int i = 0; i < l$notIn.length; i++) {
        final l$notIn$entry = l$notIn[i];
        final lOther$notIn$entry = lOther$notIn[i];
        if (l$notIn$entry != lOther$notIn$entry) {
          return false;
        }
      }
    } else if (l$notIn != lOther$notIn) {
      return false;
    }
    final l$startsWith = startsWith;
    final lOther$startsWith = other.startsWith;
    if (_$data.containsKey('startsWith') !=
        other._$data.containsKey('startsWith')) {
      return false;
    }
    if (l$startsWith != lOther$startsWith) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$$_count = $_count;
    final l$$_max = $_max;
    final l$$_min = $_min;
    final l$contains = contains;
    final l$endsWith = endsWith;
    final l$equals = equals;
    final l$gt = gt;
    final l$gte = gte;
    final l$$in = $in;
    final l$lt = lt;
    final l$lte = lte;
    final l$not = not;
    final l$notIn = notIn;
    final l$startsWith = startsWith;
    return Object.hashAll([
      _$data.containsKey('_count') ? l$$_count : const {},
      _$data.containsKey('_max') ? l$$_max : const {},
      _$data.containsKey('_min') ? l$$_min : const {},
      _$data.containsKey('contains') ? l$contains : const {},
      _$data.containsKey('endsWith') ? l$endsWith : const {},
      _$data.containsKey('equals') ? l$equals : const {},
      _$data.containsKey('gt') ? l$gt : const {},
      _$data.containsKey('gte') ? l$gte : const {},
      _$data.containsKey('in')
          ? l$$in == null
              ? null
              : Object.hashAll(l$$in.map((v) => v))
          : const {},
      _$data.containsKey('lt') ? l$lt : const {},
      _$data.containsKey('lte') ? l$lte : const {},
      _$data.containsKey('not') ? l$not : const {},
      _$data.containsKey('notIn')
          ? l$notIn == null
              ? null
              : Object.hashAll(l$notIn.map((v) => v))
          : const {},
      _$data.containsKey('startsWith') ? l$startsWith : const {},
    ]);
  }
}

abstract class CopyWith$Input$NestedStringNullableWithAggregatesFilter<TRes> {
  factory CopyWith$Input$NestedStringNullableWithAggregatesFilter(
    Input$NestedStringNullableWithAggregatesFilter instance,
    TRes Function(Input$NestedStringNullableWithAggregatesFilter) then,
  ) = _CopyWithImpl$Input$NestedStringNullableWithAggregatesFilter;

  factory CopyWith$Input$NestedStringNullableWithAggregatesFilter.stub(
          TRes res) =
      _CopyWithStubImpl$Input$NestedStringNullableWithAggregatesFilter;

  TRes call({
    Input$NestedIntNullableFilter? $_count,
    Input$NestedStringNullableFilter? $_max,
    Input$NestedStringNullableFilter? $_min,
    String? contains,
    String? endsWith,
    String? equals,
    String? gt,
    String? gte,
    List<String>? $in,
    String? lt,
    String? lte,
    Input$NestedStringNullableWithAggregatesFilter? not,
    List<String>? notIn,
    String? startsWith,
  });
  CopyWith$Input$NestedIntNullableFilter<TRes> get $_count;
  CopyWith$Input$NestedStringNullableFilter<TRes> get $_max;
  CopyWith$Input$NestedStringNullableFilter<TRes> get $_min;
  CopyWith$Input$NestedStringNullableWithAggregatesFilter<TRes> get not;
}

class _CopyWithImpl$Input$NestedStringNullableWithAggregatesFilter<TRes>
    implements CopyWith$Input$NestedStringNullableWithAggregatesFilter<TRes> {
  _CopyWithImpl$Input$NestedStringNullableWithAggregatesFilter(
    this._instance,
    this._then,
  );

  final Input$NestedStringNullableWithAggregatesFilter _instance;

  final TRes Function(Input$NestedStringNullableWithAggregatesFilter) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? $_count = _undefined,
    Object? $_max = _undefined,
    Object? $_min = _undefined,
    Object? contains = _undefined,
    Object? endsWith = _undefined,
    Object? equals = _undefined,
    Object? gt = _undefined,
    Object? gte = _undefined,
    Object? $in = _undefined,
    Object? lt = _undefined,
    Object? lte = _undefined,
    Object? not = _undefined,
    Object? notIn = _undefined,
    Object? startsWith = _undefined,
  }) =>
      _then(Input$NestedStringNullableWithAggregatesFilter._({
        ..._instance._$data,
        if ($_count != _undefined)
          '_count': ($_count as Input$NestedIntNullableFilter?),
        if ($_max != _undefined)
          '_max': ($_max as Input$NestedStringNullableFilter?),
        if ($_min != _undefined)
          '_min': ($_min as Input$NestedStringNullableFilter?),
        if (contains != _undefined) 'contains': (contains as String?),
        if (endsWith != _undefined) 'endsWith': (endsWith as String?),
        if (equals != _undefined) 'equals': (equals as String?),
        if (gt != _undefined) 'gt': (gt as String?),
        if (gte != _undefined) 'gte': (gte as String?),
        if ($in != _undefined) 'in': ($in as List<String>?),
        if (lt != _undefined) 'lt': (lt as String?),
        if (lte != _undefined) 'lte': (lte as String?),
        if (not != _undefined)
          'not': (not as Input$NestedStringNullableWithAggregatesFilter?),
        if (notIn != _undefined) 'notIn': (notIn as List<String>?),
        if (startsWith != _undefined) 'startsWith': (startsWith as String?),
      }));

  CopyWith$Input$NestedIntNullableFilter<TRes> get $_count {
    final local$$_count = _instance.$_count;
    return local$$_count == null
        ? CopyWith$Input$NestedIntNullableFilter.stub(_then(_instance))
        : CopyWith$Input$NestedIntNullableFilter(
            local$$_count, (e) => call($_count: e));
  }

  CopyWith$Input$NestedStringNullableFilter<TRes> get $_max {
    final local$$_max = _instance.$_max;
    return local$$_max == null
        ? CopyWith$Input$NestedStringNullableFilter.stub(_then(_instance))
        : CopyWith$Input$NestedStringNullableFilter(
            local$$_max, (e) => call($_max: e));
  }

  CopyWith$Input$NestedStringNullableFilter<TRes> get $_min {
    final local$$_min = _instance.$_min;
    return local$$_min == null
        ? CopyWith$Input$NestedStringNullableFilter.stub(_then(_instance))
        : CopyWith$Input$NestedStringNullableFilter(
            local$$_min, (e) => call($_min: e));
  }

  CopyWith$Input$NestedStringNullableWithAggregatesFilter<TRes> get not {
    final local$not = _instance.not;
    return local$not == null
        ? CopyWith$Input$NestedStringNullableWithAggregatesFilter.stub(
            _then(_instance))
        : CopyWith$Input$NestedStringNullableWithAggregatesFilter(
            local$not, (e) => call(not: e));
  }
}

class _CopyWithStubImpl$Input$NestedStringNullableWithAggregatesFilter<TRes>
    implements CopyWith$Input$NestedStringNullableWithAggregatesFilter<TRes> {
  _CopyWithStubImpl$Input$NestedStringNullableWithAggregatesFilter(this._res);

  TRes _res;

  call({
    Input$NestedIntNullableFilter? $_count,
    Input$NestedStringNullableFilter? $_max,
    Input$NestedStringNullableFilter? $_min,
    String? contains,
    String? endsWith,
    String? equals,
    String? gt,
    String? gte,
    List<String>? $in,
    String? lt,
    String? lte,
    Input$NestedStringNullableWithAggregatesFilter? not,
    List<String>? notIn,
    String? startsWith,
  }) =>
      _res;

  CopyWith$Input$NestedIntNullableFilter<TRes> get $_count =>
      CopyWith$Input$NestedIntNullableFilter.stub(_res);

  CopyWith$Input$NestedStringNullableFilter<TRes> get $_max =>
      CopyWith$Input$NestedStringNullableFilter.stub(_res);

  CopyWith$Input$NestedStringNullableFilter<TRes> get $_min =>
      CopyWith$Input$NestedStringNullableFilter.stub(_res);

  CopyWith$Input$NestedStringNullableWithAggregatesFilter<TRes> get not =>
      CopyWith$Input$NestedStringNullableWithAggregatesFilter.stub(_res);
}

class Input$NestedStringWithAggregatesFilter {
  factory Input$NestedStringWithAggregatesFilter({
    Input$NestedIntFilter? $_count,
    Input$NestedStringFilter? $_max,
    Input$NestedStringFilter? $_min,
    String? contains,
    String? endsWith,
    String? equals,
    String? gt,
    String? gte,
    List<String>? $in,
    String? lt,
    String? lte,
    Input$NestedStringWithAggregatesFilter? not,
    List<String>? notIn,
    String? startsWith,
  }) =>
      Input$NestedStringWithAggregatesFilter._({
        if ($_count != null) r'_count': $_count,
        if ($_max != null) r'_max': $_max,
        if ($_min != null) r'_min': $_min,
        if (contains != null) r'contains': contains,
        if (endsWith != null) r'endsWith': endsWith,
        if (equals != null) r'equals': equals,
        if (gt != null) r'gt': gt,
        if (gte != null) r'gte': gte,
        if ($in != null) r'in': $in,
        if (lt != null) r'lt': lt,
        if (lte != null) r'lte': lte,
        if (not != null) r'not': not,
        if (notIn != null) r'notIn': notIn,
        if (startsWith != null) r'startsWith': startsWith,
      });

  Input$NestedStringWithAggregatesFilter._(this._$data);

  factory Input$NestedStringWithAggregatesFilter.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('_count')) {
      final l$$_count = data['_count'];
      result$data['_count'] = l$$_count == null
          ? null
          : Input$NestedIntFilter.fromJson((l$$_count as Map<String, dynamic>));
    }
    if (data.containsKey('_max')) {
      final l$$_max = data['_max'];
      result$data['_max'] = l$$_max == null
          ? null
          : Input$NestedStringFilter.fromJson(
              (l$$_max as Map<String, dynamic>));
    }
    if (data.containsKey('_min')) {
      final l$$_min = data['_min'];
      result$data['_min'] = l$$_min == null
          ? null
          : Input$NestedStringFilter.fromJson(
              (l$$_min as Map<String, dynamic>));
    }
    if (data.containsKey('contains')) {
      final l$contains = data['contains'];
      result$data['contains'] = (l$contains as String?);
    }
    if (data.containsKey('endsWith')) {
      final l$endsWith = data['endsWith'];
      result$data['endsWith'] = (l$endsWith as String?);
    }
    if (data.containsKey('equals')) {
      final l$equals = data['equals'];
      result$data['equals'] = (l$equals as String?);
    }
    if (data.containsKey('gt')) {
      final l$gt = data['gt'];
      result$data['gt'] = (l$gt as String?);
    }
    if (data.containsKey('gte')) {
      final l$gte = data['gte'];
      result$data['gte'] = (l$gte as String?);
    }
    if (data.containsKey('in')) {
      final l$$in = data['in'];
      result$data['in'] =
          (l$$in as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    if (data.containsKey('lt')) {
      final l$lt = data['lt'];
      result$data['lt'] = (l$lt as String?);
    }
    if (data.containsKey('lte')) {
      final l$lte = data['lte'];
      result$data['lte'] = (l$lte as String?);
    }
    if (data.containsKey('not')) {
      final l$not = data['not'];
      result$data['not'] = l$not == null
          ? null
          : Input$NestedStringWithAggregatesFilter.fromJson(
              (l$not as Map<String, dynamic>));
    }
    if (data.containsKey('notIn')) {
      final l$notIn = data['notIn'];
      result$data['notIn'] =
          (l$notIn as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    if (data.containsKey('startsWith')) {
      final l$startsWith = data['startsWith'];
      result$data['startsWith'] = (l$startsWith as String?);
    }
    return Input$NestedStringWithAggregatesFilter._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$NestedIntFilter? get $_count =>
      (_$data['_count'] as Input$NestedIntFilter?);

  Input$NestedStringFilter? get $_max =>
      (_$data['_max'] as Input$NestedStringFilter?);

  Input$NestedStringFilter? get $_min =>
      (_$data['_min'] as Input$NestedStringFilter?);

  String? get contains => (_$data['contains'] as String?);

  String? get endsWith => (_$data['endsWith'] as String?);

  String? get equals => (_$data['equals'] as String?);

  String? get gt => (_$data['gt'] as String?);

  String? get gte => (_$data['gte'] as String?);

  List<String>? get $in => (_$data['in'] as List<String>?);

  String? get lt => (_$data['lt'] as String?);

  String? get lte => (_$data['lte'] as String?);

  Input$NestedStringWithAggregatesFilter? get not =>
      (_$data['not'] as Input$NestedStringWithAggregatesFilter?);

  List<String>? get notIn => (_$data['notIn'] as List<String>?);

  String? get startsWith => (_$data['startsWith'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('_count')) {
      final l$$_count = $_count;
      result$data['_count'] = l$$_count?.toJson();
    }
    if (_$data.containsKey('_max')) {
      final l$$_max = $_max;
      result$data['_max'] = l$$_max?.toJson();
    }
    if (_$data.containsKey('_min')) {
      final l$$_min = $_min;
      result$data['_min'] = l$$_min?.toJson();
    }
    if (_$data.containsKey('contains')) {
      final l$contains = contains;
      result$data['contains'] = l$contains;
    }
    if (_$data.containsKey('endsWith')) {
      final l$endsWith = endsWith;
      result$data['endsWith'] = l$endsWith;
    }
    if (_$data.containsKey('equals')) {
      final l$equals = equals;
      result$data['equals'] = l$equals;
    }
    if (_$data.containsKey('gt')) {
      final l$gt = gt;
      result$data['gt'] = l$gt;
    }
    if (_$data.containsKey('gte')) {
      final l$gte = gte;
      result$data['gte'] = l$gte;
    }
    if (_$data.containsKey('in')) {
      final l$$in = $in;
      result$data['in'] = l$$in?.map((e) => e).toList();
    }
    if (_$data.containsKey('lt')) {
      final l$lt = lt;
      result$data['lt'] = l$lt;
    }
    if (_$data.containsKey('lte')) {
      final l$lte = lte;
      result$data['lte'] = l$lte;
    }
    if (_$data.containsKey('not')) {
      final l$not = not;
      result$data['not'] = l$not?.toJson();
    }
    if (_$data.containsKey('notIn')) {
      final l$notIn = notIn;
      result$data['notIn'] = l$notIn?.map((e) => e).toList();
    }
    if (_$data.containsKey('startsWith')) {
      final l$startsWith = startsWith;
      result$data['startsWith'] = l$startsWith;
    }
    return result$data;
  }

  CopyWith$Input$NestedStringWithAggregatesFilter<
          Input$NestedStringWithAggregatesFilter>
      get copyWith => CopyWith$Input$NestedStringWithAggregatesFilter(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$NestedStringWithAggregatesFilter) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$$_count = $_count;
    final lOther$$_count = other.$_count;
    if (_$data.containsKey('_count') != other._$data.containsKey('_count')) {
      return false;
    }
    if (l$$_count != lOther$$_count) {
      return false;
    }
    final l$$_max = $_max;
    final lOther$$_max = other.$_max;
    if (_$data.containsKey('_max') != other._$data.containsKey('_max')) {
      return false;
    }
    if (l$$_max != lOther$$_max) {
      return false;
    }
    final l$$_min = $_min;
    final lOther$$_min = other.$_min;
    if (_$data.containsKey('_min') != other._$data.containsKey('_min')) {
      return false;
    }
    if (l$$_min != lOther$$_min) {
      return false;
    }
    final l$contains = contains;
    final lOther$contains = other.contains;
    if (_$data.containsKey('contains') !=
        other._$data.containsKey('contains')) {
      return false;
    }
    if (l$contains != lOther$contains) {
      return false;
    }
    final l$endsWith = endsWith;
    final lOther$endsWith = other.endsWith;
    if (_$data.containsKey('endsWith') !=
        other._$data.containsKey('endsWith')) {
      return false;
    }
    if (l$endsWith != lOther$endsWith) {
      return false;
    }
    final l$equals = equals;
    final lOther$equals = other.equals;
    if (_$data.containsKey('equals') != other._$data.containsKey('equals')) {
      return false;
    }
    if (l$equals != lOther$equals) {
      return false;
    }
    final l$gt = gt;
    final lOther$gt = other.gt;
    if (_$data.containsKey('gt') != other._$data.containsKey('gt')) {
      return false;
    }
    if (l$gt != lOther$gt) {
      return false;
    }
    final l$gte = gte;
    final lOther$gte = other.gte;
    if (_$data.containsKey('gte') != other._$data.containsKey('gte')) {
      return false;
    }
    if (l$gte != lOther$gte) {
      return false;
    }
    final l$$in = $in;
    final lOther$$in = other.$in;
    if (_$data.containsKey('in') != other._$data.containsKey('in')) {
      return false;
    }
    if (l$$in != null && lOther$$in != null) {
      if (l$$in.length != lOther$$in.length) {
        return false;
      }
      for (int i = 0; i < l$$in.length; i++) {
        final l$$in$entry = l$$in[i];
        final lOther$$in$entry = lOther$$in[i];
        if (l$$in$entry != lOther$$in$entry) {
          return false;
        }
      }
    } else if (l$$in != lOther$$in) {
      return false;
    }
    final l$lt = lt;
    final lOther$lt = other.lt;
    if (_$data.containsKey('lt') != other._$data.containsKey('lt')) {
      return false;
    }
    if (l$lt != lOther$lt) {
      return false;
    }
    final l$lte = lte;
    final lOther$lte = other.lte;
    if (_$data.containsKey('lte') != other._$data.containsKey('lte')) {
      return false;
    }
    if (l$lte != lOther$lte) {
      return false;
    }
    final l$not = not;
    final lOther$not = other.not;
    if (_$data.containsKey('not') != other._$data.containsKey('not')) {
      return false;
    }
    if (l$not != lOther$not) {
      return false;
    }
    final l$notIn = notIn;
    final lOther$notIn = other.notIn;
    if (_$data.containsKey('notIn') != other._$data.containsKey('notIn')) {
      return false;
    }
    if (l$notIn != null && lOther$notIn != null) {
      if (l$notIn.length != lOther$notIn.length) {
        return false;
      }
      for (int i = 0; i < l$notIn.length; i++) {
        final l$notIn$entry = l$notIn[i];
        final lOther$notIn$entry = lOther$notIn[i];
        if (l$notIn$entry != lOther$notIn$entry) {
          return false;
        }
      }
    } else if (l$notIn != lOther$notIn) {
      return false;
    }
    final l$startsWith = startsWith;
    final lOther$startsWith = other.startsWith;
    if (_$data.containsKey('startsWith') !=
        other._$data.containsKey('startsWith')) {
      return false;
    }
    if (l$startsWith != lOther$startsWith) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$$_count = $_count;
    final l$$_max = $_max;
    final l$$_min = $_min;
    final l$contains = contains;
    final l$endsWith = endsWith;
    final l$equals = equals;
    final l$gt = gt;
    final l$gte = gte;
    final l$$in = $in;
    final l$lt = lt;
    final l$lte = lte;
    final l$not = not;
    final l$notIn = notIn;
    final l$startsWith = startsWith;
    return Object.hashAll([
      _$data.containsKey('_count') ? l$$_count : const {},
      _$data.containsKey('_max') ? l$$_max : const {},
      _$data.containsKey('_min') ? l$$_min : const {},
      _$data.containsKey('contains') ? l$contains : const {},
      _$data.containsKey('endsWith') ? l$endsWith : const {},
      _$data.containsKey('equals') ? l$equals : const {},
      _$data.containsKey('gt') ? l$gt : const {},
      _$data.containsKey('gte') ? l$gte : const {},
      _$data.containsKey('in')
          ? l$$in == null
              ? null
              : Object.hashAll(l$$in.map((v) => v))
          : const {},
      _$data.containsKey('lt') ? l$lt : const {},
      _$data.containsKey('lte') ? l$lte : const {},
      _$data.containsKey('not') ? l$not : const {},
      _$data.containsKey('notIn')
          ? l$notIn == null
              ? null
              : Object.hashAll(l$notIn.map((v) => v))
          : const {},
      _$data.containsKey('startsWith') ? l$startsWith : const {},
    ]);
  }
}

abstract class CopyWith$Input$NestedStringWithAggregatesFilter<TRes> {
  factory CopyWith$Input$NestedStringWithAggregatesFilter(
    Input$NestedStringWithAggregatesFilter instance,
    TRes Function(Input$NestedStringWithAggregatesFilter) then,
  ) = _CopyWithImpl$Input$NestedStringWithAggregatesFilter;

  factory CopyWith$Input$NestedStringWithAggregatesFilter.stub(TRes res) =
      _CopyWithStubImpl$Input$NestedStringWithAggregatesFilter;

  TRes call({
    Input$NestedIntFilter? $_count,
    Input$NestedStringFilter? $_max,
    Input$NestedStringFilter? $_min,
    String? contains,
    String? endsWith,
    String? equals,
    String? gt,
    String? gte,
    List<String>? $in,
    String? lt,
    String? lte,
    Input$NestedStringWithAggregatesFilter? not,
    List<String>? notIn,
    String? startsWith,
  });
  CopyWith$Input$NestedIntFilter<TRes> get $_count;
  CopyWith$Input$NestedStringFilter<TRes> get $_max;
  CopyWith$Input$NestedStringFilter<TRes> get $_min;
  CopyWith$Input$NestedStringWithAggregatesFilter<TRes> get not;
}

class _CopyWithImpl$Input$NestedStringWithAggregatesFilter<TRes>
    implements CopyWith$Input$NestedStringWithAggregatesFilter<TRes> {
  _CopyWithImpl$Input$NestedStringWithAggregatesFilter(
    this._instance,
    this._then,
  );

  final Input$NestedStringWithAggregatesFilter _instance;

  final TRes Function(Input$NestedStringWithAggregatesFilter) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? $_count = _undefined,
    Object? $_max = _undefined,
    Object? $_min = _undefined,
    Object? contains = _undefined,
    Object? endsWith = _undefined,
    Object? equals = _undefined,
    Object? gt = _undefined,
    Object? gte = _undefined,
    Object? $in = _undefined,
    Object? lt = _undefined,
    Object? lte = _undefined,
    Object? not = _undefined,
    Object? notIn = _undefined,
    Object? startsWith = _undefined,
  }) =>
      _then(Input$NestedStringWithAggregatesFilter._({
        ..._instance._$data,
        if ($_count != _undefined)
          '_count': ($_count as Input$NestedIntFilter?),
        if ($_max != _undefined) '_max': ($_max as Input$NestedStringFilter?),
        if ($_min != _undefined) '_min': ($_min as Input$NestedStringFilter?),
        if (contains != _undefined) 'contains': (contains as String?),
        if (endsWith != _undefined) 'endsWith': (endsWith as String?),
        if (equals != _undefined) 'equals': (equals as String?),
        if (gt != _undefined) 'gt': (gt as String?),
        if (gte != _undefined) 'gte': (gte as String?),
        if ($in != _undefined) 'in': ($in as List<String>?),
        if (lt != _undefined) 'lt': (lt as String?),
        if (lte != _undefined) 'lte': (lte as String?),
        if (not != _undefined)
          'not': (not as Input$NestedStringWithAggregatesFilter?),
        if (notIn != _undefined) 'notIn': (notIn as List<String>?),
        if (startsWith != _undefined) 'startsWith': (startsWith as String?),
      }));

  CopyWith$Input$NestedIntFilter<TRes> get $_count {
    final local$$_count = _instance.$_count;
    return local$$_count == null
        ? CopyWith$Input$NestedIntFilter.stub(_then(_instance))
        : CopyWith$Input$NestedIntFilter(
            local$$_count, (e) => call($_count: e));
  }

  CopyWith$Input$NestedStringFilter<TRes> get $_max {
    final local$$_max = _instance.$_max;
    return local$$_max == null
        ? CopyWith$Input$NestedStringFilter.stub(_then(_instance))
        : CopyWith$Input$NestedStringFilter(local$$_max, (e) => call($_max: e));
  }

  CopyWith$Input$NestedStringFilter<TRes> get $_min {
    final local$$_min = _instance.$_min;
    return local$$_min == null
        ? CopyWith$Input$NestedStringFilter.stub(_then(_instance))
        : CopyWith$Input$NestedStringFilter(local$$_min, (e) => call($_min: e));
  }

  CopyWith$Input$NestedStringWithAggregatesFilter<TRes> get not {
    final local$not = _instance.not;
    return local$not == null
        ? CopyWith$Input$NestedStringWithAggregatesFilter.stub(_then(_instance))
        : CopyWith$Input$NestedStringWithAggregatesFilter(
            local$not, (e) => call(not: e));
  }
}

class _CopyWithStubImpl$Input$NestedStringWithAggregatesFilter<TRes>
    implements CopyWith$Input$NestedStringWithAggregatesFilter<TRes> {
  _CopyWithStubImpl$Input$NestedStringWithAggregatesFilter(this._res);

  TRes _res;

  call({
    Input$NestedIntFilter? $_count,
    Input$NestedStringFilter? $_max,
    Input$NestedStringFilter? $_min,
    String? contains,
    String? endsWith,
    String? equals,
    String? gt,
    String? gte,
    List<String>? $in,
    String? lt,
    String? lte,
    Input$NestedStringWithAggregatesFilter? not,
    List<String>? notIn,
    String? startsWith,
  }) =>
      _res;

  CopyWith$Input$NestedIntFilter<TRes> get $_count =>
      CopyWith$Input$NestedIntFilter.stub(_res);

  CopyWith$Input$NestedStringFilter<TRes> get $_max =>
      CopyWith$Input$NestedStringFilter.stub(_res);

  CopyWith$Input$NestedStringFilter<TRes> get $_min =>
      CopyWith$Input$NestedStringFilter.stub(_res);

  CopyWith$Input$NestedStringWithAggregatesFilter<TRes> get not =>
      CopyWith$Input$NestedStringWithAggregatesFilter.stub(_res);
}

class Input$NestedUuidFilter {
  factory Input$NestedUuidFilter({
    String? equals,
    String? gt,
    String? gte,
    List<String>? $in,
    String? lt,
    String? lte,
    Input$NestedUuidFilter? not,
    List<String>? notIn,
  }) =>
      Input$NestedUuidFilter._({
        if (equals != null) r'equals': equals,
        if (gt != null) r'gt': gt,
        if (gte != null) r'gte': gte,
        if ($in != null) r'in': $in,
        if (lt != null) r'lt': lt,
        if (lte != null) r'lte': lte,
        if (not != null) r'not': not,
        if (notIn != null) r'notIn': notIn,
      });

  Input$NestedUuidFilter._(this._$data);

  factory Input$NestedUuidFilter.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('equals')) {
      final l$equals = data['equals'];
      result$data['equals'] = (l$equals as String?);
    }
    if (data.containsKey('gt')) {
      final l$gt = data['gt'];
      result$data['gt'] = (l$gt as String?);
    }
    if (data.containsKey('gte')) {
      final l$gte = data['gte'];
      result$data['gte'] = (l$gte as String?);
    }
    if (data.containsKey('in')) {
      final l$$in = data['in'];
      result$data['in'] =
          (l$$in as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    if (data.containsKey('lt')) {
      final l$lt = data['lt'];
      result$data['lt'] = (l$lt as String?);
    }
    if (data.containsKey('lte')) {
      final l$lte = data['lte'];
      result$data['lte'] = (l$lte as String?);
    }
    if (data.containsKey('not')) {
      final l$not = data['not'];
      result$data['not'] = l$not == null
          ? null
          : Input$NestedUuidFilter.fromJson((l$not as Map<String, dynamic>));
    }
    if (data.containsKey('notIn')) {
      final l$notIn = data['notIn'];
      result$data['notIn'] =
          (l$notIn as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    return Input$NestedUuidFilter._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get equals => (_$data['equals'] as String?);

  String? get gt => (_$data['gt'] as String?);

  String? get gte => (_$data['gte'] as String?);

  List<String>? get $in => (_$data['in'] as List<String>?);

  String? get lt => (_$data['lt'] as String?);

  String? get lte => (_$data['lte'] as String?);

  Input$NestedUuidFilter? get not => (_$data['not'] as Input$NestedUuidFilter?);

  List<String>? get notIn => (_$data['notIn'] as List<String>?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('equals')) {
      final l$equals = equals;
      result$data['equals'] = l$equals;
    }
    if (_$data.containsKey('gt')) {
      final l$gt = gt;
      result$data['gt'] = l$gt;
    }
    if (_$data.containsKey('gte')) {
      final l$gte = gte;
      result$data['gte'] = l$gte;
    }
    if (_$data.containsKey('in')) {
      final l$$in = $in;
      result$data['in'] = l$$in?.map((e) => e).toList();
    }
    if (_$data.containsKey('lt')) {
      final l$lt = lt;
      result$data['lt'] = l$lt;
    }
    if (_$data.containsKey('lte')) {
      final l$lte = lte;
      result$data['lte'] = l$lte;
    }
    if (_$data.containsKey('not')) {
      final l$not = not;
      result$data['not'] = l$not?.toJson();
    }
    if (_$data.containsKey('notIn')) {
      final l$notIn = notIn;
      result$data['notIn'] = l$notIn?.map((e) => e).toList();
    }
    return result$data;
  }

  CopyWith$Input$NestedUuidFilter<Input$NestedUuidFilter> get copyWith =>
      CopyWith$Input$NestedUuidFilter(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$NestedUuidFilter) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$equals = equals;
    final lOther$equals = other.equals;
    if (_$data.containsKey('equals') != other._$data.containsKey('equals')) {
      return false;
    }
    if (l$equals != lOther$equals) {
      return false;
    }
    final l$gt = gt;
    final lOther$gt = other.gt;
    if (_$data.containsKey('gt') != other._$data.containsKey('gt')) {
      return false;
    }
    if (l$gt != lOther$gt) {
      return false;
    }
    final l$gte = gte;
    final lOther$gte = other.gte;
    if (_$data.containsKey('gte') != other._$data.containsKey('gte')) {
      return false;
    }
    if (l$gte != lOther$gte) {
      return false;
    }
    final l$$in = $in;
    final lOther$$in = other.$in;
    if (_$data.containsKey('in') != other._$data.containsKey('in')) {
      return false;
    }
    if (l$$in != null && lOther$$in != null) {
      if (l$$in.length != lOther$$in.length) {
        return false;
      }
      for (int i = 0; i < l$$in.length; i++) {
        final l$$in$entry = l$$in[i];
        final lOther$$in$entry = lOther$$in[i];
        if (l$$in$entry != lOther$$in$entry) {
          return false;
        }
      }
    } else if (l$$in != lOther$$in) {
      return false;
    }
    final l$lt = lt;
    final lOther$lt = other.lt;
    if (_$data.containsKey('lt') != other._$data.containsKey('lt')) {
      return false;
    }
    if (l$lt != lOther$lt) {
      return false;
    }
    final l$lte = lte;
    final lOther$lte = other.lte;
    if (_$data.containsKey('lte') != other._$data.containsKey('lte')) {
      return false;
    }
    if (l$lte != lOther$lte) {
      return false;
    }
    final l$not = not;
    final lOther$not = other.not;
    if (_$data.containsKey('not') != other._$data.containsKey('not')) {
      return false;
    }
    if (l$not != lOther$not) {
      return false;
    }
    final l$notIn = notIn;
    final lOther$notIn = other.notIn;
    if (_$data.containsKey('notIn') != other._$data.containsKey('notIn')) {
      return false;
    }
    if (l$notIn != null && lOther$notIn != null) {
      if (l$notIn.length != lOther$notIn.length) {
        return false;
      }
      for (int i = 0; i < l$notIn.length; i++) {
        final l$notIn$entry = l$notIn[i];
        final lOther$notIn$entry = lOther$notIn[i];
        if (l$notIn$entry != lOther$notIn$entry) {
          return false;
        }
      }
    } else if (l$notIn != lOther$notIn) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$equals = equals;
    final l$gt = gt;
    final l$gte = gte;
    final l$$in = $in;
    final l$lt = lt;
    final l$lte = lte;
    final l$not = not;
    final l$notIn = notIn;
    return Object.hashAll([
      _$data.containsKey('equals') ? l$equals : const {},
      _$data.containsKey('gt') ? l$gt : const {},
      _$data.containsKey('gte') ? l$gte : const {},
      _$data.containsKey('in')
          ? l$$in == null
              ? null
              : Object.hashAll(l$$in.map((v) => v))
          : const {},
      _$data.containsKey('lt') ? l$lt : const {},
      _$data.containsKey('lte') ? l$lte : const {},
      _$data.containsKey('not') ? l$not : const {},
      _$data.containsKey('notIn')
          ? l$notIn == null
              ? null
              : Object.hashAll(l$notIn.map((v) => v))
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$NestedUuidFilter<TRes> {
  factory CopyWith$Input$NestedUuidFilter(
    Input$NestedUuidFilter instance,
    TRes Function(Input$NestedUuidFilter) then,
  ) = _CopyWithImpl$Input$NestedUuidFilter;

  factory CopyWith$Input$NestedUuidFilter.stub(TRes res) =
      _CopyWithStubImpl$Input$NestedUuidFilter;

  TRes call({
    String? equals,
    String? gt,
    String? gte,
    List<String>? $in,
    String? lt,
    String? lte,
    Input$NestedUuidFilter? not,
    List<String>? notIn,
  });
  CopyWith$Input$NestedUuidFilter<TRes> get not;
}

class _CopyWithImpl$Input$NestedUuidFilter<TRes>
    implements CopyWith$Input$NestedUuidFilter<TRes> {
  _CopyWithImpl$Input$NestedUuidFilter(
    this._instance,
    this._then,
  );

  final Input$NestedUuidFilter _instance;

  final TRes Function(Input$NestedUuidFilter) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? equals = _undefined,
    Object? gt = _undefined,
    Object? gte = _undefined,
    Object? $in = _undefined,
    Object? lt = _undefined,
    Object? lte = _undefined,
    Object? not = _undefined,
    Object? notIn = _undefined,
  }) =>
      _then(Input$NestedUuidFilter._({
        ..._instance._$data,
        if (equals != _undefined) 'equals': (equals as String?),
        if (gt != _undefined) 'gt': (gt as String?),
        if (gte != _undefined) 'gte': (gte as String?),
        if ($in != _undefined) 'in': ($in as List<String>?),
        if (lt != _undefined) 'lt': (lt as String?),
        if (lte != _undefined) 'lte': (lte as String?),
        if (not != _undefined) 'not': (not as Input$NestedUuidFilter?),
        if (notIn != _undefined) 'notIn': (notIn as List<String>?),
      }));

  CopyWith$Input$NestedUuidFilter<TRes> get not {
    final local$not = _instance.not;
    return local$not == null
        ? CopyWith$Input$NestedUuidFilter.stub(_then(_instance))
        : CopyWith$Input$NestedUuidFilter(local$not, (e) => call(not: e));
  }
}

class _CopyWithStubImpl$Input$NestedUuidFilter<TRes>
    implements CopyWith$Input$NestedUuidFilter<TRes> {
  _CopyWithStubImpl$Input$NestedUuidFilter(this._res);

  TRes _res;

  call({
    String? equals,
    String? gt,
    String? gte,
    List<String>? $in,
    String? lt,
    String? lte,
    Input$NestedUuidFilter? not,
    List<String>? notIn,
  }) =>
      _res;

  CopyWith$Input$NestedUuidFilter<TRes> get not =>
      CopyWith$Input$NestedUuidFilter.stub(_res);
}

class Input$NestedUuidNullableFilter {
  factory Input$NestedUuidNullableFilter({
    String? equals,
    String? gt,
    String? gte,
    List<String>? $in,
    String? lt,
    String? lte,
    Input$NestedUuidNullableFilter? not,
    List<String>? notIn,
  }) =>
      Input$NestedUuidNullableFilter._({
        if (equals != null) r'equals': equals,
        if (gt != null) r'gt': gt,
        if (gte != null) r'gte': gte,
        if ($in != null) r'in': $in,
        if (lt != null) r'lt': lt,
        if (lte != null) r'lte': lte,
        if (not != null) r'not': not,
        if (notIn != null) r'notIn': notIn,
      });

  Input$NestedUuidNullableFilter._(this._$data);

  factory Input$NestedUuidNullableFilter.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('equals')) {
      final l$equals = data['equals'];
      result$data['equals'] = (l$equals as String?);
    }
    if (data.containsKey('gt')) {
      final l$gt = data['gt'];
      result$data['gt'] = (l$gt as String?);
    }
    if (data.containsKey('gte')) {
      final l$gte = data['gte'];
      result$data['gte'] = (l$gte as String?);
    }
    if (data.containsKey('in')) {
      final l$$in = data['in'];
      result$data['in'] =
          (l$$in as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    if (data.containsKey('lt')) {
      final l$lt = data['lt'];
      result$data['lt'] = (l$lt as String?);
    }
    if (data.containsKey('lte')) {
      final l$lte = data['lte'];
      result$data['lte'] = (l$lte as String?);
    }
    if (data.containsKey('not')) {
      final l$not = data['not'];
      result$data['not'] = l$not == null
          ? null
          : Input$NestedUuidNullableFilter.fromJson(
              (l$not as Map<String, dynamic>));
    }
    if (data.containsKey('notIn')) {
      final l$notIn = data['notIn'];
      result$data['notIn'] =
          (l$notIn as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    return Input$NestedUuidNullableFilter._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get equals => (_$data['equals'] as String?);

  String? get gt => (_$data['gt'] as String?);

  String? get gte => (_$data['gte'] as String?);

  List<String>? get $in => (_$data['in'] as List<String>?);

  String? get lt => (_$data['lt'] as String?);

  String? get lte => (_$data['lte'] as String?);

  Input$NestedUuidNullableFilter? get not =>
      (_$data['not'] as Input$NestedUuidNullableFilter?);

  List<String>? get notIn => (_$data['notIn'] as List<String>?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('equals')) {
      final l$equals = equals;
      result$data['equals'] = l$equals;
    }
    if (_$data.containsKey('gt')) {
      final l$gt = gt;
      result$data['gt'] = l$gt;
    }
    if (_$data.containsKey('gte')) {
      final l$gte = gte;
      result$data['gte'] = l$gte;
    }
    if (_$data.containsKey('in')) {
      final l$$in = $in;
      result$data['in'] = l$$in?.map((e) => e).toList();
    }
    if (_$data.containsKey('lt')) {
      final l$lt = lt;
      result$data['lt'] = l$lt;
    }
    if (_$data.containsKey('lte')) {
      final l$lte = lte;
      result$data['lte'] = l$lte;
    }
    if (_$data.containsKey('not')) {
      final l$not = not;
      result$data['not'] = l$not?.toJson();
    }
    if (_$data.containsKey('notIn')) {
      final l$notIn = notIn;
      result$data['notIn'] = l$notIn?.map((e) => e).toList();
    }
    return result$data;
  }

  CopyWith$Input$NestedUuidNullableFilter<Input$NestedUuidNullableFilter>
      get copyWith => CopyWith$Input$NestedUuidNullableFilter(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$NestedUuidNullableFilter) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$equals = equals;
    final lOther$equals = other.equals;
    if (_$data.containsKey('equals') != other._$data.containsKey('equals')) {
      return false;
    }
    if (l$equals != lOther$equals) {
      return false;
    }
    final l$gt = gt;
    final lOther$gt = other.gt;
    if (_$data.containsKey('gt') != other._$data.containsKey('gt')) {
      return false;
    }
    if (l$gt != lOther$gt) {
      return false;
    }
    final l$gte = gte;
    final lOther$gte = other.gte;
    if (_$data.containsKey('gte') != other._$data.containsKey('gte')) {
      return false;
    }
    if (l$gte != lOther$gte) {
      return false;
    }
    final l$$in = $in;
    final lOther$$in = other.$in;
    if (_$data.containsKey('in') != other._$data.containsKey('in')) {
      return false;
    }
    if (l$$in != null && lOther$$in != null) {
      if (l$$in.length != lOther$$in.length) {
        return false;
      }
      for (int i = 0; i < l$$in.length; i++) {
        final l$$in$entry = l$$in[i];
        final lOther$$in$entry = lOther$$in[i];
        if (l$$in$entry != lOther$$in$entry) {
          return false;
        }
      }
    } else if (l$$in != lOther$$in) {
      return false;
    }
    final l$lt = lt;
    final lOther$lt = other.lt;
    if (_$data.containsKey('lt') != other._$data.containsKey('lt')) {
      return false;
    }
    if (l$lt != lOther$lt) {
      return false;
    }
    final l$lte = lte;
    final lOther$lte = other.lte;
    if (_$data.containsKey('lte') != other._$data.containsKey('lte')) {
      return false;
    }
    if (l$lte != lOther$lte) {
      return false;
    }
    final l$not = not;
    final lOther$not = other.not;
    if (_$data.containsKey('not') != other._$data.containsKey('not')) {
      return false;
    }
    if (l$not != lOther$not) {
      return false;
    }
    final l$notIn = notIn;
    final lOther$notIn = other.notIn;
    if (_$data.containsKey('notIn') != other._$data.containsKey('notIn')) {
      return false;
    }
    if (l$notIn != null && lOther$notIn != null) {
      if (l$notIn.length != lOther$notIn.length) {
        return false;
      }
      for (int i = 0; i < l$notIn.length; i++) {
        final l$notIn$entry = l$notIn[i];
        final lOther$notIn$entry = lOther$notIn[i];
        if (l$notIn$entry != lOther$notIn$entry) {
          return false;
        }
      }
    } else if (l$notIn != lOther$notIn) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$equals = equals;
    final l$gt = gt;
    final l$gte = gte;
    final l$$in = $in;
    final l$lt = lt;
    final l$lte = lte;
    final l$not = not;
    final l$notIn = notIn;
    return Object.hashAll([
      _$data.containsKey('equals') ? l$equals : const {},
      _$data.containsKey('gt') ? l$gt : const {},
      _$data.containsKey('gte') ? l$gte : const {},
      _$data.containsKey('in')
          ? l$$in == null
              ? null
              : Object.hashAll(l$$in.map((v) => v))
          : const {},
      _$data.containsKey('lt') ? l$lt : const {},
      _$data.containsKey('lte') ? l$lte : const {},
      _$data.containsKey('not') ? l$not : const {},
      _$data.containsKey('notIn')
          ? l$notIn == null
              ? null
              : Object.hashAll(l$notIn.map((v) => v))
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$NestedUuidNullableFilter<TRes> {
  factory CopyWith$Input$NestedUuidNullableFilter(
    Input$NestedUuidNullableFilter instance,
    TRes Function(Input$NestedUuidNullableFilter) then,
  ) = _CopyWithImpl$Input$NestedUuidNullableFilter;

  factory CopyWith$Input$NestedUuidNullableFilter.stub(TRes res) =
      _CopyWithStubImpl$Input$NestedUuidNullableFilter;

  TRes call({
    String? equals,
    String? gt,
    String? gte,
    List<String>? $in,
    String? lt,
    String? lte,
    Input$NestedUuidNullableFilter? not,
    List<String>? notIn,
  });
  CopyWith$Input$NestedUuidNullableFilter<TRes> get not;
}

class _CopyWithImpl$Input$NestedUuidNullableFilter<TRes>
    implements CopyWith$Input$NestedUuidNullableFilter<TRes> {
  _CopyWithImpl$Input$NestedUuidNullableFilter(
    this._instance,
    this._then,
  );

  final Input$NestedUuidNullableFilter _instance;

  final TRes Function(Input$NestedUuidNullableFilter) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? equals = _undefined,
    Object? gt = _undefined,
    Object? gte = _undefined,
    Object? $in = _undefined,
    Object? lt = _undefined,
    Object? lte = _undefined,
    Object? not = _undefined,
    Object? notIn = _undefined,
  }) =>
      _then(Input$NestedUuidNullableFilter._({
        ..._instance._$data,
        if (equals != _undefined) 'equals': (equals as String?),
        if (gt != _undefined) 'gt': (gt as String?),
        if (gte != _undefined) 'gte': (gte as String?),
        if ($in != _undefined) 'in': ($in as List<String>?),
        if (lt != _undefined) 'lt': (lt as String?),
        if (lte != _undefined) 'lte': (lte as String?),
        if (not != _undefined) 'not': (not as Input$NestedUuidNullableFilter?),
        if (notIn != _undefined) 'notIn': (notIn as List<String>?),
      }));

  CopyWith$Input$NestedUuidNullableFilter<TRes> get not {
    final local$not = _instance.not;
    return local$not == null
        ? CopyWith$Input$NestedUuidNullableFilter.stub(_then(_instance))
        : CopyWith$Input$NestedUuidNullableFilter(
            local$not, (e) => call(not: e));
  }
}

class _CopyWithStubImpl$Input$NestedUuidNullableFilter<TRes>
    implements CopyWith$Input$NestedUuidNullableFilter<TRes> {
  _CopyWithStubImpl$Input$NestedUuidNullableFilter(this._res);

  TRes _res;

  call({
    String? equals,
    String? gt,
    String? gte,
    List<String>? $in,
    String? lt,
    String? lte,
    Input$NestedUuidNullableFilter? not,
    List<String>? notIn,
  }) =>
      _res;

  CopyWith$Input$NestedUuidNullableFilter<TRes> get not =>
      CopyWith$Input$NestedUuidNullableFilter.stub(_res);
}

class Input$NestedUuidNullableWithAggregatesFilter {
  factory Input$NestedUuidNullableWithAggregatesFilter({
    Input$NestedIntNullableFilter? $_count,
    Input$NestedStringNullableFilter? $_max,
    Input$NestedStringNullableFilter? $_min,
    String? equals,
    String? gt,
    String? gte,
    List<String>? $in,
    String? lt,
    String? lte,
    Input$NestedUuidNullableWithAggregatesFilter? not,
    List<String>? notIn,
  }) =>
      Input$NestedUuidNullableWithAggregatesFilter._({
        if ($_count != null) r'_count': $_count,
        if ($_max != null) r'_max': $_max,
        if ($_min != null) r'_min': $_min,
        if (equals != null) r'equals': equals,
        if (gt != null) r'gt': gt,
        if (gte != null) r'gte': gte,
        if ($in != null) r'in': $in,
        if (lt != null) r'lt': lt,
        if (lte != null) r'lte': lte,
        if (not != null) r'not': not,
        if (notIn != null) r'notIn': notIn,
      });

  Input$NestedUuidNullableWithAggregatesFilter._(this._$data);

  factory Input$NestedUuidNullableWithAggregatesFilter.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('_count')) {
      final l$$_count = data['_count'];
      result$data['_count'] = l$$_count == null
          ? null
          : Input$NestedIntNullableFilter.fromJson(
              (l$$_count as Map<String, dynamic>));
    }
    if (data.containsKey('_max')) {
      final l$$_max = data['_max'];
      result$data['_max'] = l$$_max == null
          ? null
          : Input$NestedStringNullableFilter.fromJson(
              (l$$_max as Map<String, dynamic>));
    }
    if (data.containsKey('_min')) {
      final l$$_min = data['_min'];
      result$data['_min'] = l$$_min == null
          ? null
          : Input$NestedStringNullableFilter.fromJson(
              (l$$_min as Map<String, dynamic>));
    }
    if (data.containsKey('equals')) {
      final l$equals = data['equals'];
      result$data['equals'] = (l$equals as String?);
    }
    if (data.containsKey('gt')) {
      final l$gt = data['gt'];
      result$data['gt'] = (l$gt as String?);
    }
    if (data.containsKey('gte')) {
      final l$gte = data['gte'];
      result$data['gte'] = (l$gte as String?);
    }
    if (data.containsKey('in')) {
      final l$$in = data['in'];
      result$data['in'] =
          (l$$in as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    if (data.containsKey('lt')) {
      final l$lt = data['lt'];
      result$data['lt'] = (l$lt as String?);
    }
    if (data.containsKey('lte')) {
      final l$lte = data['lte'];
      result$data['lte'] = (l$lte as String?);
    }
    if (data.containsKey('not')) {
      final l$not = data['not'];
      result$data['not'] = l$not == null
          ? null
          : Input$NestedUuidNullableWithAggregatesFilter.fromJson(
              (l$not as Map<String, dynamic>));
    }
    if (data.containsKey('notIn')) {
      final l$notIn = data['notIn'];
      result$data['notIn'] =
          (l$notIn as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    return Input$NestedUuidNullableWithAggregatesFilter._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$NestedIntNullableFilter? get $_count =>
      (_$data['_count'] as Input$NestedIntNullableFilter?);

  Input$NestedStringNullableFilter? get $_max =>
      (_$data['_max'] as Input$NestedStringNullableFilter?);

  Input$NestedStringNullableFilter? get $_min =>
      (_$data['_min'] as Input$NestedStringNullableFilter?);

  String? get equals => (_$data['equals'] as String?);

  String? get gt => (_$data['gt'] as String?);

  String? get gte => (_$data['gte'] as String?);

  List<String>? get $in => (_$data['in'] as List<String>?);

  String? get lt => (_$data['lt'] as String?);

  String? get lte => (_$data['lte'] as String?);

  Input$NestedUuidNullableWithAggregatesFilter? get not =>
      (_$data['not'] as Input$NestedUuidNullableWithAggregatesFilter?);

  List<String>? get notIn => (_$data['notIn'] as List<String>?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('_count')) {
      final l$$_count = $_count;
      result$data['_count'] = l$$_count?.toJson();
    }
    if (_$data.containsKey('_max')) {
      final l$$_max = $_max;
      result$data['_max'] = l$$_max?.toJson();
    }
    if (_$data.containsKey('_min')) {
      final l$$_min = $_min;
      result$data['_min'] = l$$_min?.toJson();
    }
    if (_$data.containsKey('equals')) {
      final l$equals = equals;
      result$data['equals'] = l$equals;
    }
    if (_$data.containsKey('gt')) {
      final l$gt = gt;
      result$data['gt'] = l$gt;
    }
    if (_$data.containsKey('gte')) {
      final l$gte = gte;
      result$data['gte'] = l$gte;
    }
    if (_$data.containsKey('in')) {
      final l$$in = $in;
      result$data['in'] = l$$in?.map((e) => e).toList();
    }
    if (_$data.containsKey('lt')) {
      final l$lt = lt;
      result$data['lt'] = l$lt;
    }
    if (_$data.containsKey('lte')) {
      final l$lte = lte;
      result$data['lte'] = l$lte;
    }
    if (_$data.containsKey('not')) {
      final l$not = not;
      result$data['not'] = l$not?.toJson();
    }
    if (_$data.containsKey('notIn')) {
      final l$notIn = notIn;
      result$data['notIn'] = l$notIn?.map((e) => e).toList();
    }
    return result$data;
  }

  CopyWith$Input$NestedUuidNullableWithAggregatesFilter<
          Input$NestedUuidNullableWithAggregatesFilter>
      get copyWith => CopyWith$Input$NestedUuidNullableWithAggregatesFilter(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$NestedUuidNullableWithAggregatesFilter) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$$_count = $_count;
    final lOther$$_count = other.$_count;
    if (_$data.containsKey('_count') != other._$data.containsKey('_count')) {
      return false;
    }
    if (l$$_count != lOther$$_count) {
      return false;
    }
    final l$$_max = $_max;
    final lOther$$_max = other.$_max;
    if (_$data.containsKey('_max') != other._$data.containsKey('_max')) {
      return false;
    }
    if (l$$_max != lOther$$_max) {
      return false;
    }
    final l$$_min = $_min;
    final lOther$$_min = other.$_min;
    if (_$data.containsKey('_min') != other._$data.containsKey('_min')) {
      return false;
    }
    if (l$$_min != lOther$$_min) {
      return false;
    }
    final l$equals = equals;
    final lOther$equals = other.equals;
    if (_$data.containsKey('equals') != other._$data.containsKey('equals')) {
      return false;
    }
    if (l$equals != lOther$equals) {
      return false;
    }
    final l$gt = gt;
    final lOther$gt = other.gt;
    if (_$data.containsKey('gt') != other._$data.containsKey('gt')) {
      return false;
    }
    if (l$gt != lOther$gt) {
      return false;
    }
    final l$gte = gte;
    final lOther$gte = other.gte;
    if (_$data.containsKey('gte') != other._$data.containsKey('gte')) {
      return false;
    }
    if (l$gte != lOther$gte) {
      return false;
    }
    final l$$in = $in;
    final lOther$$in = other.$in;
    if (_$data.containsKey('in') != other._$data.containsKey('in')) {
      return false;
    }
    if (l$$in != null && lOther$$in != null) {
      if (l$$in.length != lOther$$in.length) {
        return false;
      }
      for (int i = 0; i < l$$in.length; i++) {
        final l$$in$entry = l$$in[i];
        final lOther$$in$entry = lOther$$in[i];
        if (l$$in$entry != lOther$$in$entry) {
          return false;
        }
      }
    } else if (l$$in != lOther$$in) {
      return false;
    }
    final l$lt = lt;
    final lOther$lt = other.lt;
    if (_$data.containsKey('lt') != other._$data.containsKey('lt')) {
      return false;
    }
    if (l$lt != lOther$lt) {
      return false;
    }
    final l$lte = lte;
    final lOther$lte = other.lte;
    if (_$data.containsKey('lte') != other._$data.containsKey('lte')) {
      return false;
    }
    if (l$lte != lOther$lte) {
      return false;
    }
    final l$not = not;
    final lOther$not = other.not;
    if (_$data.containsKey('not') != other._$data.containsKey('not')) {
      return false;
    }
    if (l$not != lOther$not) {
      return false;
    }
    final l$notIn = notIn;
    final lOther$notIn = other.notIn;
    if (_$data.containsKey('notIn') != other._$data.containsKey('notIn')) {
      return false;
    }
    if (l$notIn != null && lOther$notIn != null) {
      if (l$notIn.length != lOther$notIn.length) {
        return false;
      }
      for (int i = 0; i < l$notIn.length; i++) {
        final l$notIn$entry = l$notIn[i];
        final lOther$notIn$entry = lOther$notIn[i];
        if (l$notIn$entry != lOther$notIn$entry) {
          return false;
        }
      }
    } else if (l$notIn != lOther$notIn) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$$_count = $_count;
    final l$$_max = $_max;
    final l$$_min = $_min;
    final l$equals = equals;
    final l$gt = gt;
    final l$gte = gte;
    final l$$in = $in;
    final l$lt = lt;
    final l$lte = lte;
    final l$not = not;
    final l$notIn = notIn;
    return Object.hashAll([
      _$data.containsKey('_count') ? l$$_count : const {},
      _$data.containsKey('_max') ? l$$_max : const {},
      _$data.containsKey('_min') ? l$$_min : const {},
      _$data.containsKey('equals') ? l$equals : const {},
      _$data.containsKey('gt') ? l$gt : const {},
      _$data.containsKey('gte') ? l$gte : const {},
      _$data.containsKey('in')
          ? l$$in == null
              ? null
              : Object.hashAll(l$$in.map((v) => v))
          : const {},
      _$data.containsKey('lt') ? l$lt : const {},
      _$data.containsKey('lte') ? l$lte : const {},
      _$data.containsKey('not') ? l$not : const {},
      _$data.containsKey('notIn')
          ? l$notIn == null
              ? null
              : Object.hashAll(l$notIn.map((v) => v))
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$NestedUuidNullableWithAggregatesFilter<TRes> {
  factory CopyWith$Input$NestedUuidNullableWithAggregatesFilter(
    Input$NestedUuidNullableWithAggregatesFilter instance,
    TRes Function(Input$NestedUuidNullableWithAggregatesFilter) then,
  ) = _CopyWithImpl$Input$NestedUuidNullableWithAggregatesFilter;

  factory CopyWith$Input$NestedUuidNullableWithAggregatesFilter.stub(TRes res) =
      _CopyWithStubImpl$Input$NestedUuidNullableWithAggregatesFilter;

  TRes call({
    Input$NestedIntNullableFilter? $_count,
    Input$NestedStringNullableFilter? $_max,
    Input$NestedStringNullableFilter? $_min,
    String? equals,
    String? gt,
    String? gte,
    List<String>? $in,
    String? lt,
    String? lte,
    Input$NestedUuidNullableWithAggregatesFilter? not,
    List<String>? notIn,
  });
  CopyWith$Input$NestedIntNullableFilter<TRes> get $_count;
  CopyWith$Input$NestedStringNullableFilter<TRes> get $_max;
  CopyWith$Input$NestedStringNullableFilter<TRes> get $_min;
  CopyWith$Input$NestedUuidNullableWithAggregatesFilter<TRes> get not;
}

class _CopyWithImpl$Input$NestedUuidNullableWithAggregatesFilter<TRes>
    implements CopyWith$Input$NestedUuidNullableWithAggregatesFilter<TRes> {
  _CopyWithImpl$Input$NestedUuidNullableWithAggregatesFilter(
    this._instance,
    this._then,
  );

  final Input$NestedUuidNullableWithAggregatesFilter _instance;

  final TRes Function(Input$NestedUuidNullableWithAggregatesFilter) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? $_count = _undefined,
    Object? $_max = _undefined,
    Object? $_min = _undefined,
    Object? equals = _undefined,
    Object? gt = _undefined,
    Object? gte = _undefined,
    Object? $in = _undefined,
    Object? lt = _undefined,
    Object? lte = _undefined,
    Object? not = _undefined,
    Object? notIn = _undefined,
  }) =>
      _then(Input$NestedUuidNullableWithAggregatesFilter._({
        ..._instance._$data,
        if ($_count != _undefined)
          '_count': ($_count as Input$NestedIntNullableFilter?),
        if ($_max != _undefined)
          '_max': ($_max as Input$NestedStringNullableFilter?),
        if ($_min != _undefined)
          '_min': ($_min as Input$NestedStringNullableFilter?),
        if (equals != _undefined) 'equals': (equals as String?),
        if (gt != _undefined) 'gt': (gt as String?),
        if (gte != _undefined) 'gte': (gte as String?),
        if ($in != _undefined) 'in': ($in as List<String>?),
        if (lt != _undefined) 'lt': (lt as String?),
        if (lte != _undefined) 'lte': (lte as String?),
        if (not != _undefined)
          'not': (not as Input$NestedUuidNullableWithAggregatesFilter?),
        if (notIn != _undefined) 'notIn': (notIn as List<String>?),
      }));

  CopyWith$Input$NestedIntNullableFilter<TRes> get $_count {
    final local$$_count = _instance.$_count;
    return local$$_count == null
        ? CopyWith$Input$NestedIntNullableFilter.stub(_then(_instance))
        : CopyWith$Input$NestedIntNullableFilter(
            local$$_count, (e) => call($_count: e));
  }

  CopyWith$Input$NestedStringNullableFilter<TRes> get $_max {
    final local$$_max = _instance.$_max;
    return local$$_max == null
        ? CopyWith$Input$NestedStringNullableFilter.stub(_then(_instance))
        : CopyWith$Input$NestedStringNullableFilter(
            local$$_max, (e) => call($_max: e));
  }

  CopyWith$Input$NestedStringNullableFilter<TRes> get $_min {
    final local$$_min = _instance.$_min;
    return local$$_min == null
        ? CopyWith$Input$NestedStringNullableFilter.stub(_then(_instance))
        : CopyWith$Input$NestedStringNullableFilter(
            local$$_min, (e) => call($_min: e));
  }

  CopyWith$Input$NestedUuidNullableWithAggregatesFilter<TRes> get not {
    final local$not = _instance.not;
    return local$not == null
        ? CopyWith$Input$NestedUuidNullableWithAggregatesFilter.stub(
            _then(_instance))
        : CopyWith$Input$NestedUuidNullableWithAggregatesFilter(
            local$not, (e) => call(not: e));
  }
}

class _CopyWithStubImpl$Input$NestedUuidNullableWithAggregatesFilter<TRes>
    implements CopyWith$Input$NestedUuidNullableWithAggregatesFilter<TRes> {
  _CopyWithStubImpl$Input$NestedUuidNullableWithAggregatesFilter(this._res);

  TRes _res;

  call({
    Input$NestedIntNullableFilter? $_count,
    Input$NestedStringNullableFilter? $_max,
    Input$NestedStringNullableFilter? $_min,
    String? equals,
    String? gt,
    String? gte,
    List<String>? $in,
    String? lt,
    String? lte,
    Input$NestedUuidNullableWithAggregatesFilter? not,
    List<String>? notIn,
  }) =>
      _res;

  CopyWith$Input$NestedIntNullableFilter<TRes> get $_count =>
      CopyWith$Input$NestedIntNullableFilter.stub(_res);

  CopyWith$Input$NestedStringNullableFilter<TRes> get $_max =>
      CopyWith$Input$NestedStringNullableFilter.stub(_res);

  CopyWith$Input$NestedStringNullableFilter<TRes> get $_min =>
      CopyWith$Input$NestedStringNullableFilter.stub(_res);

  CopyWith$Input$NestedUuidNullableWithAggregatesFilter<TRes> get not =>
      CopyWith$Input$NestedUuidNullableWithAggregatesFilter.stub(_res);
}

class Input$NestedUuidWithAggregatesFilter {
  factory Input$NestedUuidWithAggregatesFilter({
    Input$NestedIntFilter? $_count,
    Input$NestedStringFilter? $_max,
    Input$NestedStringFilter? $_min,
    String? equals,
    String? gt,
    String? gte,
    List<String>? $in,
    String? lt,
    String? lte,
    Input$NestedUuidWithAggregatesFilter? not,
    List<String>? notIn,
  }) =>
      Input$NestedUuidWithAggregatesFilter._({
        if ($_count != null) r'_count': $_count,
        if ($_max != null) r'_max': $_max,
        if ($_min != null) r'_min': $_min,
        if (equals != null) r'equals': equals,
        if (gt != null) r'gt': gt,
        if (gte != null) r'gte': gte,
        if ($in != null) r'in': $in,
        if (lt != null) r'lt': lt,
        if (lte != null) r'lte': lte,
        if (not != null) r'not': not,
        if (notIn != null) r'notIn': notIn,
      });

  Input$NestedUuidWithAggregatesFilter._(this._$data);

  factory Input$NestedUuidWithAggregatesFilter.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('_count')) {
      final l$$_count = data['_count'];
      result$data['_count'] = l$$_count == null
          ? null
          : Input$NestedIntFilter.fromJson((l$$_count as Map<String, dynamic>));
    }
    if (data.containsKey('_max')) {
      final l$$_max = data['_max'];
      result$data['_max'] = l$$_max == null
          ? null
          : Input$NestedStringFilter.fromJson(
              (l$$_max as Map<String, dynamic>));
    }
    if (data.containsKey('_min')) {
      final l$$_min = data['_min'];
      result$data['_min'] = l$$_min == null
          ? null
          : Input$NestedStringFilter.fromJson(
              (l$$_min as Map<String, dynamic>));
    }
    if (data.containsKey('equals')) {
      final l$equals = data['equals'];
      result$data['equals'] = (l$equals as String?);
    }
    if (data.containsKey('gt')) {
      final l$gt = data['gt'];
      result$data['gt'] = (l$gt as String?);
    }
    if (data.containsKey('gte')) {
      final l$gte = data['gte'];
      result$data['gte'] = (l$gte as String?);
    }
    if (data.containsKey('in')) {
      final l$$in = data['in'];
      result$data['in'] =
          (l$$in as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    if (data.containsKey('lt')) {
      final l$lt = data['lt'];
      result$data['lt'] = (l$lt as String?);
    }
    if (data.containsKey('lte')) {
      final l$lte = data['lte'];
      result$data['lte'] = (l$lte as String?);
    }
    if (data.containsKey('not')) {
      final l$not = data['not'];
      result$data['not'] = l$not == null
          ? null
          : Input$NestedUuidWithAggregatesFilter.fromJson(
              (l$not as Map<String, dynamic>));
    }
    if (data.containsKey('notIn')) {
      final l$notIn = data['notIn'];
      result$data['notIn'] =
          (l$notIn as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    return Input$NestedUuidWithAggregatesFilter._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$NestedIntFilter? get $_count =>
      (_$data['_count'] as Input$NestedIntFilter?);

  Input$NestedStringFilter? get $_max =>
      (_$data['_max'] as Input$NestedStringFilter?);

  Input$NestedStringFilter? get $_min =>
      (_$data['_min'] as Input$NestedStringFilter?);

  String? get equals => (_$data['equals'] as String?);

  String? get gt => (_$data['gt'] as String?);

  String? get gte => (_$data['gte'] as String?);

  List<String>? get $in => (_$data['in'] as List<String>?);

  String? get lt => (_$data['lt'] as String?);

  String? get lte => (_$data['lte'] as String?);

  Input$NestedUuidWithAggregatesFilter? get not =>
      (_$data['not'] as Input$NestedUuidWithAggregatesFilter?);

  List<String>? get notIn => (_$data['notIn'] as List<String>?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('_count')) {
      final l$$_count = $_count;
      result$data['_count'] = l$$_count?.toJson();
    }
    if (_$data.containsKey('_max')) {
      final l$$_max = $_max;
      result$data['_max'] = l$$_max?.toJson();
    }
    if (_$data.containsKey('_min')) {
      final l$$_min = $_min;
      result$data['_min'] = l$$_min?.toJson();
    }
    if (_$data.containsKey('equals')) {
      final l$equals = equals;
      result$data['equals'] = l$equals;
    }
    if (_$data.containsKey('gt')) {
      final l$gt = gt;
      result$data['gt'] = l$gt;
    }
    if (_$data.containsKey('gte')) {
      final l$gte = gte;
      result$data['gte'] = l$gte;
    }
    if (_$data.containsKey('in')) {
      final l$$in = $in;
      result$data['in'] = l$$in?.map((e) => e).toList();
    }
    if (_$data.containsKey('lt')) {
      final l$lt = lt;
      result$data['lt'] = l$lt;
    }
    if (_$data.containsKey('lte')) {
      final l$lte = lte;
      result$data['lte'] = l$lte;
    }
    if (_$data.containsKey('not')) {
      final l$not = not;
      result$data['not'] = l$not?.toJson();
    }
    if (_$data.containsKey('notIn')) {
      final l$notIn = notIn;
      result$data['notIn'] = l$notIn?.map((e) => e).toList();
    }
    return result$data;
  }

  CopyWith$Input$NestedUuidWithAggregatesFilter<
          Input$NestedUuidWithAggregatesFilter>
      get copyWith => CopyWith$Input$NestedUuidWithAggregatesFilter(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$NestedUuidWithAggregatesFilter) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$$_count = $_count;
    final lOther$$_count = other.$_count;
    if (_$data.containsKey('_count') != other._$data.containsKey('_count')) {
      return false;
    }
    if (l$$_count != lOther$$_count) {
      return false;
    }
    final l$$_max = $_max;
    final lOther$$_max = other.$_max;
    if (_$data.containsKey('_max') != other._$data.containsKey('_max')) {
      return false;
    }
    if (l$$_max != lOther$$_max) {
      return false;
    }
    final l$$_min = $_min;
    final lOther$$_min = other.$_min;
    if (_$data.containsKey('_min') != other._$data.containsKey('_min')) {
      return false;
    }
    if (l$$_min != lOther$$_min) {
      return false;
    }
    final l$equals = equals;
    final lOther$equals = other.equals;
    if (_$data.containsKey('equals') != other._$data.containsKey('equals')) {
      return false;
    }
    if (l$equals != lOther$equals) {
      return false;
    }
    final l$gt = gt;
    final lOther$gt = other.gt;
    if (_$data.containsKey('gt') != other._$data.containsKey('gt')) {
      return false;
    }
    if (l$gt != lOther$gt) {
      return false;
    }
    final l$gte = gte;
    final lOther$gte = other.gte;
    if (_$data.containsKey('gte') != other._$data.containsKey('gte')) {
      return false;
    }
    if (l$gte != lOther$gte) {
      return false;
    }
    final l$$in = $in;
    final lOther$$in = other.$in;
    if (_$data.containsKey('in') != other._$data.containsKey('in')) {
      return false;
    }
    if (l$$in != null && lOther$$in != null) {
      if (l$$in.length != lOther$$in.length) {
        return false;
      }
      for (int i = 0; i < l$$in.length; i++) {
        final l$$in$entry = l$$in[i];
        final lOther$$in$entry = lOther$$in[i];
        if (l$$in$entry != lOther$$in$entry) {
          return false;
        }
      }
    } else if (l$$in != lOther$$in) {
      return false;
    }
    final l$lt = lt;
    final lOther$lt = other.lt;
    if (_$data.containsKey('lt') != other._$data.containsKey('lt')) {
      return false;
    }
    if (l$lt != lOther$lt) {
      return false;
    }
    final l$lte = lte;
    final lOther$lte = other.lte;
    if (_$data.containsKey('lte') != other._$data.containsKey('lte')) {
      return false;
    }
    if (l$lte != lOther$lte) {
      return false;
    }
    final l$not = not;
    final lOther$not = other.not;
    if (_$data.containsKey('not') != other._$data.containsKey('not')) {
      return false;
    }
    if (l$not != lOther$not) {
      return false;
    }
    final l$notIn = notIn;
    final lOther$notIn = other.notIn;
    if (_$data.containsKey('notIn') != other._$data.containsKey('notIn')) {
      return false;
    }
    if (l$notIn != null && lOther$notIn != null) {
      if (l$notIn.length != lOther$notIn.length) {
        return false;
      }
      for (int i = 0; i < l$notIn.length; i++) {
        final l$notIn$entry = l$notIn[i];
        final lOther$notIn$entry = lOther$notIn[i];
        if (l$notIn$entry != lOther$notIn$entry) {
          return false;
        }
      }
    } else if (l$notIn != lOther$notIn) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$$_count = $_count;
    final l$$_max = $_max;
    final l$$_min = $_min;
    final l$equals = equals;
    final l$gt = gt;
    final l$gte = gte;
    final l$$in = $in;
    final l$lt = lt;
    final l$lte = lte;
    final l$not = not;
    final l$notIn = notIn;
    return Object.hashAll([
      _$data.containsKey('_count') ? l$$_count : const {},
      _$data.containsKey('_max') ? l$$_max : const {},
      _$data.containsKey('_min') ? l$$_min : const {},
      _$data.containsKey('equals') ? l$equals : const {},
      _$data.containsKey('gt') ? l$gt : const {},
      _$data.containsKey('gte') ? l$gte : const {},
      _$data.containsKey('in')
          ? l$$in == null
              ? null
              : Object.hashAll(l$$in.map((v) => v))
          : const {},
      _$data.containsKey('lt') ? l$lt : const {},
      _$data.containsKey('lte') ? l$lte : const {},
      _$data.containsKey('not') ? l$not : const {},
      _$data.containsKey('notIn')
          ? l$notIn == null
              ? null
              : Object.hashAll(l$notIn.map((v) => v))
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$NestedUuidWithAggregatesFilter<TRes> {
  factory CopyWith$Input$NestedUuidWithAggregatesFilter(
    Input$NestedUuidWithAggregatesFilter instance,
    TRes Function(Input$NestedUuidWithAggregatesFilter) then,
  ) = _CopyWithImpl$Input$NestedUuidWithAggregatesFilter;

  factory CopyWith$Input$NestedUuidWithAggregatesFilter.stub(TRes res) =
      _CopyWithStubImpl$Input$NestedUuidWithAggregatesFilter;

  TRes call({
    Input$NestedIntFilter? $_count,
    Input$NestedStringFilter? $_max,
    Input$NestedStringFilter? $_min,
    String? equals,
    String? gt,
    String? gte,
    List<String>? $in,
    String? lt,
    String? lte,
    Input$NestedUuidWithAggregatesFilter? not,
    List<String>? notIn,
  });
  CopyWith$Input$NestedIntFilter<TRes> get $_count;
  CopyWith$Input$NestedStringFilter<TRes> get $_max;
  CopyWith$Input$NestedStringFilter<TRes> get $_min;
  CopyWith$Input$NestedUuidWithAggregatesFilter<TRes> get not;
}

class _CopyWithImpl$Input$NestedUuidWithAggregatesFilter<TRes>
    implements CopyWith$Input$NestedUuidWithAggregatesFilter<TRes> {
  _CopyWithImpl$Input$NestedUuidWithAggregatesFilter(
    this._instance,
    this._then,
  );

  final Input$NestedUuidWithAggregatesFilter _instance;

  final TRes Function(Input$NestedUuidWithAggregatesFilter) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? $_count = _undefined,
    Object? $_max = _undefined,
    Object? $_min = _undefined,
    Object? equals = _undefined,
    Object? gt = _undefined,
    Object? gte = _undefined,
    Object? $in = _undefined,
    Object? lt = _undefined,
    Object? lte = _undefined,
    Object? not = _undefined,
    Object? notIn = _undefined,
  }) =>
      _then(Input$NestedUuidWithAggregatesFilter._({
        ..._instance._$data,
        if ($_count != _undefined)
          '_count': ($_count as Input$NestedIntFilter?),
        if ($_max != _undefined) '_max': ($_max as Input$NestedStringFilter?),
        if ($_min != _undefined) '_min': ($_min as Input$NestedStringFilter?),
        if (equals != _undefined) 'equals': (equals as String?),
        if (gt != _undefined) 'gt': (gt as String?),
        if (gte != _undefined) 'gte': (gte as String?),
        if ($in != _undefined) 'in': ($in as List<String>?),
        if (lt != _undefined) 'lt': (lt as String?),
        if (lte != _undefined) 'lte': (lte as String?),
        if (not != _undefined)
          'not': (not as Input$NestedUuidWithAggregatesFilter?),
        if (notIn != _undefined) 'notIn': (notIn as List<String>?),
      }));

  CopyWith$Input$NestedIntFilter<TRes> get $_count {
    final local$$_count = _instance.$_count;
    return local$$_count == null
        ? CopyWith$Input$NestedIntFilter.stub(_then(_instance))
        : CopyWith$Input$NestedIntFilter(
            local$$_count, (e) => call($_count: e));
  }

  CopyWith$Input$NestedStringFilter<TRes> get $_max {
    final local$$_max = _instance.$_max;
    return local$$_max == null
        ? CopyWith$Input$NestedStringFilter.stub(_then(_instance))
        : CopyWith$Input$NestedStringFilter(local$$_max, (e) => call($_max: e));
  }

  CopyWith$Input$NestedStringFilter<TRes> get $_min {
    final local$$_min = _instance.$_min;
    return local$$_min == null
        ? CopyWith$Input$NestedStringFilter.stub(_then(_instance))
        : CopyWith$Input$NestedStringFilter(local$$_min, (e) => call($_min: e));
  }

  CopyWith$Input$NestedUuidWithAggregatesFilter<TRes> get not {
    final local$not = _instance.not;
    return local$not == null
        ? CopyWith$Input$NestedUuidWithAggregatesFilter.stub(_then(_instance))
        : CopyWith$Input$NestedUuidWithAggregatesFilter(
            local$not, (e) => call(not: e));
  }
}

class _CopyWithStubImpl$Input$NestedUuidWithAggregatesFilter<TRes>
    implements CopyWith$Input$NestedUuidWithAggregatesFilter<TRes> {
  _CopyWithStubImpl$Input$NestedUuidWithAggregatesFilter(this._res);

  TRes _res;

  call({
    Input$NestedIntFilter? $_count,
    Input$NestedStringFilter? $_max,
    Input$NestedStringFilter? $_min,
    String? equals,
    String? gt,
    String? gte,
    List<String>? $in,
    String? lt,
    String? lte,
    Input$NestedUuidWithAggregatesFilter? not,
    List<String>? notIn,
  }) =>
      _res;

  CopyWith$Input$NestedIntFilter<TRes> get $_count =>
      CopyWith$Input$NestedIntFilter.stub(_res);

  CopyWith$Input$NestedStringFilter<TRes> get $_max =>
      CopyWith$Input$NestedStringFilter.stub(_res);

  CopyWith$Input$NestedStringFilter<TRes> get $_min =>
      CopyWith$Input$NestedStringFilter.stub(_res);

  CopyWith$Input$NestedUuidWithAggregatesFilter<TRes> get not =>
      CopyWith$Input$NestedUuidWithAggregatesFilter.stub(_res);
}

class Input$NullableIntFieldUpdateOperationsInput {
  factory Input$NullableIntFieldUpdateOperationsInput({
    int? decrement,
    int? divide,
    int? increment,
    int? multiply,
    int? $set,
  }) =>
      Input$NullableIntFieldUpdateOperationsInput._({
        if (decrement != null) r'decrement': decrement,
        if (divide != null) r'divide': divide,
        if (increment != null) r'increment': increment,
        if (multiply != null) r'multiply': multiply,
        if ($set != null) r'set': $set,
      });

  Input$NullableIntFieldUpdateOperationsInput._(this._$data);

  factory Input$NullableIntFieldUpdateOperationsInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('decrement')) {
      final l$decrement = data['decrement'];
      result$data['decrement'] = (l$decrement as int?);
    }
    if (data.containsKey('divide')) {
      final l$divide = data['divide'];
      result$data['divide'] = (l$divide as int?);
    }
    if (data.containsKey('increment')) {
      final l$increment = data['increment'];
      result$data['increment'] = (l$increment as int?);
    }
    if (data.containsKey('multiply')) {
      final l$multiply = data['multiply'];
      result$data['multiply'] = (l$multiply as int?);
    }
    if (data.containsKey('set')) {
      final l$$set = data['set'];
      result$data['set'] = (l$$set as int?);
    }
    return Input$NullableIntFieldUpdateOperationsInput._(result$data);
  }

  Map<String, dynamic> _$data;

  int? get decrement => (_$data['decrement'] as int?);

  int? get divide => (_$data['divide'] as int?);

  int? get increment => (_$data['increment'] as int?);

  int? get multiply => (_$data['multiply'] as int?);

  int? get $set => (_$data['set'] as int?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('decrement')) {
      final l$decrement = decrement;
      result$data['decrement'] = l$decrement;
    }
    if (_$data.containsKey('divide')) {
      final l$divide = divide;
      result$data['divide'] = l$divide;
    }
    if (_$data.containsKey('increment')) {
      final l$increment = increment;
      result$data['increment'] = l$increment;
    }
    if (_$data.containsKey('multiply')) {
      final l$multiply = multiply;
      result$data['multiply'] = l$multiply;
    }
    if (_$data.containsKey('set')) {
      final l$$set = $set;
      result$data['set'] = l$$set;
    }
    return result$data;
  }

  CopyWith$Input$NullableIntFieldUpdateOperationsInput<
          Input$NullableIntFieldUpdateOperationsInput>
      get copyWith => CopyWith$Input$NullableIntFieldUpdateOperationsInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$NullableIntFieldUpdateOperationsInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$decrement = decrement;
    final lOther$decrement = other.decrement;
    if (_$data.containsKey('decrement') !=
        other._$data.containsKey('decrement')) {
      return false;
    }
    if (l$decrement != lOther$decrement) {
      return false;
    }
    final l$divide = divide;
    final lOther$divide = other.divide;
    if (_$data.containsKey('divide') != other._$data.containsKey('divide')) {
      return false;
    }
    if (l$divide != lOther$divide) {
      return false;
    }
    final l$increment = increment;
    final lOther$increment = other.increment;
    if (_$data.containsKey('increment') !=
        other._$data.containsKey('increment')) {
      return false;
    }
    if (l$increment != lOther$increment) {
      return false;
    }
    final l$multiply = multiply;
    final lOther$multiply = other.multiply;
    if (_$data.containsKey('multiply') !=
        other._$data.containsKey('multiply')) {
      return false;
    }
    if (l$multiply != lOther$multiply) {
      return false;
    }
    final l$$set = $set;
    final lOther$$set = other.$set;
    if (_$data.containsKey('set') != other._$data.containsKey('set')) {
      return false;
    }
    if (l$$set != lOther$$set) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$decrement = decrement;
    final l$divide = divide;
    final l$increment = increment;
    final l$multiply = multiply;
    final l$$set = $set;
    return Object.hashAll([
      _$data.containsKey('decrement') ? l$decrement : const {},
      _$data.containsKey('divide') ? l$divide : const {},
      _$data.containsKey('increment') ? l$increment : const {},
      _$data.containsKey('multiply') ? l$multiply : const {},
      _$data.containsKey('set') ? l$$set : const {},
    ]);
  }
}

abstract class CopyWith$Input$NullableIntFieldUpdateOperationsInput<TRes> {
  factory CopyWith$Input$NullableIntFieldUpdateOperationsInput(
    Input$NullableIntFieldUpdateOperationsInput instance,
    TRes Function(Input$NullableIntFieldUpdateOperationsInput) then,
  ) = _CopyWithImpl$Input$NullableIntFieldUpdateOperationsInput;

  factory CopyWith$Input$NullableIntFieldUpdateOperationsInput.stub(TRes res) =
      _CopyWithStubImpl$Input$NullableIntFieldUpdateOperationsInput;

  TRes call({
    int? decrement,
    int? divide,
    int? increment,
    int? multiply,
    int? $set,
  });
}

class _CopyWithImpl$Input$NullableIntFieldUpdateOperationsInput<TRes>
    implements CopyWith$Input$NullableIntFieldUpdateOperationsInput<TRes> {
  _CopyWithImpl$Input$NullableIntFieldUpdateOperationsInput(
    this._instance,
    this._then,
  );

  final Input$NullableIntFieldUpdateOperationsInput _instance;

  final TRes Function(Input$NullableIntFieldUpdateOperationsInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? decrement = _undefined,
    Object? divide = _undefined,
    Object? increment = _undefined,
    Object? multiply = _undefined,
    Object? $set = _undefined,
  }) =>
      _then(Input$NullableIntFieldUpdateOperationsInput._({
        ..._instance._$data,
        if (decrement != _undefined) 'decrement': (decrement as int?),
        if (divide != _undefined) 'divide': (divide as int?),
        if (increment != _undefined) 'increment': (increment as int?),
        if (multiply != _undefined) 'multiply': (multiply as int?),
        if ($set != _undefined) 'set': ($set as int?),
      }));
}

class _CopyWithStubImpl$Input$NullableIntFieldUpdateOperationsInput<TRes>
    implements CopyWith$Input$NullableIntFieldUpdateOperationsInput<TRes> {
  _CopyWithStubImpl$Input$NullableIntFieldUpdateOperationsInput(this._res);

  TRes _res;

  call({
    int? decrement,
    int? divide,
    int? increment,
    int? multiply,
    int? $set,
  }) =>
      _res;
}

class Input$NullableStringFieldUpdateOperationsInput {
  factory Input$NullableStringFieldUpdateOperationsInput({String? $set}) =>
      Input$NullableStringFieldUpdateOperationsInput._({
        if ($set != null) r'set': $set,
      });

  Input$NullableStringFieldUpdateOperationsInput._(this._$data);

  factory Input$NullableStringFieldUpdateOperationsInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('set')) {
      final l$$set = data['set'];
      result$data['set'] = (l$$set as String?);
    }
    return Input$NullableStringFieldUpdateOperationsInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get $set => (_$data['set'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('set')) {
      final l$$set = $set;
      result$data['set'] = l$$set;
    }
    return result$data;
  }

  CopyWith$Input$NullableStringFieldUpdateOperationsInput<
          Input$NullableStringFieldUpdateOperationsInput>
      get copyWith => CopyWith$Input$NullableStringFieldUpdateOperationsInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$NullableStringFieldUpdateOperationsInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$$set = $set;
    final lOther$$set = other.$set;
    if (_$data.containsKey('set') != other._$data.containsKey('set')) {
      return false;
    }
    if (l$$set != lOther$$set) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$$set = $set;
    return Object.hashAll([_$data.containsKey('set') ? l$$set : const {}]);
  }
}

abstract class CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> {
  factory CopyWith$Input$NullableStringFieldUpdateOperationsInput(
    Input$NullableStringFieldUpdateOperationsInput instance,
    TRes Function(Input$NullableStringFieldUpdateOperationsInput) then,
  ) = _CopyWithImpl$Input$NullableStringFieldUpdateOperationsInput;

  factory CopyWith$Input$NullableStringFieldUpdateOperationsInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$NullableStringFieldUpdateOperationsInput;

  TRes call({String? $set});
}

class _CopyWithImpl$Input$NullableStringFieldUpdateOperationsInput<TRes>
    implements CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> {
  _CopyWithImpl$Input$NullableStringFieldUpdateOperationsInput(
    this._instance,
    this._then,
  );

  final Input$NullableStringFieldUpdateOperationsInput _instance;

  final TRes Function(Input$NullableStringFieldUpdateOperationsInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({Object? $set = _undefined}) =>
      _then(Input$NullableStringFieldUpdateOperationsInput._({
        ..._instance._$data,
        if ($set != _undefined) 'set': ($set as String?),
      }));
}

class _CopyWithStubImpl$Input$NullableStringFieldUpdateOperationsInput<TRes>
    implements CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> {
  _CopyWithStubImpl$Input$NullableStringFieldUpdateOperationsInput(this._res);

  TRes _res;

  call({String? $set}) => _res;
}

class Input$PromptInput {
  factory Input$PromptInput({
    required int age,
    required String name,
    required String prompt,
  }) =>
      Input$PromptInput._({
        r'age': age,
        r'name': name,
        r'prompt': prompt,
      });

  Input$PromptInput._(this._$data);

  factory Input$PromptInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$age = data['age'];
    result$data['age'] = (l$age as int);
    final l$name = data['name'];
    result$data['name'] = (l$name as String);
    final l$prompt = data['prompt'];
    result$data['prompt'] = (l$prompt as String);
    return Input$PromptInput._(result$data);
  }

  Map<String, dynamic> _$data;

  int get age => (_$data['age'] as int);

  String get name => (_$data['name'] as String);

  String get prompt => (_$data['prompt'] as String);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$age = age;
    result$data['age'] = l$age;
    final l$name = name;
    result$data['name'] = l$name;
    final l$prompt = prompt;
    result$data['prompt'] = l$prompt;
    return result$data;
  }

  CopyWith$Input$PromptInput<Input$PromptInput> get copyWith =>
      CopyWith$Input$PromptInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$PromptInput) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$age = age;
    final lOther$age = other.age;
    if (l$age != lOther$age) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) {
      return false;
    }
    final l$prompt = prompt;
    final lOther$prompt = other.prompt;
    if (l$prompt != lOther$prompt) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$age = age;
    final l$name = name;
    final l$prompt = prompt;
    return Object.hashAll([
      l$age,
      l$name,
      l$prompt,
    ]);
  }
}

abstract class CopyWith$Input$PromptInput<TRes> {
  factory CopyWith$Input$PromptInput(
    Input$PromptInput instance,
    TRes Function(Input$PromptInput) then,
  ) = _CopyWithImpl$Input$PromptInput;

  factory CopyWith$Input$PromptInput.stub(TRes res) =
      _CopyWithStubImpl$Input$PromptInput;

  TRes call({
    int? age,
    String? name,
    String? prompt,
  });
}

class _CopyWithImpl$Input$PromptInput<TRes>
    implements CopyWith$Input$PromptInput<TRes> {
  _CopyWithImpl$Input$PromptInput(
    this._instance,
    this._then,
  );

  final Input$PromptInput _instance;

  final TRes Function(Input$PromptInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? age = _undefined,
    Object? name = _undefined,
    Object? prompt = _undefined,
  }) =>
      _then(Input$PromptInput._({
        ..._instance._$data,
        if (age != _undefined && age != null) 'age': (age as int),
        if (name != _undefined && name != null) 'name': (name as String),
        if (prompt != _undefined && prompt != null)
          'prompt': (prompt as String),
      }));
}

class _CopyWithStubImpl$Input$PromptInput<TRes>
    implements CopyWith$Input$PromptInput<TRes> {
  _CopyWithStubImpl$Input$PromptInput(this._res);

  TRes _res;

  call({
    int? age,
    String? name,
    String? prompt,
  }) =>
      _res;
}

class Input$SortOrderInput {
  factory Input$SortOrderInput({
    Enum$NullsOrder? nulls,
    required Enum$SortOrder sort,
  }) =>
      Input$SortOrderInput._({
        if (nulls != null) r'nulls': nulls,
        r'sort': sort,
      });

  Input$SortOrderInput._(this._$data);

  factory Input$SortOrderInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('nulls')) {
      final l$nulls = data['nulls'];
      result$data['nulls'] = l$nulls == null
          ? null
          : fromJson$Enum$NullsOrder((l$nulls as String));
    }
    final l$sort = data['sort'];
    result$data['sort'] = fromJson$Enum$SortOrder((l$sort as String));
    return Input$SortOrderInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$NullsOrder? get nulls => (_$data['nulls'] as Enum$NullsOrder?);

  Enum$SortOrder get sort => (_$data['sort'] as Enum$SortOrder);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('nulls')) {
      final l$nulls = nulls;
      result$data['nulls'] =
          l$nulls == null ? null : toJson$Enum$NullsOrder(l$nulls);
    }
    final l$sort = sort;
    result$data['sort'] = toJson$Enum$SortOrder(l$sort);
    return result$data;
  }

  CopyWith$Input$SortOrderInput<Input$SortOrderInput> get copyWith =>
      CopyWith$Input$SortOrderInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$SortOrderInput) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$nulls = nulls;
    final lOther$nulls = other.nulls;
    if (_$data.containsKey('nulls') != other._$data.containsKey('nulls')) {
      return false;
    }
    if (l$nulls != lOther$nulls) {
      return false;
    }
    final l$sort = sort;
    final lOther$sort = other.sort;
    if (l$sort != lOther$sort) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$nulls = nulls;
    final l$sort = sort;
    return Object.hashAll([
      _$data.containsKey('nulls') ? l$nulls : const {},
      l$sort,
    ]);
  }
}

abstract class CopyWith$Input$SortOrderInput<TRes> {
  factory CopyWith$Input$SortOrderInput(
    Input$SortOrderInput instance,
    TRes Function(Input$SortOrderInput) then,
  ) = _CopyWithImpl$Input$SortOrderInput;

  factory CopyWith$Input$SortOrderInput.stub(TRes res) =
      _CopyWithStubImpl$Input$SortOrderInput;

  TRes call({
    Enum$NullsOrder? nulls,
    Enum$SortOrder? sort,
  });
}

class _CopyWithImpl$Input$SortOrderInput<TRes>
    implements CopyWith$Input$SortOrderInput<TRes> {
  _CopyWithImpl$Input$SortOrderInput(
    this._instance,
    this._then,
  );

  final Input$SortOrderInput _instance;

  final TRes Function(Input$SortOrderInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? nulls = _undefined,
    Object? sort = _undefined,
  }) =>
      _then(Input$SortOrderInput._({
        ..._instance._$data,
        if (nulls != _undefined) 'nulls': (nulls as Enum$NullsOrder?),
        if (sort != _undefined && sort != null)
          'sort': (sort as Enum$SortOrder),
      }));
}

class _CopyWithStubImpl$Input$SortOrderInput<TRes>
    implements CopyWith$Input$SortOrderInput<TRes> {
  _CopyWithStubImpl$Input$SortOrderInput(this._res);

  TRes _res;

  call({
    Enum$NullsOrder? nulls,
    Enum$SortOrder? sort,
  }) =>
      _res;
}

class Input$StringFieldUpdateOperationsInput {
  factory Input$StringFieldUpdateOperationsInput({String? $set}) =>
      Input$StringFieldUpdateOperationsInput._({
        if ($set != null) r'set': $set,
      });

  Input$StringFieldUpdateOperationsInput._(this._$data);

  factory Input$StringFieldUpdateOperationsInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('set')) {
      final l$$set = data['set'];
      result$data['set'] = (l$$set as String?);
    }
    return Input$StringFieldUpdateOperationsInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get $set => (_$data['set'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('set')) {
      final l$$set = $set;
      result$data['set'] = l$$set;
    }
    return result$data;
  }

  CopyWith$Input$StringFieldUpdateOperationsInput<
          Input$StringFieldUpdateOperationsInput>
      get copyWith => CopyWith$Input$StringFieldUpdateOperationsInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$StringFieldUpdateOperationsInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$$set = $set;
    final lOther$$set = other.$set;
    if (_$data.containsKey('set') != other._$data.containsKey('set')) {
      return false;
    }
    if (l$$set != lOther$$set) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$$set = $set;
    return Object.hashAll([_$data.containsKey('set') ? l$$set : const {}]);
  }
}

abstract class CopyWith$Input$StringFieldUpdateOperationsInput<TRes> {
  factory CopyWith$Input$StringFieldUpdateOperationsInput(
    Input$StringFieldUpdateOperationsInput instance,
    TRes Function(Input$StringFieldUpdateOperationsInput) then,
  ) = _CopyWithImpl$Input$StringFieldUpdateOperationsInput;

  factory CopyWith$Input$StringFieldUpdateOperationsInput.stub(TRes res) =
      _CopyWithStubImpl$Input$StringFieldUpdateOperationsInput;

  TRes call({String? $set});
}

class _CopyWithImpl$Input$StringFieldUpdateOperationsInput<TRes>
    implements CopyWith$Input$StringFieldUpdateOperationsInput<TRes> {
  _CopyWithImpl$Input$StringFieldUpdateOperationsInput(
    this._instance,
    this._then,
  );

  final Input$StringFieldUpdateOperationsInput _instance;

  final TRes Function(Input$StringFieldUpdateOperationsInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({Object? $set = _undefined}) =>
      _then(Input$StringFieldUpdateOperationsInput._({
        ..._instance._$data,
        if ($set != _undefined) 'set': ($set as String?),
      }));
}

class _CopyWithStubImpl$Input$StringFieldUpdateOperationsInput<TRes>
    implements CopyWith$Input$StringFieldUpdateOperationsInput<TRes> {
  _CopyWithStubImpl$Input$StringFieldUpdateOperationsInput(this._res);

  TRes _res;

  call({String? $set}) => _res;
}

class Input$StringFilter {
  factory Input$StringFilter({
    String? contains,
    String? endsWith,
    String? equals,
    String? gt,
    String? gte,
    List<String>? $in,
    String? lt,
    String? lte,
    Enum$QueryMode? mode,
    Input$NestedStringFilter? not,
    List<String>? notIn,
    String? startsWith,
  }) =>
      Input$StringFilter._({
        if (contains != null) r'contains': contains,
        if (endsWith != null) r'endsWith': endsWith,
        if (equals != null) r'equals': equals,
        if (gt != null) r'gt': gt,
        if (gte != null) r'gte': gte,
        if ($in != null) r'in': $in,
        if (lt != null) r'lt': lt,
        if (lte != null) r'lte': lte,
        if (mode != null) r'mode': mode,
        if (not != null) r'not': not,
        if (notIn != null) r'notIn': notIn,
        if (startsWith != null) r'startsWith': startsWith,
      });

  Input$StringFilter._(this._$data);

  factory Input$StringFilter.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('contains')) {
      final l$contains = data['contains'];
      result$data['contains'] = (l$contains as String?);
    }
    if (data.containsKey('endsWith')) {
      final l$endsWith = data['endsWith'];
      result$data['endsWith'] = (l$endsWith as String?);
    }
    if (data.containsKey('equals')) {
      final l$equals = data['equals'];
      result$data['equals'] = (l$equals as String?);
    }
    if (data.containsKey('gt')) {
      final l$gt = data['gt'];
      result$data['gt'] = (l$gt as String?);
    }
    if (data.containsKey('gte')) {
      final l$gte = data['gte'];
      result$data['gte'] = (l$gte as String?);
    }
    if (data.containsKey('in')) {
      final l$$in = data['in'];
      result$data['in'] =
          (l$$in as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    if (data.containsKey('lt')) {
      final l$lt = data['lt'];
      result$data['lt'] = (l$lt as String?);
    }
    if (data.containsKey('lte')) {
      final l$lte = data['lte'];
      result$data['lte'] = (l$lte as String?);
    }
    if (data.containsKey('mode')) {
      final l$mode = data['mode'];
      result$data['mode'] =
          l$mode == null ? null : fromJson$Enum$QueryMode((l$mode as String));
    }
    if (data.containsKey('not')) {
      final l$not = data['not'];
      result$data['not'] = l$not == null
          ? null
          : Input$NestedStringFilter.fromJson((l$not as Map<String, dynamic>));
    }
    if (data.containsKey('notIn')) {
      final l$notIn = data['notIn'];
      result$data['notIn'] =
          (l$notIn as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    if (data.containsKey('startsWith')) {
      final l$startsWith = data['startsWith'];
      result$data['startsWith'] = (l$startsWith as String?);
    }
    return Input$StringFilter._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get contains => (_$data['contains'] as String?);

  String? get endsWith => (_$data['endsWith'] as String?);

  String? get equals => (_$data['equals'] as String?);

  String? get gt => (_$data['gt'] as String?);

  String? get gte => (_$data['gte'] as String?);

  List<String>? get $in => (_$data['in'] as List<String>?);

  String? get lt => (_$data['lt'] as String?);

  String? get lte => (_$data['lte'] as String?);

  Enum$QueryMode? get mode => (_$data['mode'] as Enum$QueryMode?);

  Input$NestedStringFilter? get not =>
      (_$data['not'] as Input$NestedStringFilter?);

  List<String>? get notIn => (_$data['notIn'] as List<String>?);

  String? get startsWith => (_$data['startsWith'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('contains')) {
      final l$contains = contains;
      result$data['contains'] = l$contains;
    }
    if (_$data.containsKey('endsWith')) {
      final l$endsWith = endsWith;
      result$data['endsWith'] = l$endsWith;
    }
    if (_$data.containsKey('equals')) {
      final l$equals = equals;
      result$data['equals'] = l$equals;
    }
    if (_$data.containsKey('gt')) {
      final l$gt = gt;
      result$data['gt'] = l$gt;
    }
    if (_$data.containsKey('gte')) {
      final l$gte = gte;
      result$data['gte'] = l$gte;
    }
    if (_$data.containsKey('in')) {
      final l$$in = $in;
      result$data['in'] = l$$in?.map((e) => e).toList();
    }
    if (_$data.containsKey('lt')) {
      final l$lt = lt;
      result$data['lt'] = l$lt;
    }
    if (_$data.containsKey('lte')) {
      final l$lte = lte;
      result$data['lte'] = l$lte;
    }
    if (_$data.containsKey('mode')) {
      final l$mode = mode;
      result$data['mode'] =
          l$mode == null ? null : toJson$Enum$QueryMode(l$mode);
    }
    if (_$data.containsKey('not')) {
      final l$not = not;
      result$data['not'] = l$not?.toJson();
    }
    if (_$data.containsKey('notIn')) {
      final l$notIn = notIn;
      result$data['notIn'] = l$notIn?.map((e) => e).toList();
    }
    if (_$data.containsKey('startsWith')) {
      final l$startsWith = startsWith;
      result$data['startsWith'] = l$startsWith;
    }
    return result$data;
  }

  CopyWith$Input$StringFilter<Input$StringFilter> get copyWith =>
      CopyWith$Input$StringFilter(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$StringFilter) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$contains = contains;
    final lOther$contains = other.contains;
    if (_$data.containsKey('contains') !=
        other._$data.containsKey('contains')) {
      return false;
    }
    if (l$contains != lOther$contains) {
      return false;
    }
    final l$endsWith = endsWith;
    final lOther$endsWith = other.endsWith;
    if (_$data.containsKey('endsWith') !=
        other._$data.containsKey('endsWith')) {
      return false;
    }
    if (l$endsWith != lOther$endsWith) {
      return false;
    }
    final l$equals = equals;
    final lOther$equals = other.equals;
    if (_$data.containsKey('equals') != other._$data.containsKey('equals')) {
      return false;
    }
    if (l$equals != lOther$equals) {
      return false;
    }
    final l$gt = gt;
    final lOther$gt = other.gt;
    if (_$data.containsKey('gt') != other._$data.containsKey('gt')) {
      return false;
    }
    if (l$gt != lOther$gt) {
      return false;
    }
    final l$gte = gte;
    final lOther$gte = other.gte;
    if (_$data.containsKey('gte') != other._$data.containsKey('gte')) {
      return false;
    }
    if (l$gte != lOther$gte) {
      return false;
    }
    final l$$in = $in;
    final lOther$$in = other.$in;
    if (_$data.containsKey('in') != other._$data.containsKey('in')) {
      return false;
    }
    if (l$$in != null && lOther$$in != null) {
      if (l$$in.length != lOther$$in.length) {
        return false;
      }
      for (int i = 0; i < l$$in.length; i++) {
        final l$$in$entry = l$$in[i];
        final lOther$$in$entry = lOther$$in[i];
        if (l$$in$entry != lOther$$in$entry) {
          return false;
        }
      }
    } else if (l$$in != lOther$$in) {
      return false;
    }
    final l$lt = lt;
    final lOther$lt = other.lt;
    if (_$data.containsKey('lt') != other._$data.containsKey('lt')) {
      return false;
    }
    if (l$lt != lOther$lt) {
      return false;
    }
    final l$lte = lte;
    final lOther$lte = other.lte;
    if (_$data.containsKey('lte') != other._$data.containsKey('lte')) {
      return false;
    }
    if (l$lte != lOther$lte) {
      return false;
    }
    final l$mode = mode;
    final lOther$mode = other.mode;
    if (_$data.containsKey('mode') != other._$data.containsKey('mode')) {
      return false;
    }
    if (l$mode != lOther$mode) {
      return false;
    }
    final l$not = not;
    final lOther$not = other.not;
    if (_$data.containsKey('not') != other._$data.containsKey('not')) {
      return false;
    }
    if (l$not != lOther$not) {
      return false;
    }
    final l$notIn = notIn;
    final lOther$notIn = other.notIn;
    if (_$data.containsKey('notIn') != other._$data.containsKey('notIn')) {
      return false;
    }
    if (l$notIn != null && lOther$notIn != null) {
      if (l$notIn.length != lOther$notIn.length) {
        return false;
      }
      for (int i = 0; i < l$notIn.length; i++) {
        final l$notIn$entry = l$notIn[i];
        final lOther$notIn$entry = lOther$notIn[i];
        if (l$notIn$entry != lOther$notIn$entry) {
          return false;
        }
      }
    } else if (l$notIn != lOther$notIn) {
      return false;
    }
    final l$startsWith = startsWith;
    final lOther$startsWith = other.startsWith;
    if (_$data.containsKey('startsWith') !=
        other._$data.containsKey('startsWith')) {
      return false;
    }
    if (l$startsWith != lOther$startsWith) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$contains = contains;
    final l$endsWith = endsWith;
    final l$equals = equals;
    final l$gt = gt;
    final l$gte = gte;
    final l$$in = $in;
    final l$lt = lt;
    final l$lte = lte;
    final l$mode = mode;
    final l$not = not;
    final l$notIn = notIn;
    final l$startsWith = startsWith;
    return Object.hashAll([
      _$data.containsKey('contains') ? l$contains : const {},
      _$data.containsKey('endsWith') ? l$endsWith : const {},
      _$data.containsKey('equals') ? l$equals : const {},
      _$data.containsKey('gt') ? l$gt : const {},
      _$data.containsKey('gte') ? l$gte : const {},
      _$data.containsKey('in')
          ? l$$in == null
              ? null
              : Object.hashAll(l$$in.map((v) => v))
          : const {},
      _$data.containsKey('lt') ? l$lt : const {},
      _$data.containsKey('lte') ? l$lte : const {},
      _$data.containsKey('mode') ? l$mode : const {},
      _$data.containsKey('not') ? l$not : const {},
      _$data.containsKey('notIn')
          ? l$notIn == null
              ? null
              : Object.hashAll(l$notIn.map((v) => v))
          : const {},
      _$data.containsKey('startsWith') ? l$startsWith : const {},
    ]);
  }
}

abstract class CopyWith$Input$StringFilter<TRes> {
  factory CopyWith$Input$StringFilter(
    Input$StringFilter instance,
    TRes Function(Input$StringFilter) then,
  ) = _CopyWithImpl$Input$StringFilter;

  factory CopyWith$Input$StringFilter.stub(TRes res) =
      _CopyWithStubImpl$Input$StringFilter;

  TRes call({
    String? contains,
    String? endsWith,
    String? equals,
    String? gt,
    String? gte,
    List<String>? $in,
    String? lt,
    String? lte,
    Enum$QueryMode? mode,
    Input$NestedStringFilter? not,
    List<String>? notIn,
    String? startsWith,
  });
  CopyWith$Input$NestedStringFilter<TRes> get not;
}

class _CopyWithImpl$Input$StringFilter<TRes>
    implements CopyWith$Input$StringFilter<TRes> {
  _CopyWithImpl$Input$StringFilter(
    this._instance,
    this._then,
  );

  final Input$StringFilter _instance;

  final TRes Function(Input$StringFilter) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? contains = _undefined,
    Object? endsWith = _undefined,
    Object? equals = _undefined,
    Object? gt = _undefined,
    Object? gte = _undefined,
    Object? $in = _undefined,
    Object? lt = _undefined,
    Object? lte = _undefined,
    Object? mode = _undefined,
    Object? not = _undefined,
    Object? notIn = _undefined,
    Object? startsWith = _undefined,
  }) =>
      _then(Input$StringFilter._({
        ..._instance._$data,
        if (contains != _undefined) 'contains': (contains as String?),
        if (endsWith != _undefined) 'endsWith': (endsWith as String?),
        if (equals != _undefined) 'equals': (equals as String?),
        if (gt != _undefined) 'gt': (gt as String?),
        if (gte != _undefined) 'gte': (gte as String?),
        if ($in != _undefined) 'in': ($in as List<String>?),
        if (lt != _undefined) 'lt': (lt as String?),
        if (lte != _undefined) 'lte': (lte as String?),
        if (mode != _undefined) 'mode': (mode as Enum$QueryMode?),
        if (not != _undefined) 'not': (not as Input$NestedStringFilter?),
        if (notIn != _undefined) 'notIn': (notIn as List<String>?),
        if (startsWith != _undefined) 'startsWith': (startsWith as String?),
      }));

  CopyWith$Input$NestedStringFilter<TRes> get not {
    final local$not = _instance.not;
    return local$not == null
        ? CopyWith$Input$NestedStringFilter.stub(_then(_instance))
        : CopyWith$Input$NestedStringFilter(local$not, (e) => call(not: e));
  }
}

class _CopyWithStubImpl$Input$StringFilter<TRes>
    implements CopyWith$Input$StringFilter<TRes> {
  _CopyWithStubImpl$Input$StringFilter(this._res);

  TRes _res;

  call({
    String? contains,
    String? endsWith,
    String? equals,
    String? gt,
    String? gte,
    List<String>? $in,
    String? lt,
    String? lte,
    Enum$QueryMode? mode,
    Input$NestedStringFilter? not,
    List<String>? notIn,
    String? startsWith,
  }) =>
      _res;

  CopyWith$Input$NestedStringFilter<TRes> get not =>
      CopyWith$Input$NestedStringFilter.stub(_res);
}

class Input$StringNullableFilter {
  factory Input$StringNullableFilter({
    String? contains,
    String? endsWith,
    String? equals,
    String? gt,
    String? gte,
    List<String>? $in,
    String? lt,
    String? lte,
    Enum$QueryMode? mode,
    Input$NestedStringNullableFilter? not,
    List<String>? notIn,
    String? startsWith,
  }) =>
      Input$StringNullableFilter._({
        if (contains != null) r'contains': contains,
        if (endsWith != null) r'endsWith': endsWith,
        if (equals != null) r'equals': equals,
        if (gt != null) r'gt': gt,
        if (gte != null) r'gte': gte,
        if ($in != null) r'in': $in,
        if (lt != null) r'lt': lt,
        if (lte != null) r'lte': lte,
        if (mode != null) r'mode': mode,
        if (not != null) r'not': not,
        if (notIn != null) r'notIn': notIn,
        if (startsWith != null) r'startsWith': startsWith,
      });

  Input$StringNullableFilter._(this._$data);

  factory Input$StringNullableFilter.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('contains')) {
      final l$contains = data['contains'];
      result$data['contains'] = (l$contains as String?);
    }
    if (data.containsKey('endsWith')) {
      final l$endsWith = data['endsWith'];
      result$data['endsWith'] = (l$endsWith as String?);
    }
    if (data.containsKey('equals')) {
      final l$equals = data['equals'];
      result$data['equals'] = (l$equals as String?);
    }
    if (data.containsKey('gt')) {
      final l$gt = data['gt'];
      result$data['gt'] = (l$gt as String?);
    }
    if (data.containsKey('gte')) {
      final l$gte = data['gte'];
      result$data['gte'] = (l$gte as String?);
    }
    if (data.containsKey('in')) {
      final l$$in = data['in'];
      result$data['in'] =
          (l$$in as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    if (data.containsKey('lt')) {
      final l$lt = data['lt'];
      result$data['lt'] = (l$lt as String?);
    }
    if (data.containsKey('lte')) {
      final l$lte = data['lte'];
      result$data['lte'] = (l$lte as String?);
    }
    if (data.containsKey('mode')) {
      final l$mode = data['mode'];
      result$data['mode'] =
          l$mode == null ? null : fromJson$Enum$QueryMode((l$mode as String));
    }
    if (data.containsKey('not')) {
      final l$not = data['not'];
      result$data['not'] = l$not == null
          ? null
          : Input$NestedStringNullableFilter.fromJson(
              (l$not as Map<String, dynamic>));
    }
    if (data.containsKey('notIn')) {
      final l$notIn = data['notIn'];
      result$data['notIn'] =
          (l$notIn as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    if (data.containsKey('startsWith')) {
      final l$startsWith = data['startsWith'];
      result$data['startsWith'] = (l$startsWith as String?);
    }
    return Input$StringNullableFilter._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get contains => (_$data['contains'] as String?);

  String? get endsWith => (_$data['endsWith'] as String?);

  String? get equals => (_$data['equals'] as String?);

  String? get gt => (_$data['gt'] as String?);

  String? get gte => (_$data['gte'] as String?);

  List<String>? get $in => (_$data['in'] as List<String>?);

  String? get lt => (_$data['lt'] as String?);

  String? get lte => (_$data['lte'] as String?);

  Enum$QueryMode? get mode => (_$data['mode'] as Enum$QueryMode?);

  Input$NestedStringNullableFilter? get not =>
      (_$data['not'] as Input$NestedStringNullableFilter?);

  List<String>? get notIn => (_$data['notIn'] as List<String>?);

  String? get startsWith => (_$data['startsWith'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('contains')) {
      final l$contains = contains;
      result$data['contains'] = l$contains;
    }
    if (_$data.containsKey('endsWith')) {
      final l$endsWith = endsWith;
      result$data['endsWith'] = l$endsWith;
    }
    if (_$data.containsKey('equals')) {
      final l$equals = equals;
      result$data['equals'] = l$equals;
    }
    if (_$data.containsKey('gt')) {
      final l$gt = gt;
      result$data['gt'] = l$gt;
    }
    if (_$data.containsKey('gte')) {
      final l$gte = gte;
      result$data['gte'] = l$gte;
    }
    if (_$data.containsKey('in')) {
      final l$$in = $in;
      result$data['in'] = l$$in?.map((e) => e).toList();
    }
    if (_$data.containsKey('lt')) {
      final l$lt = lt;
      result$data['lt'] = l$lt;
    }
    if (_$data.containsKey('lte')) {
      final l$lte = lte;
      result$data['lte'] = l$lte;
    }
    if (_$data.containsKey('mode')) {
      final l$mode = mode;
      result$data['mode'] =
          l$mode == null ? null : toJson$Enum$QueryMode(l$mode);
    }
    if (_$data.containsKey('not')) {
      final l$not = not;
      result$data['not'] = l$not?.toJson();
    }
    if (_$data.containsKey('notIn')) {
      final l$notIn = notIn;
      result$data['notIn'] = l$notIn?.map((e) => e).toList();
    }
    if (_$data.containsKey('startsWith')) {
      final l$startsWith = startsWith;
      result$data['startsWith'] = l$startsWith;
    }
    return result$data;
  }

  CopyWith$Input$StringNullableFilter<Input$StringNullableFilter>
      get copyWith => CopyWith$Input$StringNullableFilter(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$StringNullableFilter) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$contains = contains;
    final lOther$contains = other.contains;
    if (_$data.containsKey('contains') !=
        other._$data.containsKey('contains')) {
      return false;
    }
    if (l$contains != lOther$contains) {
      return false;
    }
    final l$endsWith = endsWith;
    final lOther$endsWith = other.endsWith;
    if (_$data.containsKey('endsWith') !=
        other._$data.containsKey('endsWith')) {
      return false;
    }
    if (l$endsWith != lOther$endsWith) {
      return false;
    }
    final l$equals = equals;
    final lOther$equals = other.equals;
    if (_$data.containsKey('equals') != other._$data.containsKey('equals')) {
      return false;
    }
    if (l$equals != lOther$equals) {
      return false;
    }
    final l$gt = gt;
    final lOther$gt = other.gt;
    if (_$data.containsKey('gt') != other._$data.containsKey('gt')) {
      return false;
    }
    if (l$gt != lOther$gt) {
      return false;
    }
    final l$gte = gte;
    final lOther$gte = other.gte;
    if (_$data.containsKey('gte') != other._$data.containsKey('gte')) {
      return false;
    }
    if (l$gte != lOther$gte) {
      return false;
    }
    final l$$in = $in;
    final lOther$$in = other.$in;
    if (_$data.containsKey('in') != other._$data.containsKey('in')) {
      return false;
    }
    if (l$$in != null && lOther$$in != null) {
      if (l$$in.length != lOther$$in.length) {
        return false;
      }
      for (int i = 0; i < l$$in.length; i++) {
        final l$$in$entry = l$$in[i];
        final lOther$$in$entry = lOther$$in[i];
        if (l$$in$entry != lOther$$in$entry) {
          return false;
        }
      }
    } else if (l$$in != lOther$$in) {
      return false;
    }
    final l$lt = lt;
    final lOther$lt = other.lt;
    if (_$data.containsKey('lt') != other._$data.containsKey('lt')) {
      return false;
    }
    if (l$lt != lOther$lt) {
      return false;
    }
    final l$lte = lte;
    final lOther$lte = other.lte;
    if (_$data.containsKey('lte') != other._$data.containsKey('lte')) {
      return false;
    }
    if (l$lte != lOther$lte) {
      return false;
    }
    final l$mode = mode;
    final lOther$mode = other.mode;
    if (_$data.containsKey('mode') != other._$data.containsKey('mode')) {
      return false;
    }
    if (l$mode != lOther$mode) {
      return false;
    }
    final l$not = not;
    final lOther$not = other.not;
    if (_$data.containsKey('not') != other._$data.containsKey('not')) {
      return false;
    }
    if (l$not != lOther$not) {
      return false;
    }
    final l$notIn = notIn;
    final lOther$notIn = other.notIn;
    if (_$data.containsKey('notIn') != other._$data.containsKey('notIn')) {
      return false;
    }
    if (l$notIn != null && lOther$notIn != null) {
      if (l$notIn.length != lOther$notIn.length) {
        return false;
      }
      for (int i = 0; i < l$notIn.length; i++) {
        final l$notIn$entry = l$notIn[i];
        final lOther$notIn$entry = lOther$notIn[i];
        if (l$notIn$entry != lOther$notIn$entry) {
          return false;
        }
      }
    } else if (l$notIn != lOther$notIn) {
      return false;
    }
    final l$startsWith = startsWith;
    final lOther$startsWith = other.startsWith;
    if (_$data.containsKey('startsWith') !=
        other._$data.containsKey('startsWith')) {
      return false;
    }
    if (l$startsWith != lOther$startsWith) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$contains = contains;
    final l$endsWith = endsWith;
    final l$equals = equals;
    final l$gt = gt;
    final l$gte = gte;
    final l$$in = $in;
    final l$lt = lt;
    final l$lte = lte;
    final l$mode = mode;
    final l$not = not;
    final l$notIn = notIn;
    final l$startsWith = startsWith;
    return Object.hashAll([
      _$data.containsKey('contains') ? l$contains : const {},
      _$data.containsKey('endsWith') ? l$endsWith : const {},
      _$data.containsKey('equals') ? l$equals : const {},
      _$data.containsKey('gt') ? l$gt : const {},
      _$data.containsKey('gte') ? l$gte : const {},
      _$data.containsKey('in')
          ? l$$in == null
              ? null
              : Object.hashAll(l$$in.map((v) => v))
          : const {},
      _$data.containsKey('lt') ? l$lt : const {},
      _$data.containsKey('lte') ? l$lte : const {},
      _$data.containsKey('mode') ? l$mode : const {},
      _$data.containsKey('not') ? l$not : const {},
      _$data.containsKey('notIn')
          ? l$notIn == null
              ? null
              : Object.hashAll(l$notIn.map((v) => v))
          : const {},
      _$data.containsKey('startsWith') ? l$startsWith : const {},
    ]);
  }
}

abstract class CopyWith$Input$StringNullableFilter<TRes> {
  factory CopyWith$Input$StringNullableFilter(
    Input$StringNullableFilter instance,
    TRes Function(Input$StringNullableFilter) then,
  ) = _CopyWithImpl$Input$StringNullableFilter;

  factory CopyWith$Input$StringNullableFilter.stub(TRes res) =
      _CopyWithStubImpl$Input$StringNullableFilter;

  TRes call({
    String? contains,
    String? endsWith,
    String? equals,
    String? gt,
    String? gte,
    List<String>? $in,
    String? lt,
    String? lte,
    Enum$QueryMode? mode,
    Input$NestedStringNullableFilter? not,
    List<String>? notIn,
    String? startsWith,
  });
  CopyWith$Input$NestedStringNullableFilter<TRes> get not;
}

class _CopyWithImpl$Input$StringNullableFilter<TRes>
    implements CopyWith$Input$StringNullableFilter<TRes> {
  _CopyWithImpl$Input$StringNullableFilter(
    this._instance,
    this._then,
  );

  final Input$StringNullableFilter _instance;

  final TRes Function(Input$StringNullableFilter) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? contains = _undefined,
    Object? endsWith = _undefined,
    Object? equals = _undefined,
    Object? gt = _undefined,
    Object? gte = _undefined,
    Object? $in = _undefined,
    Object? lt = _undefined,
    Object? lte = _undefined,
    Object? mode = _undefined,
    Object? not = _undefined,
    Object? notIn = _undefined,
    Object? startsWith = _undefined,
  }) =>
      _then(Input$StringNullableFilter._({
        ..._instance._$data,
        if (contains != _undefined) 'contains': (contains as String?),
        if (endsWith != _undefined) 'endsWith': (endsWith as String?),
        if (equals != _undefined) 'equals': (equals as String?),
        if (gt != _undefined) 'gt': (gt as String?),
        if (gte != _undefined) 'gte': (gte as String?),
        if ($in != _undefined) 'in': ($in as List<String>?),
        if (lt != _undefined) 'lt': (lt as String?),
        if (lte != _undefined) 'lte': (lte as String?),
        if (mode != _undefined) 'mode': (mode as Enum$QueryMode?),
        if (not != _undefined)
          'not': (not as Input$NestedStringNullableFilter?),
        if (notIn != _undefined) 'notIn': (notIn as List<String>?),
        if (startsWith != _undefined) 'startsWith': (startsWith as String?),
      }));

  CopyWith$Input$NestedStringNullableFilter<TRes> get not {
    final local$not = _instance.not;
    return local$not == null
        ? CopyWith$Input$NestedStringNullableFilter.stub(_then(_instance))
        : CopyWith$Input$NestedStringNullableFilter(
            local$not, (e) => call(not: e));
  }
}

class _CopyWithStubImpl$Input$StringNullableFilter<TRes>
    implements CopyWith$Input$StringNullableFilter<TRes> {
  _CopyWithStubImpl$Input$StringNullableFilter(this._res);

  TRes _res;

  call({
    String? contains,
    String? endsWith,
    String? equals,
    String? gt,
    String? gte,
    List<String>? $in,
    String? lt,
    String? lte,
    Enum$QueryMode? mode,
    Input$NestedStringNullableFilter? not,
    List<String>? notIn,
    String? startsWith,
  }) =>
      _res;

  CopyWith$Input$NestedStringNullableFilter<TRes> get not =>
      CopyWith$Input$NestedStringNullableFilter.stub(_res);
}

class Input$StringNullableListFilter {
  factory Input$StringNullableListFilter({
    List<String>? equals,
    String? has,
    List<String>? hasEvery,
    List<String>? hasSome,
    bool? isEmpty,
  }) =>
      Input$StringNullableListFilter._({
        if (equals != null) r'equals': equals,
        if (has != null) r'has': has,
        if (hasEvery != null) r'hasEvery': hasEvery,
        if (hasSome != null) r'hasSome': hasSome,
        if (isEmpty != null) r'isEmpty': isEmpty,
      });

  Input$StringNullableListFilter._(this._$data);

  factory Input$StringNullableListFilter.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('equals')) {
      final l$equals = data['equals'];
      result$data['equals'] =
          (l$equals as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    if (data.containsKey('has')) {
      final l$has = data['has'];
      result$data['has'] = (l$has as String?);
    }
    if (data.containsKey('hasEvery')) {
      final l$hasEvery = data['hasEvery'];
      result$data['hasEvery'] =
          (l$hasEvery as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    if (data.containsKey('hasSome')) {
      final l$hasSome = data['hasSome'];
      result$data['hasSome'] =
          (l$hasSome as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    if (data.containsKey('isEmpty')) {
      final l$isEmpty = data['isEmpty'];
      result$data['isEmpty'] = (l$isEmpty as bool?);
    }
    return Input$StringNullableListFilter._(result$data);
  }

  Map<String, dynamic> _$data;

  List<String>? get equals => (_$data['equals'] as List<String>?);

  String? get has => (_$data['has'] as String?);

  List<String>? get hasEvery => (_$data['hasEvery'] as List<String>?);

  List<String>? get hasSome => (_$data['hasSome'] as List<String>?);

  bool? get isEmpty => (_$data['isEmpty'] as bool?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('equals')) {
      final l$equals = equals;
      result$data['equals'] = l$equals?.map((e) => e).toList();
    }
    if (_$data.containsKey('has')) {
      final l$has = has;
      result$data['has'] = l$has;
    }
    if (_$data.containsKey('hasEvery')) {
      final l$hasEvery = hasEvery;
      result$data['hasEvery'] = l$hasEvery?.map((e) => e).toList();
    }
    if (_$data.containsKey('hasSome')) {
      final l$hasSome = hasSome;
      result$data['hasSome'] = l$hasSome?.map((e) => e).toList();
    }
    if (_$data.containsKey('isEmpty')) {
      final l$isEmpty = isEmpty;
      result$data['isEmpty'] = l$isEmpty;
    }
    return result$data;
  }

  CopyWith$Input$StringNullableListFilter<Input$StringNullableListFilter>
      get copyWith => CopyWith$Input$StringNullableListFilter(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$StringNullableListFilter) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$equals = equals;
    final lOther$equals = other.equals;
    if (_$data.containsKey('equals') != other._$data.containsKey('equals')) {
      return false;
    }
    if (l$equals != null && lOther$equals != null) {
      if (l$equals.length != lOther$equals.length) {
        return false;
      }
      for (int i = 0; i < l$equals.length; i++) {
        final l$equals$entry = l$equals[i];
        final lOther$equals$entry = lOther$equals[i];
        if (l$equals$entry != lOther$equals$entry) {
          return false;
        }
      }
    } else if (l$equals != lOther$equals) {
      return false;
    }
    final l$has = has;
    final lOther$has = other.has;
    if (_$data.containsKey('has') != other._$data.containsKey('has')) {
      return false;
    }
    if (l$has != lOther$has) {
      return false;
    }
    final l$hasEvery = hasEvery;
    final lOther$hasEvery = other.hasEvery;
    if (_$data.containsKey('hasEvery') !=
        other._$data.containsKey('hasEvery')) {
      return false;
    }
    if (l$hasEvery != null && lOther$hasEvery != null) {
      if (l$hasEvery.length != lOther$hasEvery.length) {
        return false;
      }
      for (int i = 0; i < l$hasEvery.length; i++) {
        final l$hasEvery$entry = l$hasEvery[i];
        final lOther$hasEvery$entry = lOther$hasEvery[i];
        if (l$hasEvery$entry != lOther$hasEvery$entry) {
          return false;
        }
      }
    } else if (l$hasEvery != lOther$hasEvery) {
      return false;
    }
    final l$hasSome = hasSome;
    final lOther$hasSome = other.hasSome;
    if (_$data.containsKey('hasSome') != other._$data.containsKey('hasSome')) {
      return false;
    }
    if (l$hasSome != null && lOther$hasSome != null) {
      if (l$hasSome.length != lOther$hasSome.length) {
        return false;
      }
      for (int i = 0; i < l$hasSome.length; i++) {
        final l$hasSome$entry = l$hasSome[i];
        final lOther$hasSome$entry = lOther$hasSome[i];
        if (l$hasSome$entry != lOther$hasSome$entry) {
          return false;
        }
      }
    } else if (l$hasSome != lOther$hasSome) {
      return false;
    }
    final l$isEmpty = isEmpty;
    final lOther$isEmpty = other.isEmpty;
    if (_$data.containsKey('isEmpty') != other._$data.containsKey('isEmpty')) {
      return false;
    }
    if (l$isEmpty != lOther$isEmpty) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$equals = equals;
    final l$has = has;
    final l$hasEvery = hasEvery;
    final l$hasSome = hasSome;
    final l$isEmpty = isEmpty;
    return Object.hashAll([
      _$data.containsKey('equals')
          ? l$equals == null
              ? null
              : Object.hashAll(l$equals.map((v) => v))
          : const {},
      _$data.containsKey('has') ? l$has : const {},
      _$data.containsKey('hasEvery')
          ? l$hasEvery == null
              ? null
              : Object.hashAll(l$hasEvery.map((v) => v))
          : const {},
      _$data.containsKey('hasSome')
          ? l$hasSome == null
              ? null
              : Object.hashAll(l$hasSome.map((v) => v))
          : const {},
      _$data.containsKey('isEmpty') ? l$isEmpty : const {},
    ]);
  }
}

abstract class CopyWith$Input$StringNullableListFilter<TRes> {
  factory CopyWith$Input$StringNullableListFilter(
    Input$StringNullableListFilter instance,
    TRes Function(Input$StringNullableListFilter) then,
  ) = _CopyWithImpl$Input$StringNullableListFilter;

  factory CopyWith$Input$StringNullableListFilter.stub(TRes res) =
      _CopyWithStubImpl$Input$StringNullableListFilter;

  TRes call({
    List<String>? equals,
    String? has,
    List<String>? hasEvery,
    List<String>? hasSome,
    bool? isEmpty,
  });
}

class _CopyWithImpl$Input$StringNullableListFilter<TRes>
    implements CopyWith$Input$StringNullableListFilter<TRes> {
  _CopyWithImpl$Input$StringNullableListFilter(
    this._instance,
    this._then,
  );

  final Input$StringNullableListFilter _instance;

  final TRes Function(Input$StringNullableListFilter) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? equals = _undefined,
    Object? has = _undefined,
    Object? hasEvery = _undefined,
    Object? hasSome = _undefined,
    Object? isEmpty = _undefined,
  }) =>
      _then(Input$StringNullableListFilter._({
        ..._instance._$data,
        if (equals != _undefined) 'equals': (equals as List<String>?),
        if (has != _undefined) 'has': (has as String?),
        if (hasEvery != _undefined) 'hasEvery': (hasEvery as List<String>?),
        if (hasSome != _undefined) 'hasSome': (hasSome as List<String>?),
        if (isEmpty != _undefined) 'isEmpty': (isEmpty as bool?),
      }));
}

class _CopyWithStubImpl$Input$StringNullableListFilter<TRes>
    implements CopyWith$Input$StringNullableListFilter<TRes> {
  _CopyWithStubImpl$Input$StringNullableListFilter(this._res);

  TRes _res;

  call({
    List<String>? equals,
    String? has,
    List<String>? hasEvery,
    List<String>? hasSome,
    bool? isEmpty,
  }) =>
      _res;
}

class Input$StringNullableWithAggregatesFilter {
  factory Input$StringNullableWithAggregatesFilter({
    Input$NestedIntNullableFilter? $_count,
    Input$NestedStringNullableFilter? $_max,
    Input$NestedStringNullableFilter? $_min,
    String? contains,
    String? endsWith,
    String? equals,
    String? gt,
    String? gte,
    List<String>? $in,
    String? lt,
    String? lte,
    Enum$QueryMode? mode,
    Input$NestedStringNullableWithAggregatesFilter? not,
    List<String>? notIn,
    String? startsWith,
  }) =>
      Input$StringNullableWithAggregatesFilter._({
        if ($_count != null) r'_count': $_count,
        if ($_max != null) r'_max': $_max,
        if ($_min != null) r'_min': $_min,
        if (contains != null) r'contains': contains,
        if (endsWith != null) r'endsWith': endsWith,
        if (equals != null) r'equals': equals,
        if (gt != null) r'gt': gt,
        if (gte != null) r'gte': gte,
        if ($in != null) r'in': $in,
        if (lt != null) r'lt': lt,
        if (lte != null) r'lte': lte,
        if (mode != null) r'mode': mode,
        if (not != null) r'not': not,
        if (notIn != null) r'notIn': notIn,
        if (startsWith != null) r'startsWith': startsWith,
      });

  Input$StringNullableWithAggregatesFilter._(this._$data);

  factory Input$StringNullableWithAggregatesFilter.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('_count')) {
      final l$$_count = data['_count'];
      result$data['_count'] = l$$_count == null
          ? null
          : Input$NestedIntNullableFilter.fromJson(
              (l$$_count as Map<String, dynamic>));
    }
    if (data.containsKey('_max')) {
      final l$$_max = data['_max'];
      result$data['_max'] = l$$_max == null
          ? null
          : Input$NestedStringNullableFilter.fromJson(
              (l$$_max as Map<String, dynamic>));
    }
    if (data.containsKey('_min')) {
      final l$$_min = data['_min'];
      result$data['_min'] = l$$_min == null
          ? null
          : Input$NestedStringNullableFilter.fromJson(
              (l$$_min as Map<String, dynamic>));
    }
    if (data.containsKey('contains')) {
      final l$contains = data['contains'];
      result$data['contains'] = (l$contains as String?);
    }
    if (data.containsKey('endsWith')) {
      final l$endsWith = data['endsWith'];
      result$data['endsWith'] = (l$endsWith as String?);
    }
    if (data.containsKey('equals')) {
      final l$equals = data['equals'];
      result$data['equals'] = (l$equals as String?);
    }
    if (data.containsKey('gt')) {
      final l$gt = data['gt'];
      result$data['gt'] = (l$gt as String?);
    }
    if (data.containsKey('gte')) {
      final l$gte = data['gte'];
      result$data['gte'] = (l$gte as String?);
    }
    if (data.containsKey('in')) {
      final l$$in = data['in'];
      result$data['in'] =
          (l$$in as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    if (data.containsKey('lt')) {
      final l$lt = data['lt'];
      result$data['lt'] = (l$lt as String?);
    }
    if (data.containsKey('lte')) {
      final l$lte = data['lte'];
      result$data['lte'] = (l$lte as String?);
    }
    if (data.containsKey('mode')) {
      final l$mode = data['mode'];
      result$data['mode'] =
          l$mode == null ? null : fromJson$Enum$QueryMode((l$mode as String));
    }
    if (data.containsKey('not')) {
      final l$not = data['not'];
      result$data['not'] = l$not == null
          ? null
          : Input$NestedStringNullableWithAggregatesFilter.fromJson(
              (l$not as Map<String, dynamic>));
    }
    if (data.containsKey('notIn')) {
      final l$notIn = data['notIn'];
      result$data['notIn'] =
          (l$notIn as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    if (data.containsKey('startsWith')) {
      final l$startsWith = data['startsWith'];
      result$data['startsWith'] = (l$startsWith as String?);
    }
    return Input$StringNullableWithAggregatesFilter._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$NestedIntNullableFilter? get $_count =>
      (_$data['_count'] as Input$NestedIntNullableFilter?);

  Input$NestedStringNullableFilter? get $_max =>
      (_$data['_max'] as Input$NestedStringNullableFilter?);

  Input$NestedStringNullableFilter? get $_min =>
      (_$data['_min'] as Input$NestedStringNullableFilter?);

  String? get contains => (_$data['contains'] as String?);

  String? get endsWith => (_$data['endsWith'] as String?);

  String? get equals => (_$data['equals'] as String?);

  String? get gt => (_$data['gt'] as String?);

  String? get gte => (_$data['gte'] as String?);

  List<String>? get $in => (_$data['in'] as List<String>?);

  String? get lt => (_$data['lt'] as String?);

  String? get lte => (_$data['lte'] as String?);

  Enum$QueryMode? get mode => (_$data['mode'] as Enum$QueryMode?);

  Input$NestedStringNullableWithAggregatesFilter? get not =>
      (_$data['not'] as Input$NestedStringNullableWithAggregatesFilter?);

  List<String>? get notIn => (_$data['notIn'] as List<String>?);

  String? get startsWith => (_$data['startsWith'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('_count')) {
      final l$$_count = $_count;
      result$data['_count'] = l$$_count?.toJson();
    }
    if (_$data.containsKey('_max')) {
      final l$$_max = $_max;
      result$data['_max'] = l$$_max?.toJson();
    }
    if (_$data.containsKey('_min')) {
      final l$$_min = $_min;
      result$data['_min'] = l$$_min?.toJson();
    }
    if (_$data.containsKey('contains')) {
      final l$contains = contains;
      result$data['contains'] = l$contains;
    }
    if (_$data.containsKey('endsWith')) {
      final l$endsWith = endsWith;
      result$data['endsWith'] = l$endsWith;
    }
    if (_$data.containsKey('equals')) {
      final l$equals = equals;
      result$data['equals'] = l$equals;
    }
    if (_$data.containsKey('gt')) {
      final l$gt = gt;
      result$data['gt'] = l$gt;
    }
    if (_$data.containsKey('gte')) {
      final l$gte = gte;
      result$data['gte'] = l$gte;
    }
    if (_$data.containsKey('in')) {
      final l$$in = $in;
      result$data['in'] = l$$in?.map((e) => e).toList();
    }
    if (_$data.containsKey('lt')) {
      final l$lt = lt;
      result$data['lt'] = l$lt;
    }
    if (_$data.containsKey('lte')) {
      final l$lte = lte;
      result$data['lte'] = l$lte;
    }
    if (_$data.containsKey('mode')) {
      final l$mode = mode;
      result$data['mode'] =
          l$mode == null ? null : toJson$Enum$QueryMode(l$mode);
    }
    if (_$data.containsKey('not')) {
      final l$not = not;
      result$data['not'] = l$not?.toJson();
    }
    if (_$data.containsKey('notIn')) {
      final l$notIn = notIn;
      result$data['notIn'] = l$notIn?.map((e) => e).toList();
    }
    if (_$data.containsKey('startsWith')) {
      final l$startsWith = startsWith;
      result$data['startsWith'] = l$startsWith;
    }
    return result$data;
  }

  CopyWith$Input$StringNullableWithAggregatesFilter<
          Input$StringNullableWithAggregatesFilter>
      get copyWith => CopyWith$Input$StringNullableWithAggregatesFilter(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$StringNullableWithAggregatesFilter) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$$_count = $_count;
    final lOther$$_count = other.$_count;
    if (_$data.containsKey('_count') != other._$data.containsKey('_count')) {
      return false;
    }
    if (l$$_count != lOther$$_count) {
      return false;
    }
    final l$$_max = $_max;
    final lOther$$_max = other.$_max;
    if (_$data.containsKey('_max') != other._$data.containsKey('_max')) {
      return false;
    }
    if (l$$_max != lOther$$_max) {
      return false;
    }
    final l$$_min = $_min;
    final lOther$$_min = other.$_min;
    if (_$data.containsKey('_min') != other._$data.containsKey('_min')) {
      return false;
    }
    if (l$$_min != lOther$$_min) {
      return false;
    }
    final l$contains = contains;
    final lOther$contains = other.contains;
    if (_$data.containsKey('contains') !=
        other._$data.containsKey('contains')) {
      return false;
    }
    if (l$contains != lOther$contains) {
      return false;
    }
    final l$endsWith = endsWith;
    final lOther$endsWith = other.endsWith;
    if (_$data.containsKey('endsWith') !=
        other._$data.containsKey('endsWith')) {
      return false;
    }
    if (l$endsWith != lOther$endsWith) {
      return false;
    }
    final l$equals = equals;
    final lOther$equals = other.equals;
    if (_$data.containsKey('equals') != other._$data.containsKey('equals')) {
      return false;
    }
    if (l$equals != lOther$equals) {
      return false;
    }
    final l$gt = gt;
    final lOther$gt = other.gt;
    if (_$data.containsKey('gt') != other._$data.containsKey('gt')) {
      return false;
    }
    if (l$gt != lOther$gt) {
      return false;
    }
    final l$gte = gte;
    final lOther$gte = other.gte;
    if (_$data.containsKey('gte') != other._$data.containsKey('gte')) {
      return false;
    }
    if (l$gte != lOther$gte) {
      return false;
    }
    final l$$in = $in;
    final lOther$$in = other.$in;
    if (_$data.containsKey('in') != other._$data.containsKey('in')) {
      return false;
    }
    if (l$$in != null && lOther$$in != null) {
      if (l$$in.length != lOther$$in.length) {
        return false;
      }
      for (int i = 0; i < l$$in.length; i++) {
        final l$$in$entry = l$$in[i];
        final lOther$$in$entry = lOther$$in[i];
        if (l$$in$entry != lOther$$in$entry) {
          return false;
        }
      }
    } else if (l$$in != lOther$$in) {
      return false;
    }
    final l$lt = lt;
    final lOther$lt = other.lt;
    if (_$data.containsKey('lt') != other._$data.containsKey('lt')) {
      return false;
    }
    if (l$lt != lOther$lt) {
      return false;
    }
    final l$lte = lte;
    final lOther$lte = other.lte;
    if (_$data.containsKey('lte') != other._$data.containsKey('lte')) {
      return false;
    }
    if (l$lte != lOther$lte) {
      return false;
    }
    final l$mode = mode;
    final lOther$mode = other.mode;
    if (_$data.containsKey('mode') != other._$data.containsKey('mode')) {
      return false;
    }
    if (l$mode != lOther$mode) {
      return false;
    }
    final l$not = not;
    final lOther$not = other.not;
    if (_$data.containsKey('not') != other._$data.containsKey('not')) {
      return false;
    }
    if (l$not != lOther$not) {
      return false;
    }
    final l$notIn = notIn;
    final lOther$notIn = other.notIn;
    if (_$data.containsKey('notIn') != other._$data.containsKey('notIn')) {
      return false;
    }
    if (l$notIn != null && lOther$notIn != null) {
      if (l$notIn.length != lOther$notIn.length) {
        return false;
      }
      for (int i = 0; i < l$notIn.length; i++) {
        final l$notIn$entry = l$notIn[i];
        final lOther$notIn$entry = lOther$notIn[i];
        if (l$notIn$entry != lOther$notIn$entry) {
          return false;
        }
      }
    } else if (l$notIn != lOther$notIn) {
      return false;
    }
    final l$startsWith = startsWith;
    final lOther$startsWith = other.startsWith;
    if (_$data.containsKey('startsWith') !=
        other._$data.containsKey('startsWith')) {
      return false;
    }
    if (l$startsWith != lOther$startsWith) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$$_count = $_count;
    final l$$_max = $_max;
    final l$$_min = $_min;
    final l$contains = contains;
    final l$endsWith = endsWith;
    final l$equals = equals;
    final l$gt = gt;
    final l$gte = gte;
    final l$$in = $in;
    final l$lt = lt;
    final l$lte = lte;
    final l$mode = mode;
    final l$not = not;
    final l$notIn = notIn;
    final l$startsWith = startsWith;
    return Object.hashAll([
      _$data.containsKey('_count') ? l$$_count : const {},
      _$data.containsKey('_max') ? l$$_max : const {},
      _$data.containsKey('_min') ? l$$_min : const {},
      _$data.containsKey('contains') ? l$contains : const {},
      _$data.containsKey('endsWith') ? l$endsWith : const {},
      _$data.containsKey('equals') ? l$equals : const {},
      _$data.containsKey('gt') ? l$gt : const {},
      _$data.containsKey('gte') ? l$gte : const {},
      _$data.containsKey('in')
          ? l$$in == null
              ? null
              : Object.hashAll(l$$in.map((v) => v))
          : const {},
      _$data.containsKey('lt') ? l$lt : const {},
      _$data.containsKey('lte') ? l$lte : const {},
      _$data.containsKey('mode') ? l$mode : const {},
      _$data.containsKey('not') ? l$not : const {},
      _$data.containsKey('notIn')
          ? l$notIn == null
              ? null
              : Object.hashAll(l$notIn.map((v) => v))
          : const {},
      _$data.containsKey('startsWith') ? l$startsWith : const {},
    ]);
  }
}

abstract class CopyWith$Input$StringNullableWithAggregatesFilter<TRes> {
  factory CopyWith$Input$StringNullableWithAggregatesFilter(
    Input$StringNullableWithAggregatesFilter instance,
    TRes Function(Input$StringNullableWithAggregatesFilter) then,
  ) = _CopyWithImpl$Input$StringNullableWithAggregatesFilter;

  factory CopyWith$Input$StringNullableWithAggregatesFilter.stub(TRes res) =
      _CopyWithStubImpl$Input$StringNullableWithAggregatesFilter;

  TRes call({
    Input$NestedIntNullableFilter? $_count,
    Input$NestedStringNullableFilter? $_max,
    Input$NestedStringNullableFilter? $_min,
    String? contains,
    String? endsWith,
    String? equals,
    String? gt,
    String? gte,
    List<String>? $in,
    String? lt,
    String? lte,
    Enum$QueryMode? mode,
    Input$NestedStringNullableWithAggregatesFilter? not,
    List<String>? notIn,
    String? startsWith,
  });
  CopyWith$Input$NestedIntNullableFilter<TRes> get $_count;
  CopyWith$Input$NestedStringNullableFilter<TRes> get $_max;
  CopyWith$Input$NestedStringNullableFilter<TRes> get $_min;
  CopyWith$Input$NestedStringNullableWithAggregatesFilter<TRes> get not;
}

class _CopyWithImpl$Input$StringNullableWithAggregatesFilter<TRes>
    implements CopyWith$Input$StringNullableWithAggregatesFilter<TRes> {
  _CopyWithImpl$Input$StringNullableWithAggregatesFilter(
    this._instance,
    this._then,
  );

  final Input$StringNullableWithAggregatesFilter _instance;

  final TRes Function(Input$StringNullableWithAggregatesFilter) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? $_count = _undefined,
    Object? $_max = _undefined,
    Object? $_min = _undefined,
    Object? contains = _undefined,
    Object? endsWith = _undefined,
    Object? equals = _undefined,
    Object? gt = _undefined,
    Object? gte = _undefined,
    Object? $in = _undefined,
    Object? lt = _undefined,
    Object? lte = _undefined,
    Object? mode = _undefined,
    Object? not = _undefined,
    Object? notIn = _undefined,
    Object? startsWith = _undefined,
  }) =>
      _then(Input$StringNullableWithAggregatesFilter._({
        ..._instance._$data,
        if ($_count != _undefined)
          '_count': ($_count as Input$NestedIntNullableFilter?),
        if ($_max != _undefined)
          '_max': ($_max as Input$NestedStringNullableFilter?),
        if ($_min != _undefined)
          '_min': ($_min as Input$NestedStringNullableFilter?),
        if (contains != _undefined) 'contains': (contains as String?),
        if (endsWith != _undefined) 'endsWith': (endsWith as String?),
        if (equals != _undefined) 'equals': (equals as String?),
        if (gt != _undefined) 'gt': (gt as String?),
        if (gte != _undefined) 'gte': (gte as String?),
        if ($in != _undefined) 'in': ($in as List<String>?),
        if (lt != _undefined) 'lt': (lt as String?),
        if (lte != _undefined) 'lte': (lte as String?),
        if (mode != _undefined) 'mode': (mode as Enum$QueryMode?),
        if (not != _undefined)
          'not': (not as Input$NestedStringNullableWithAggregatesFilter?),
        if (notIn != _undefined) 'notIn': (notIn as List<String>?),
        if (startsWith != _undefined) 'startsWith': (startsWith as String?),
      }));

  CopyWith$Input$NestedIntNullableFilter<TRes> get $_count {
    final local$$_count = _instance.$_count;
    return local$$_count == null
        ? CopyWith$Input$NestedIntNullableFilter.stub(_then(_instance))
        : CopyWith$Input$NestedIntNullableFilter(
            local$$_count, (e) => call($_count: e));
  }

  CopyWith$Input$NestedStringNullableFilter<TRes> get $_max {
    final local$$_max = _instance.$_max;
    return local$$_max == null
        ? CopyWith$Input$NestedStringNullableFilter.stub(_then(_instance))
        : CopyWith$Input$NestedStringNullableFilter(
            local$$_max, (e) => call($_max: e));
  }

  CopyWith$Input$NestedStringNullableFilter<TRes> get $_min {
    final local$$_min = _instance.$_min;
    return local$$_min == null
        ? CopyWith$Input$NestedStringNullableFilter.stub(_then(_instance))
        : CopyWith$Input$NestedStringNullableFilter(
            local$$_min, (e) => call($_min: e));
  }

  CopyWith$Input$NestedStringNullableWithAggregatesFilter<TRes> get not {
    final local$not = _instance.not;
    return local$not == null
        ? CopyWith$Input$NestedStringNullableWithAggregatesFilter.stub(
            _then(_instance))
        : CopyWith$Input$NestedStringNullableWithAggregatesFilter(
            local$not, (e) => call(not: e));
  }
}

class _CopyWithStubImpl$Input$StringNullableWithAggregatesFilter<TRes>
    implements CopyWith$Input$StringNullableWithAggregatesFilter<TRes> {
  _CopyWithStubImpl$Input$StringNullableWithAggregatesFilter(this._res);

  TRes _res;

  call({
    Input$NestedIntNullableFilter? $_count,
    Input$NestedStringNullableFilter? $_max,
    Input$NestedStringNullableFilter? $_min,
    String? contains,
    String? endsWith,
    String? equals,
    String? gt,
    String? gte,
    List<String>? $in,
    String? lt,
    String? lte,
    Enum$QueryMode? mode,
    Input$NestedStringNullableWithAggregatesFilter? not,
    List<String>? notIn,
    String? startsWith,
  }) =>
      _res;

  CopyWith$Input$NestedIntNullableFilter<TRes> get $_count =>
      CopyWith$Input$NestedIntNullableFilter.stub(_res);

  CopyWith$Input$NestedStringNullableFilter<TRes> get $_max =>
      CopyWith$Input$NestedStringNullableFilter.stub(_res);

  CopyWith$Input$NestedStringNullableFilter<TRes> get $_min =>
      CopyWith$Input$NestedStringNullableFilter.stub(_res);

  CopyWith$Input$NestedStringNullableWithAggregatesFilter<TRes> get not =>
      CopyWith$Input$NestedStringNullableWithAggregatesFilter.stub(_res);
}

class Input$StringWithAggregatesFilter {
  factory Input$StringWithAggregatesFilter({
    Input$NestedIntFilter? $_count,
    Input$NestedStringFilter? $_max,
    Input$NestedStringFilter? $_min,
    String? contains,
    String? endsWith,
    String? equals,
    String? gt,
    String? gte,
    List<String>? $in,
    String? lt,
    String? lte,
    Enum$QueryMode? mode,
    Input$NestedStringWithAggregatesFilter? not,
    List<String>? notIn,
    String? startsWith,
  }) =>
      Input$StringWithAggregatesFilter._({
        if ($_count != null) r'_count': $_count,
        if ($_max != null) r'_max': $_max,
        if ($_min != null) r'_min': $_min,
        if (contains != null) r'contains': contains,
        if (endsWith != null) r'endsWith': endsWith,
        if (equals != null) r'equals': equals,
        if (gt != null) r'gt': gt,
        if (gte != null) r'gte': gte,
        if ($in != null) r'in': $in,
        if (lt != null) r'lt': lt,
        if (lte != null) r'lte': lte,
        if (mode != null) r'mode': mode,
        if (not != null) r'not': not,
        if (notIn != null) r'notIn': notIn,
        if (startsWith != null) r'startsWith': startsWith,
      });

  Input$StringWithAggregatesFilter._(this._$data);

  factory Input$StringWithAggregatesFilter.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('_count')) {
      final l$$_count = data['_count'];
      result$data['_count'] = l$$_count == null
          ? null
          : Input$NestedIntFilter.fromJson((l$$_count as Map<String, dynamic>));
    }
    if (data.containsKey('_max')) {
      final l$$_max = data['_max'];
      result$data['_max'] = l$$_max == null
          ? null
          : Input$NestedStringFilter.fromJson(
              (l$$_max as Map<String, dynamic>));
    }
    if (data.containsKey('_min')) {
      final l$$_min = data['_min'];
      result$data['_min'] = l$$_min == null
          ? null
          : Input$NestedStringFilter.fromJson(
              (l$$_min as Map<String, dynamic>));
    }
    if (data.containsKey('contains')) {
      final l$contains = data['contains'];
      result$data['contains'] = (l$contains as String?);
    }
    if (data.containsKey('endsWith')) {
      final l$endsWith = data['endsWith'];
      result$data['endsWith'] = (l$endsWith as String?);
    }
    if (data.containsKey('equals')) {
      final l$equals = data['equals'];
      result$data['equals'] = (l$equals as String?);
    }
    if (data.containsKey('gt')) {
      final l$gt = data['gt'];
      result$data['gt'] = (l$gt as String?);
    }
    if (data.containsKey('gte')) {
      final l$gte = data['gte'];
      result$data['gte'] = (l$gte as String?);
    }
    if (data.containsKey('in')) {
      final l$$in = data['in'];
      result$data['in'] =
          (l$$in as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    if (data.containsKey('lt')) {
      final l$lt = data['lt'];
      result$data['lt'] = (l$lt as String?);
    }
    if (data.containsKey('lte')) {
      final l$lte = data['lte'];
      result$data['lte'] = (l$lte as String?);
    }
    if (data.containsKey('mode')) {
      final l$mode = data['mode'];
      result$data['mode'] =
          l$mode == null ? null : fromJson$Enum$QueryMode((l$mode as String));
    }
    if (data.containsKey('not')) {
      final l$not = data['not'];
      result$data['not'] = l$not == null
          ? null
          : Input$NestedStringWithAggregatesFilter.fromJson(
              (l$not as Map<String, dynamic>));
    }
    if (data.containsKey('notIn')) {
      final l$notIn = data['notIn'];
      result$data['notIn'] =
          (l$notIn as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    if (data.containsKey('startsWith')) {
      final l$startsWith = data['startsWith'];
      result$data['startsWith'] = (l$startsWith as String?);
    }
    return Input$StringWithAggregatesFilter._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$NestedIntFilter? get $_count =>
      (_$data['_count'] as Input$NestedIntFilter?);

  Input$NestedStringFilter? get $_max =>
      (_$data['_max'] as Input$NestedStringFilter?);

  Input$NestedStringFilter? get $_min =>
      (_$data['_min'] as Input$NestedStringFilter?);

  String? get contains => (_$data['contains'] as String?);

  String? get endsWith => (_$data['endsWith'] as String?);

  String? get equals => (_$data['equals'] as String?);

  String? get gt => (_$data['gt'] as String?);

  String? get gte => (_$data['gte'] as String?);

  List<String>? get $in => (_$data['in'] as List<String>?);

  String? get lt => (_$data['lt'] as String?);

  String? get lte => (_$data['lte'] as String?);

  Enum$QueryMode? get mode => (_$data['mode'] as Enum$QueryMode?);

  Input$NestedStringWithAggregatesFilter? get not =>
      (_$data['not'] as Input$NestedStringWithAggregatesFilter?);

  List<String>? get notIn => (_$data['notIn'] as List<String>?);

  String? get startsWith => (_$data['startsWith'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('_count')) {
      final l$$_count = $_count;
      result$data['_count'] = l$$_count?.toJson();
    }
    if (_$data.containsKey('_max')) {
      final l$$_max = $_max;
      result$data['_max'] = l$$_max?.toJson();
    }
    if (_$data.containsKey('_min')) {
      final l$$_min = $_min;
      result$data['_min'] = l$$_min?.toJson();
    }
    if (_$data.containsKey('contains')) {
      final l$contains = contains;
      result$data['contains'] = l$contains;
    }
    if (_$data.containsKey('endsWith')) {
      final l$endsWith = endsWith;
      result$data['endsWith'] = l$endsWith;
    }
    if (_$data.containsKey('equals')) {
      final l$equals = equals;
      result$data['equals'] = l$equals;
    }
    if (_$data.containsKey('gt')) {
      final l$gt = gt;
      result$data['gt'] = l$gt;
    }
    if (_$data.containsKey('gte')) {
      final l$gte = gte;
      result$data['gte'] = l$gte;
    }
    if (_$data.containsKey('in')) {
      final l$$in = $in;
      result$data['in'] = l$$in?.map((e) => e).toList();
    }
    if (_$data.containsKey('lt')) {
      final l$lt = lt;
      result$data['lt'] = l$lt;
    }
    if (_$data.containsKey('lte')) {
      final l$lte = lte;
      result$data['lte'] = l$lte;
    }
    if (_$data.containsKey('mode')) {
      final l$mode = mode;
      result$data['mode'] =
          l$mode == null ? null : toJson$Enum$QueryMode(l$mode);
    }
    if (_$data.containsKey('not')) {
      final l$not = not;
      result$data['not'] = l$not?.toJson();
    }
    if (_$data.containsKey('notIn')) {
      final l$notIn = notIn;
      result$data['notIn'] = l$notIn?.map((e) => e).toList();
    }
    if (_$data.containsKey('startsWith')) {
      final l$startsWith = startsWith;
      result$data['startsWith'] = l$startsWith;
    }
    return result$data;
  }

  CopyWith$Input$StringWithAggregatesFilter<Input$StringWithAggregatesFilter>
      get copyWith => CopyWith$Input$StringWithAggregatesFilter(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$StringWithAggregatesFilter) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$$_count = $_count;
    final lOther$$_count = other.$_count;
    if (_$data.containsKey('_count') != other._$data.containsKey('_count')) {
      return false;
    }
    if (l$$_count != lOther$$_count) {
      return false;
    }
    final l$$_max = $_max;
    final lOther$$_max = other.$_max;
    if (_$data.containsKey('_max') != other._$data.containsKey('_max')) {
      return false;
    }
    if (l$$_max != lOther$$_max) {
      return false;
    }
    final l$$_min = $_min;
    final lOther$$_min = other.$_min;
    if (_$data.containsKey('_min') != other._$data.containsKey('_min')) {
      return false;
    }
    if (l$$_min != lOther$$_min) {
      return false;
    }
    final l$contains = contains;
    final lOther$contains = other.contains;
    if (_$data.containsKey('contains') !=
        other._$data.containsKey('contains')) {
      return false;
    }
    if (l$contains != lOther$contains) {
      return false;
    }
    final l$endsWith = endsWith;
    final lOther$endsWith = other.endsWith;
    if (_$data.containsKey('endsWith') !=
        other._$data.containsKey('endsWith')) {
      return false;
    }
    if (l$endsWith != lOther$endsWith) {
      return false;
    }
    final l$equals = equals;
    final lOther$equals = other.equals;
    if (_$data.containsKey('equals') != other._$data.containsKey('equals')) {
      return false;
    }
    if (l$equals != lOther$equals) {
      return false;
    }
    final l$gt = gt;
    final lOther$gt = other.gt;
    if (_$data.containsKey('gt') != other._$data.containsKey('gt')) {
      return false;
    }
    if (l$gt != lOther$gt) {
      return false;
    }
    final l$gte = gte;
    final lOther$gte = other.gte;
    if (_$data.containsKey('gte') != other._$data.containsKey('gte')) {
      return false;
    }
    if (l$gte != lOther$gte) {
      return false;
    }
    final l$$in = $in;
    final lOther$$in = other.$in;
    if (_$data.containsKey('in') != other._$data.containsKey('in')) {
      return false;
    }
    if (l$$in != null && lOther$$in != null) {
      if (l$$in.length != lOther$$in.length) {
        return false;
      }
      for (int i = 0; i < l$$in.length; i++) {
        final l$$in$entry = l$$in[i];
        final lOther$$in$entry = lOther$$in[i];
        if (l$$in$entry != lOther$$in$entry) {
          return false;
        }
      }
    } else if (l$$in != lOther$$in) {
      return false;
    }
    final l$lt = lt;
    final lOther$lt = other.lt;
    if (_$data.containsKey('lt') != other._$data.containsKey('lt')) {
      return false;
    }
    if (l$lt != lOther$lt) {
      return false;
    }
    final l$lte = lte;
    final lOther$lte = other.lte;
    if (_$data.containsKey('lte') != other._$data.containsKey('lte')) {
      return false;
    }
    if (l$lte != lOther$lte) {
      return false;
    }
    final l$mode = mode;
    final lOther$mode = other.mode;
    if (_$data.containsKey('mode') != other._$data.containsKey('mode')) {
      return false;
    }
    if (l$mode != lOther$mode) {
      return false;
    }
    final l$not = not;
    final lOther$not = other.not;
    if (_$data.containsKey('not') != other._$data.containsKey('not')) {
      return false;
    }
    if (l$not != lOther$not) {
      return false;
    }
    final l$notIn = notIn;
    final lOther$notIn = other.notIn;
    if (_$data.containsKey('notIn') != other._$data.containsKey('notIn')) {
      return false;
    }
    if (l$notIn != null && lOther$notIn != null) {
      if (l$notIn.length != lOther$notIn.length) {
        return false;
      }
      for (int i = 0; i < l$notIn.length; i++) {
        final l$notIn$entry = l$notIn[i];
        final lOther$notIn$entry = lOther$notIn[i];
        if (l$notIn$entry != lOther$notIn$entry) {
          return false;
        }
      }
    } else if (l$notIn != lOther$notIn) {
      return false;
    }
    final l$startsWith = startsWith;
    final lOther$startsWith = other.startsWith;
    if (_$data.containsKey('startsWith') !=
        other._$data.containsKey('startsWith')) {
      return false;
    }
    if (l$startsWith != lOther$startsWith) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$$_count = $_count;
    final l$$_max = $_max;
    final l$$_min = $_min;
    final l$contains = contains;
    final l$endsWith = endsWith;
    final l$equals = equals;
    final l$gt = gt;
    final l$gte = gte;
    final l$$in = $in;
    final l$lt = lt;
    final l$lte = lte;
    final l$mode = mode;
    final l$not = not;
    final l$notIn = notIn;
    final l$startsWith = startsWith;
    return Object.hashAll([
      _$data.containsKey('_count') ? l$$_count : const {},
      _$data.containsKey('_max') ? l$$_max : const {},
      _$data.containsKey('_min') ? l$$_min : const {},
      _$data.containsKey('contains') ? l$contains : const {},
      _$data.containsKey('endsWith') ? l$endsWith : const {},
      _$data.containsKey('equals') ? l$equals : const {},
      _$data.containsKey('gt') ? l$gt : const {},
      _$data.containsKey('gte') ? l$gte : const {},
      _$data.containsKey('in')
          ? l$$in == null
              ? null
              : Object.hashAll(l$$in.map((v) => v))
          : const {},
      _$data.containsKey('lt') ? l$lt : const {},
      _$data.containsKey('lte') ? l$lte : const {},
      _$data.containsKey('mode') ? l$mode : const {},
      _$data.containsKey('not') ? l$not : const {},
      _$data.containsKey('notIn')
          ? l$notIn == null
              ? null
              : Object.hashAll(l$notIn.map((v) => v))
          : const {},
      _$data.containsKey('startsWith') ? l$startsWith : const {},
    ]);
  }
}

abstract class CopyWith$Input$StringWithAggregatesFilter<TRes> {
  factory CopyWith$Input$StringWithAggregatesFilter(
    Input$StringWithAggregatesFilter instance,
    TRes Function(Input$StringWithAggregatesFilter) then,
  ) = _CopyWithImpl$Input$StringWithAggregatesFilter;

  factory CopyWith$Input$StringWithAggregatesFilter.stub(TRes res) =
      _CopyWithStubImpl$Input$StringWithAggregatesFilter;

  TRes call({
    Input$NestedIntFilter? $_count,
    Input$NestedStringFilter? $_max,
    Input$NestedStringFilter? $_min,
    String? contains,
    String? endsWith,
    String? equals,
    String? gt,
    String? gte,
    List<String>? $in,
    String? lt,
    String? lte,
    Enum$QueryMode? mode,
    Input$NestedStringWithAggregatesFilter? not,
    List<String>? notIn,
    String? startsWith,
  });
  CopyWith$Input$NestedIntFilter<TRes> get $_count;
  CopyWith$Input$NestedStringFilter<TRes> get $_max;
  CopyWith$Input$NestedStringFilter<TRes> get $_min;
  CopyWith$Input$NestedStringWithAggregatesFilter<TRes> get not;
}

class _CopyWithImpl$Input$StringWithAggregatesFilter<TRes>
    implements CopyWith$Input$StringWithAggregatesFilter<TRes> {
  _CopyWithImpl$Input$StringWithAggregatesFilter(
    this._instance,
    this._then,
  );

  final Input$StringWithAggregatesFilter _instance;

  final TRes Function(Input$StringWithAggregatesFilter) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? $_count = _undefined,
    Object? $_max = _undefined,
    Object? $_min = _undefined,
    Object? contains = _undefined,
    Object? endsWith = _undefined,
    Object? equals = _undefined,
    Object? gt = _undefined,
    Object? gte = _undefined,
    Object? $in = _undefined,
    Object? lt = _undefined,
    Object? lte = _undefined,
    Object? mode = _undefined,
    Object? not = _undefined,
    Object? notIn = _undefined,
    Object? startsWith = _undefined,
  }) =>
      _then(Input$StringWithAggregatesFilter._({
        ..._instance._$data,
        if ($_count != _undefined)
          '_count': ($_count as Input$NestedIntFilter?),
        if ($_max != _undefined) '_max': ($_max as Input$NestedStringFilter?),
        if ($_min != _undefined) '_min': ($_min as Input$NestedStringFilter?),
        if (contains != _undefined) 'contains': (contains as String?),
        if (endsWith != _undefined) 'endsWith': (endsWith as String?),
        if (equals != _undefined) 'equals': (equals as String?),
        if (gt != _undefined) 'gt': (gt as String?),
        if (gte != _undefined) 'gte': (gte as String?),
        if ($in != _undefined) 'in': ($in as List<String>?),
        if (lt != _undefined) 'lt': (lt as String?),
        if (lte != _undefined) 'lte': (lte as String?),
        if (mode != _undefined) 'mode': (mode as Enum$QueryMode?),
        if (not != _undefined)
          'not': (not as Input$NestedStringWithAggregatesFilter?),
        if (notIn != _undefined) 'notIn': (notIn as List<String>?),
        if (startsWith != _undefined) 'startsWith': (startsWith as String?),
      }));

  CopyWith$Input$NestedIntFilter<TRes> get $_count {
    final local$$_count = _instance.$_count;
    return local$$_count == null
        ? CopyWith$Input$NestedIntFilter.stub(_then(_instance))
        : CopyWith$Input$NestedIntFilter(
            local$$_count, (e) => call($_count: e));
  }

  CopyWith$Input$NestedStringFilter<TRes> get $_max {
    final local$$_max = _instance.$_max;
    return local$$_max == null
        ? CopyWith$Input$NestedStringFilter.stub(_then(_instance))
        : CopyWith$Input$NestedStringFilter(local$$_max, (e) => call($_max: e));
  }

  CopyWith$Input$NestedStringFilter<TRes> get $_min {
    final local$$_min = _instance.$_min;
    return local$$_min == null
        ? CopyWith$Input$NestedStringFilter.stub(_then(_instance))
        : CopyWith$Input$NestedStringFilter(local$$_min, (e) => call($_min: e));
  }

  CopyWith$Input$NestedStringWithAggregatesFilter<TRes> get not {
    final local$not = _instance.not;
    return local$not == null
        ? CopyWith$Input$NestedStringWithAggregatesFilter.stub(_then(_instance))
        : CopyWith$Input$NestedStringWithAggregatesFilter(
            local$not, (e) => call(not: e));
  }
}

class _CopyWithStubImpl$Input$StringWithAggregatesFilter<TRes>
    implements CopyWith$Input$StringWithAggregatesFilter<TRes> {
  _CopyWithStubImpl$Input$StringWithAggregatesFilter(this._res);

  TRes _res;

  call({
    Input$NestedIntFilter? $_count,
    Input$NestedStringFilter? $_max,
    Input$NestedStringFilter? $_min,
    String? contains,
    String? endsWith,
    String? equals,
    String? gt,
    String? gte,
    List<String>? $in,
    String? lt,
    String? lte,
    Enum$QueryMode? mode,
    Input$NestedStringWithAggregatesFilter? not,
    List<String>? notIn,
    String? startsWith,
  }) =>
      _res;

  CopyWith$Input$NestedIntFilter<TRes> get $_count =>
      CopyWith$Input$NestedIntFilter.stub(_res);

  CopyWith$Input$NestedStringFilter<TRes> get $_max =>
      CopyWith$Input$NestedStringFilter.stub(_res);

  CopyWith$Input$NestedStringFilter<TRes> get $_min =>
      CopyWith$Input$NestedStringFilter.stub(_res);

  CopyWith$Input$NestedStringWithAggregatesFilter<TRes> get not =>
      CopyWith$Input$NestedStringWithAggregatesFilter.stub(_res);
}

class Input$UuidFilter {
  factory Input$UuidFilter({
    String? equals,
    String? gt,
    String? gte,
    List<String>? $in,
    String? lt,
    String? lte,
    Enum$QueryMode? mode,
    Input$NestedUuidFilter? not,
    List<String>? notIn,
  }) =>
      Input$UuidFilter._({
        if (equals != null) r'equals': equals,
        if (gt != null) r'gt': gt,
        if (gte != null) r'gte': gte,
        if ($in != null) r'in': $in,
        if (lt != null) r'lt': lt,
        if (lte != null) r'lte': lte,
        if (mode != null) r'mode': mode,
        if (not != null) r'not': not,
        if (notIn != null) r'notIn': notIn,
      });

  Input$UuidFilter._(this._$data);

  factory Input$UuidFilter.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('equals')) {
      final l$equals = data['equals'];
      result$data['equals'] = (l$equals as String?);
    }
    if (data.containsKey('gt')) {
      final l$gt = data['gt'];
      result$data['gt'] = (l$gt as String?);
    }
    if (data.containsKey('gte')) {
      final l$gte = data['gte'];
      result$data['gte'] = (l$gte as String?);
    }
    if (data.containsKey('in')) {
      final l$$in = data['in'];
      result$data['in'] =
          (l$$in as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    if (data.containsKey('lt')) {
      final l$lt = data['lt'];
      result$data['lt'] = (l$lt as String?);
    }
    if (data.containsKey('lte')) {
      final l$lte = data['lte'];
      result$data['lte'] = (l$lte as String?);
    }
    if (data.containsKey('mode')) {
      final l$mode = data['mode'];
      result$data['mode'] =
          l$mode == null ? null : fromJson$Enum$QueryMode((l$mode as String));
    }
    if (data.containsKey('not')) {
      final l$not = data['not'];
      result$data['not'] = l$not == null
          ? null
          : Input$NestedUuidFilter.fromJson((l$not as Map<String, dynamic>));
    }
    if (data.containsKey('notIn')) {
      final l$notIn = data['notIn'];
      result$data['notIn'] =
          (l$notIn as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    return Input$UuidFilter._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get equals => (_$data['equals'] as String?);

  String? get gt => (_$data['gt'] as String?);

  String? get gte => (_$data['gte'] as String?);

  List<String>? get $in => (_$data['in'] as List<String>?);

  String? get lt => (_$data['lt'] as String?);

  String? get lte => (_$data['lte'] as String?);

  Enum$QueryMode? get mode => (_$data['mode'] as Enum$QueryMode?);

  Input$NestedUuidFilter? get not => (_$data['not'] as Input$NestedUuidFilter?);

  List<String>? get notIn => (_$data['notIn'] as List<String>?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('equals')) {
      final l$equals = equals;
      result$data['equals'] = l$equals;
    }
    if (_$data.containsKey('gt')) {
      final l$gt = gt;
      result$data['gt'] = l$gt;
    }
    if (_$data.containsKey('gte')) {
      final l$gte = gte;
      result$data['gte'] = l$gte;
    }
    if (_$data.containsKey('in')) {
      final l$$in = $in;
      result$data['in'] = l$$in?.map((e) => e).toList();
    }
    if (_$data.containsKey('lt')) {
      final l$lt = lt;
      result$data['lt'] = l$lt;
    }
    if (_$data.containsKey('lte')) {
      final l$lte = lte;
      result$data['lte'] = l$lte;
    }
    if (_$data.containsKey('mode')) {
      final l$mode = mode;
      result$data['mode'] =
          l$mode == null ? null : toJson$Enum$QueryMode(l$mode);
    }
    if (_$data.containsKey('not')) {
      final l$not = not;
      result$data['not'] = l$not?.toJson();
    }
    if (_$data.containsKey('notIn')) {
      final l$notIn = notIn;
      result$data['notIn'] = l$notIn?.map((e) => e).toList();
    }
    return result$data;
  }

  CopyWith$Input$UuidFilter<Input$UuidFilter> get copyWith =>
      CopyWith$Input$UuidFilter(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$UuidFilter) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$equals = equals;
    final lOther$equals = other.equals;
    if (_$data.containsKey('equals') != other._$data.containsKey('equals')) {
      return false;
    }
    if (l$equals != lOther$equals) {
      return false;
    }
    final l$gt = gt;
    final lOther$gt = other.gt;
    if (_$data.containsKey('gt') != other._$data.containsKey('gt')) {
      return false;
    }
    if (l$gt != lOther$gt) {
      return false;
    }
    final l$gte = gte;
    final lOther$gte = other.gte;
    if (_$data.containsKey('gte') != other._$data.containsKey('gte')) {
      return false;
    }
    if (l$gte != lOther$gte) {
      return false;
    }
    final l$$in = $in;
    final lOther$$in = other.$in;
    if (_$data.containsKey('in') != other._$data.containsKey('in')) {
      return false;
    }
    if (l$$in != null && lOther$$in != null) {
      if (l$$in.length != lOther$$in.length) {
        return false;
      }
      for (int i = 0; i < l$$in.length; i++) {
        final l$$in$entry = l$$in[i];
        final lOther$$in$entry = lOther$$in[i];
        if (l$$in$entry != lOther$$in$entry) {
          return false;
        }
      }
    } else if (l$$in != lOther$$in) {
      return false;
    }
    final l$lt = lt;
    final lOther$lt = other.lt;
    if (_$data.containsKey('lt') != other._$data.containsKey('lt')) {
      return false;
    }
    if (l$lt != lOther$lt) {
      return false;
    }
    final l$lte = lte;
    final lOther$lte = other.lte;
    if (_$data.containsKey('lte') != other._$data.containsKey('lte')) {
      return false;
    }
    if (l$lte != lOther$lte) {
      return false;
    }
    final l$mode = mode;
    final lOther$mode = other.mode;
    if (_$data.containsKey('mode') != other._$data.containsKey('mode')) {
      return false;
    }
    if (l$mode != lOther$mode) {
      return false;
    }
    final l$not = not;
    final lOther$not = other.not;
    if (_$data.containsKey('not') != other._$data.containsKey('not')) {
      return false;
    }
    if (l$not != lOther$not) {
      return false;
    }
    final l$notIn = notIn;
    final lOther$notIn = other.notIn;
    if (_$data.containsKey('notIn') != other._$data.containsKey('notIn')) {
      return false;
    }
    if (l$notIn != null && lOther$notIn != null) {
      if (l$notIn.length != lOther$notIn.length) {
        return false;
      }
      for (int i = 0; i < l$notIn.length; i++) {
        final l$notIn$entry = l$notIn[i];
        final lOther$notIn$entry = lOther$notIn[i];
        if (l$notIn$entry != lOther$notIn$entry) {
          return false;
        }
      }
    } else if (l$notIn != lOther$notIn) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$equals = equals;
    final l$gt = gt;
    final l$gte = gte;
    final l$$in = $in;
    final l$lt = lt;
    final l$lte = lte;
    final l$mode = mode;
    final l$not = not;
    final l$notIn = notIn;
    return Object.hashAll([
      _$data.containsKey('equals') ? l$equals : const {},
      _$data.containsKey('gt') ? l$gt : const {},
      _$data.containsKey('gte') ? l$gte : const {},
      _$data.containsKey('in')
          ? l$$in == null
              ? null
              : Object.hashAll(l$$in.map((v) => v))
          : const {},
      _$data.containsKey('lt') ? l$lt : const {},
      _$data.containsKey('lte') ? l$lte : const {},
      _$data.containsKey('mode') ? l$mode : const {},
      _$data.containsKey('not') ? l$not : const {},
      _$data.containsKey('notIn')
          ? l$notIn == null
              ? null
              : Object.hashAll(l$notIn.map((v) => v))
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$UuidFilter<TRes> {
  factory CopyWith$Input$UuidFilter(
    Input$UuidFilter instance,
    TRes Function(Input$UuidFilter) then,
  ) = _CopyWithImpl$Input$UuidFilter;

  factory CopyWith$Input$UuidFilter.stub(TRes res) =
      _CopyWithStubImpl$Input$UuidFilter;

  TRes call({
    String? equals,
    String? gt,
    String? gte,
    List<String>? $in,
    String? lt,
    String? lte,
    Enum$QueryMode? mode,
    Input$NestedUuidFilter? not,
    List<String>? notIn,
  });
  CopyWith$Input$NestedUuidFilter<TRes> get not;
}

class _CopyWithImpl$Input$UuidFilter<TRes>
    implements CopyWith$Input$UuidFilter<TRes> {
  _CopyWithImpl$Input$UuidFilter(
    this._instance,
    this._then,
  );

  final Input$UuidFilter _instance;

  final TRes Function(Input$UuidFilter) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? equals = _undefined,
    Object? gt = _undefined,
    Object? gte = _undefined,
    Object? $in = _undefined,
    Object? lt = _undefined,
    Object? lte = _undefined,
    Object? mode = _undefined,
    Object? not = _undefined,
    Object? notIn = _undefined,
  }) =>
      _then(Input$UuidFilter._({
        ..._instance._$data,
        if (equals != _undefined) 'equals': (equals as String?),
        if (gt != _undefined) 'gt': (gt as String?),
        if (gte != _undefined) 'gte': (gte as String?),
        if ($in != _undefined) 'in': ($in as List<String>?),
        if (lt != _undefined) 'lt': (lt as String?),
        if (lte != _undefined) 'lte': (lte as String?),
        if (mode != _undefined) 'mode': (mode as Enum$QueryMode?),
        if (not != _undefined) 'not': (not as Input$NestedUuidFilter?),
        if (notIn != _undefined) 'notIn': (notIn as List<String>?),
      }));

  CopyWith$Input$NestedUuidFilter<TRes> get not {
    final local$not = _instance.not;
    return local$not == null
        ? CopyWith$Input$NestedUuidFilter.stub(_then(_instance))
        : CopyWith$Input$NestedUuidFilter(local$not, (e) => call(not: e));
  }
}

class _CopyWithStubImpl$Input$UuidFilter<TRes>
    implements CopyWith$Input$UuidFilter<TRes> {
  _CopyWithStubImpl$Input$UuidFilter(this._res);

  TRes _res;

  call({
    String? equals,
    String? gt,
    String? gte,
    List<String>? $in,
    String? lt,
    String? lte,
    Enum$QueryMode? mode,
    Input$NestedUuidFilter? not,
    List<String>? notIn,
  }) =>
      _res;

  CopyWith$Input$NestedUuidFilter<TRes> get not =>
      CopyWith$Input$NestedUuidFilter.stub(_res);
}

class Input$UuidNullableFilter {
  factory Input$UuidNullableFilter({
    String? equals,
    String? gt,
    String? gte,
    List<String>? $in,
    String? lt,
    String? lte,
    Enum$QueryMode? mode,
    Input$NestedUuidNullableFilter? not,
    List<String>? notIn,
  }) =>
      Input$UuidNullableFilter._({
        if (equals != null) r'equals': equals,
        if (gt != null) r'gt': gt,
        if (gte != null) r'gte': gte,
        if ($in != null) r'in': $in,
        if (lt != null) r'lt': lt,
        if (lte != null) r'lte': lte,
        if (mode != null) r'mode': mode,
        if (not != null) r'not': not,
        if (notIn != null) r'notIn': notIn,
      });

  Input$UuidNullableFilter._(this._$data);

  factory Input$UuidNullableFilter.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('equals')) {
      final l$equals = data['equals'];
      result$data['equals'] = (l$equals as String?);
    }
    if (data.containsKey('gt')) {
      final l$gt = data['gt'];
      result$data['gt'] = (l$gt as String?);
    }
    if (data.containsKey('gte')) {
      final l$gte = data['gte'];
      result$data['gte'] = (l$gte as String?);
    }
    if (data.containsKey('in')) {
      final l$$in = data['in'];
      result$data['in'] =
          (l$$in as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    if (data.containsKey('lt')) {
      final l$lt = data['lt'];
      result$data['lt'] = (l$lt as String?);
    }
    if (data.containsKey('lte')) {
      final l$lte = data['lte'];
      result$data['lte'] = (l$lte as String?);
    }
    if (data.containsKey('mode')) {
      final l$mode = data['mode'];
      result$data['mode'] =
          l$mode == null ? null : fromJson$Enum$QueryMode((l$mode as String));
    }
    if (data.containsKey('not')) {
      final l$not = data['not'];
      result$data['not'] = l$not == null
          ? null
          : Input$NestedUuidNullableFilter.fromJson(
              (l$not as Map<String, dynamic>));
    }
    if (data.containsKey('notIn')) {
      final l$notIn = data['notIn'];
      result$data['notIn'] =
          (l$notIn as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    return Input$UuidNullableFilter._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get equals => (_$data['equals'] as String?);

  String? get gt => (_$data['gt'] as String?);

  String? get gte => (_$data['gte'] as String?);

  List<String>? get $in => (_$data['in'] as List<String>?);

  String? get lt => (_$data['lt'] as String?);

  String? get lte => (_$data['lte'] as String?);

  Enum$QueryMode? get mode => (_$data['mode'] as Enum$QueryMode?);

  Input$NestedUuidNullableFilter? get not =>
      (_$data['not'] as Input$NestedUuidNullableFilter?);

  List<String>? get notIn => (_$data['notIn'] as List<String>?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('equals')) {
      final l$equals = equals;
      result$data['equals'] = l$equals;
    }
    if (_$data.containsKey('gt')) {
      final l$gt = gt;
      result$data['gt'] = l$gt;
    }
    if (_$data.containsKey('gte')) {
      final l$gte = gte;
      result$data['gte'] = l$gte;
    }
    if (_$data.containsKey('in')) {
      final l$$in = $in;
      result$data['in'] = l$$in?.map((e) => e).toList();
    }
    if (_$data.containsKey('lt')) {
      final l$lt = lt;
      result$data['lt'] = l$lt;
    }
    if (_$data.containsKey('lte')) {
      final l$lte = lte;
      result$data['lte'] = l$lte;
    }
    if (_$data.containsKey('mode')) {
      final l$mode = mode;
      result$data['mode'] =
          l$mode == null ? null : toJson$Enum$QueryMode(l$mode);
    }
    if (_$data.containsKey('not')) {
      final l$not = not;
      result$data['not'] = l$not?.toJson();
    }
    if (_$data.containsKey('notIn')) {
      final l$notIn = notIn;
      result$data['notIn'] = l$notIn?.map((e) => e).toList();
    }
    return result$data;
  }

  CopyWith$Input$UuidNullableFilter<Input$UuidNullableFilter> get copyWith =>
      CopyWith$Input$UuidNullableFilter(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$UuidNullableFilter) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$equals = equals;
    final lOther$equals = other.equals;
    if (_$data.containsKey('equals') != other._$data.containsKey('equals')) {
      return false;
    }
    if (l$equals != lOther$equals) {
      return false;
    }
    final l$gt = gt;
    final lOther$gt = other.gt;
    if (_$data.containsKey('gt') != other._$data.containsKey('gt')) {
      return false;
    }
    if (l$gt != lOther$gt) {
      return false;
    }
    final l$gte = gte;
    final lOther$gte = other.gte;
    if (_$data.containsKey('gte') != other._$data.containsKey('gte')) {
      return false;
    }
    if (l$gte != lOther$gte) {
      return false;
    }
    final l$$in = $in;
    final lOther$$in = other.$in;
    if (_$data.containsKey('in') != other._$data.containsKey('in')) {
      return false;
    }
    if (l$$in != null && lOther$$in != null) {
      if (l$$in.length != lOther$$in.length) {
        return false;
      }
      for (int i = 0; i < l$$in.length; i++) {
        final l$$in$entry = l$$in[i];
        final lOther$$in$entry = lOther$$in[i];
        if (l$$in$entry != lOther$$in$entry) {
          return false;
        }
      }
    } else if (l$$in != lOther$$in) {
      return false;
    }
    final l$lt = lt;
    final lOther$lt = other.lt;
    if (_$data.containsKey('lt') != other._$data.containsKey('lt')) {
      return false;
    }
    if (l$lt != lOther$lt) {
      return false;
    }
    final l$lte = lte;
    final lOther$lte = other.lte;
    if (_$data.containsKey('lte') != other._$data.containsKey('lte')) {
      return false;
    }
    if (l$lte != lOther$lte) {
      return false;
    }
    final l$mode = mode;
    final lOther$mode = other.mode;
    if (_$data.containsKey('mode') != other._$data.containsKey('mode')) {
      return false;
    }
    if (l$mode != lOther$mode) {
      return false;
    }
    final l$not = not;
    final lOther$not = other.not;
    if (_$data.containsKey('not') != other._$data.containsKey('not')) {
      return false;
    }
    if (l$not != lOther$not) {
      return false;
    }
    final l$notIn = notIn;
    final lOther$notIn = other.notIn;
    if (_$data.containsKey('notIn') != other._$data.containsKey('notIn')) {
      return false;
    }
    if (l$notIn != null && lOther$notIn != null) {
      if (l$notIn.length != lOther$notIn.length) {
        return false;
      }
      for (int i = 0; i < l$notIn.length; i++) {
        final l$notIn$entry = l$notIn[i];
        final lOther$notIn$entry = lOther$notIn[i];
        if (l$notIn$entry != lOther$notIn$entry) {
          return false;
        }
      }
    } else if (l$notIn != lOther$notIn) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$equals = equals;
    final l$gt = gt;
    final l$gte = gte;
    final l$$in = $in;
    final l$lt = lt;
    final l$lte = lte;
    final l$mode = mode;
    final l$not = not;
    final l$notIn = notIn;
    return Object.hashAll([
      _$data.containsKey('equals') ? l$equals : const {},
      _$data.containsKey('gt') ? l$gt : const {},
      _$data.containsKey('gte') ? l$gte : const {},
      _$data.containsKey('in')
          ? l$$in == null
              ? null
              : Object.hashAll(l$$in.map((v) => v))
          : const {},
      _$data.containsKey('lt') ? l$lt : const {},
      _$data.containsKey('lte') ? l$lte : const {},
      _$data.containsKey('mode') ? l$mode : const {},
      _$data.containsKey('not') ? l$not : const {},
      _$data.containsKey('notIn')
          ? l$notIn == null
              ? null
              : Object.hashAll(l$notIn.map((v) => v))
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$UuidNullableFilter<TRes> {
  factory CopyWith$Input$UuidNullableFilter(
    Input$UuidNullableFilter instance,
    TRes Function(Input$UuidNullableFilter) then,
  ) = _CopyWithImpl$Input$UuidNullableFilter;

  factory CopyWith$Input$UuidNullableFilter.stub(TRes res) =
      _CopyWithStubImpl$Input$UuidNullableFilter;

  TRes call({
    String? equals,
    String? gt,
    String? gte,
    List<String>? $in,
    String? lt,
    String? lte,
    Enum$QueryMode? mode,
    Input$NestedUuidNullableFilter? not,
    List<String>? notIn,
  });
  CopyWith$Input$NestedUuidNullableFilter<TRes> get not;
}

class _CopyWithImpl$Input$UuidNullableFilter<TRes>
    implements CopyWith$Input$UuidNullableFilter<TRes> {
  _CopyWithImpl$Input$UuidNullableFilter(
    this._instance,
    this._then,
  );

  final Input$UuidNullableFilter _instance;

  final TRes Function(Input$UuidNullableFilter) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? equals = _undefined,
    Object? gt = _undefined,
    Object? gte = _undefined,
    Object? $in = _undefined,
    Object? lt = _undefined,
    Object? lte = _undefined,
    Object? mode = _undefined,
    Object? not = _undefined,
    Object? notIn = _undefined,
  }) =>
      _then(Input$UuidNullableFilter._({
        ..._instance._$data,
        if (equals != _undefined) 'equals': (equals as String?),
        if (gt != _undefined) 'gt': (gt as String?),
        if (gte != _undefined) 'gte': (gte as String?),
        if ($in != _undefined) 'in': ($in as List<String>?),
        if (lt != _undefined) 'lt': (lt as String?),
        if (lte != _undefined) 'lte': (lte as String?),
        if (mode != _undefined) 'mode': (mode as Enum$QueryMode?),
        if (not != _undefined) 'not': (not as Input$NestedUuidNullableFilter?),
        if (notIn != _undefined) 'notIn': (notIn as List<String>?),
      }));

  CopyWith$Input$NestedUuidNullableFilter<TRes> get not {
    final local$not = _instance.not;
    return local$not == null
        ? CopyWith$Input$NestedUuidNullableFilter.stub(_then(_instance))
        : CopyWith$Input$NestedUuidNullableFilter(
            local$not, (e) => call(not: e));
  }
}

class _CopyWithStubImpl$Input$UuidNullableFilter<TRes>
    implements CopyWith$Input$UuidNullableFilter<TRes> {
  _CopyWithStubImpl$Input$UuidNullableFilter(this._res);

  TRes _res;

  call({
    String? equals,
    String? gt,
    String? gte,
    List<String>? $in,
    String? lt,
    String? lte,
    Enum$QueryMode? mode,
    Input$NestedUuidNullableFilter? not,
    List<String>? notIn,
  }) =>
      _res;

  CopyWith$Input$NestedUuidNullableFilter<TRes> get not =>
      CopyWith$Input$NestedUuidNullableFilter.stub(_res);
}

class Input$UuidNullableWithAggregatesFilter {
  factory Input$UuidNullableWithAggregatesFilter({
    Input$NestedIntNullableFilter? $_count,
    Input$NestedStringNullableFilter? $_max,
    Input$NestedStringNullableFilter? $_min,
    String? equals,
    String? gt,
    String? gte,
    List<String>? $in,
    String? lt,
    String? lte,
    Enum$QueryMode? mode,
    Input$NestedUuidNullableWithAggregatesFilter? not,
    List<String>? notIn,
  }) =>
      Input$UuidNullableWithAggregatesFilter._({
        if ($_count != null) r'_count': $_count,
        if ($_max != null) r'_max': $_max,
        if ($_min != null) r'_min': $_min,
        if (equals != null) r'equals': equals,
        if (gt != null) r'gt': gt,
        if (gte != null) r'gte': gte,
        if ($in != null) r'in': $in,
        if (lt != null) r'lt': lt,
        if (lte != null) r'lte': lte,
        if (mode != null) r'mode': mode,
        if (not != null) r'not': not,
        if (notIn != null) r'notIn': notIn,
      });

  Input$UuidNullableWithAggregatesFilter._(this._$data);

  factory Input$UuidNullableWithAggregatesFilter.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('_count')) {
      final l$$_count = data['_count'];
      result$data['_count'] = l$$_count == null
          ? null
          : Input$NestedIntNullableFilter.fromJson(
              (l$$_count as Map<String, dynamic>));
    }
    if (data.containsKey('_max')) {
      final l$$_max = data['_max'];
      result$data['_max'] = l$$_max == null
          ? null
          : Input$NestedStringNullableFilter.fromJson(
              (l$$_max as Map<String, dynamic>));
    }
    if (data.containsKey('_min')) {
      final l$$_min = data['_min'];
      result$data['_min'] = l$$_min == null
          ? null
          : Input$NestedStringNullableFilter.fromJson(
              (l$$_min as Map<String, dynamic>));
    }
    if (data.containsKey('equals')) {
      final l$equals = data['equals'];
      result$data['equals'] = (l$equals as String?);
    }
    if (data.containsKey('gt')) {
      final l$gt = data['gt'];
      result$data['gt'] = (l$gt as String?);
    }
    if (data.containsKey('gte')) {
      final l$gte = data['gte'];
      result$data['gte'] = (l$gte as String?);
    }
    if (data.containsKey('in')) {
      final l$$in = data['in'];
      result$data['in'] =
          (l$$in as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    if (data.containsKey('lt')) {
      final l$lt = data['lt'];
      result$data['lt'] = (l$lt as String?);
    }
    if (data.containsKey('lte')) {
      final l$lte = data['lte'];
      result$data['lte'] = (l$lte as String?);
    }
    if (data.containsKey('mode')) {
      final l$mode = data['mode'];
      result$data['mode'] =
          l$mode == null ? null : fromJson$Enum$QueryMode((l$mode as String));
    }
    if (data.containsKey('not')) {
      final l$not = data['not'];
      result$data['not'] = l$not == null
          ? null
          : Input$NestedUuidNullableWithAggregatesFilter.fromJson(
              (l$not as Map<String, dynamic>));
    }
    if (data.containsKey('notIn')) {
      final l$notIn = data['notIn'];
      result$data['notIn'] =
          (l$notIn as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    return Input$UuidNullableWithAggregatesFilter._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$NestedIntNullableFilter? get $_count =>
      (_$data['_count'] as Input$NestedIntNullableFilter?);

  Input$NestedStringNullableFilter? get $_max =>
      (_$data['_max'] as Input$NestedStringNullableFilter?);

  Input$NestedStringNullableFilter? get $_min =>
      (_$data['_min'] as Input$NestedStringNullableFilter?);

  String? get equals => (_$data['equals'] as String?);

  String? get gt => (_$data['gt'] as String?);

  String? get gte => (_$data['gte'] as String?);

  List<String>? get $in => (_$data['in'] as List<String>?);

  String? get lt => (_$data['lt'] as String?);

  String? get lte => (_$data['lte'] as String?);

  Enum$QueryMode? get mode => (_$data['mode'] as Enum$QueryMode?);

  Input$NestedUuidNullableWithAggregatesFilter? get not =>
      (_$data['not'] as Input$NestedUuidNullableWithAggregatesFilter?);

  List<String>? get notIn => (_$data['notIn'] as List<String>?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('_count')) {
      final l$$_count = $_count;
      result$data['_count'] = l$$_count?.toJson();
    }
    if (_$data.containsKey('_max')) {
      final l$$_max = $_max;
      result$data['_max'] = l$$_max?.toJson();
    }
    if (_$data.containsKey('_min')) {
      final l$$_min = $_min;
      result$data['_min'] = l$$_min?.toJson();
    }
    if (_$data.containsKey('equals')) {
      final l$equals = equals;
      result$data['equals'] = l$equals;
    }
    if (_$data.containsKey('gt')) {
      final l$gt = gt;
      result$data['gt'] = l$gt;
    }
    if (_$data.containsKey('gte')) {
      final l$gte = gte;
      result$data['gte'] = l$gte;
    }
    if (_$data.containsKey('in')) {
      final l$$in = $in;
      result$data['in'] = l$$in?.map((e) => e).toList();
    }
    if (_$data.containsKey('lt')) {
      final l$lt = lt;
      result$data['lt'] = l$lt;
    }
    if (_$data.containsKey('lte')) {
      final l$lte = lte;
      result$data['lte'] = l$lte;
    }
    if (_$data.containsKey('mode')) {
      final l$mode = mode;
      result$data['mode'] =
          l$mode == null ? null : toJson$Enum$QueryMode(l$mode);
    }
    if (_$data.containsKey('not')) {
      final l$not = not;
      result$data['not'] = l$not?.toJson();
    }
    if (_$data.containsKey('notIn')) {
      final l$notIn = notIn;
      result$data['notIn'] = l$notIn?.map((e) => e).toList();
    }
    return result$data;
  }

  CopyWith$Input$UuidNullableWithAggregatesFilter<
          Input$UuidNullableWithAggregatesFilter>
      get copyWith => CopyWith$Input$UuidNullableWithAggregatesFilter(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$UuidNullableWithAggregatesFilter) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$$_count = $_count;
    final lOther$$_count = other.$_count;
    if (_$data.containsKey('_count') != other._$data.containsKey('_count')) {
      return false;
    }
    if (l$$_count != lOther$$_count) {
      return false;
    }
    final l$$_max = $_max;
    final lOther$$_max = other.$_max;
    if (_$data.containsKey('_max') != other._$data.containsKey('_max')) {
      return false;
    }
    if (l$$_max != lOther$$_max) {
      return false;
    }
    final l$$_min = $_min;
    final lOther$$_min = other.$_min;
    if (_$data.containsKey('_min') != other._$data.containsKey('_min')) {
      return false;
    }
    if (l$$_min != lOther$$_min) {
      return false;
    }
    final l$equals = equals;
    final lOther$equals = other.equals;
    if (_$data.containsKey('equals') != other._$data.containsKey('equals')) {
      return false;
    }
    if (l$equals != lOther$equals) {
      return false;
    }
    final l$gt = gt;
    final lOther$gt = other.gt;
    if (_$data.containsKey('gt') != other._$data.containsKey('gt')) {
      return false;
    }
    if (l$gt != lOther$gt) {
      return false;
    }
    final l$gte = gte;
    final lOther$gte = other.gte;
    if (_$data.containsKey('gte') != other._$data.containsKey('gte')) {
      return false;
    }
    if (l$gte != lOther$gte) {
      return false;
    }
    final l$$in = $in;
    final lOther$$in = other.$in;
    if (_$data.containsKey('in') != other._$data.containsKey('in')) {
      return false;
    }
    if (l$$in != null && lOther$$in != null) {
      if (l$$in.length != lOther$$in.length) {
        return false;
      }
      for (int i = 0; i < l$$in.length; i++) {
        final l$$in$entry = l$$in[i];
        final lOther$$in$entry = lOther$$in[i];
        if (l$$in$entry != lOther$$in$entry) {
          return false;
        }
      }
    } else if (l$$in != lOther$$in) {
      return false;
    }
    final l$lt = lt;
    final lOther$lt = other.lt;
    if (_$data.containsKey('lt') != other._$data.containsKey('lt')) {
      return false;
    }
    if (l$lt != lOther$lt) {
      return false;
    }
    final l$lte = lte;
    final lOther$lte = other.lte;
    if (_$data.containsKey('lte') != other._$data.containsKey('lte')) {
      return false;
    }
    if (l$lte != lOther$lte) {
      return false;
    }
    final l$mode = mode;
    final lOther$mode = other.mode;
    if (_$data.containsKey('mode') != other._$data.containsKey('mode')) {
      return false;
    }
    if (l$mode != lOther$mode) {
      return false;
    }
    final l$not = not;
    final lOther$not = other.not;
    if (_$data.containsKey('not') != other._$data.containsKey('not')) {
      return false;
    }
    if (l$not != lOther$not) {
      return false;
    }
    final l$notIn = notIn;
    final lOther$notIn = other.notIn;
    if (_$data.containsKey('notIn') != other._$data.containsKey('notIn')) {
      return false;
    }
    if (l$notIn != null && lOther$notIn != null) {
      if (l$notIn.length != lOther$notIn.length) {
        return false;
      }
      for (int i = 0; i < l$notIn.length; i++) {
        final l$notIn$entry = l$notIn[i];
        final lOther$notIn$entry = lOther$notIn[i];
        if (l$notIn$entry != lOther$notIn$entry) {
          return false;
        }
      }
    } else if (l$notIn != lOther$notIn) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$$_count = $_count;
    final l$$_max = $_max;
    final l$$_min = $_min;
    final l$equals = equals;
    final l$gt = gt;
    final l$gte = gte;
    final l$$in = $in;
    final l$lt = lt;
    final l$lte = lte;
    final l$mode = mode;
    final l$not = not;
    final l$notIn = notIn;
    return Object.hashAll([
      _$data.containsKey('_count') ? l$$_count : const {},
      _$data.containsKey('_max') ? l$$_max : const {},
      _$data.containsKey('_min') ? l$$_min : const {},
      _$data.containsKey('equals') ? l$equals : const {},
      _$data.containsKey('gt') ? l$gt : const {},
      _$data.containsKey('gte') ? l$gte : const {},
      _$data.containsKey('in')
          ? l$$in == null
              ? null
              : Object.hashAll(l$$in.map((v) => v))
          : const {},
      _$data.containsKey('lt') ? l$lt : const {},
      _$data.containsKey('lte') ? l$lte : const {},
      _$data.containsKey('mode') ? l$mode : const {},
      _$data.containsKey('not') ? l$not : const {},
      _$data.containsKey('notIn')
          ? l$notIn == null
              ? null
              : Object.hashAll(l$notIn.map((v) => v))
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$UuidNullableWithAggregatesFilter<TRes> {
  factory CopyWith$Input$UuidNullableWithAggregatesFilter(
    Input$UuidNullableWithAggregatesFilter instance,
    TRes Function(Input$UuidNullableWithAggregatesFilter) then,
  ) = _CopyWithImpl$Input$UuidNullableWithAggregatesFilter;

  factory CopyWith$Input$UuidNullableWithAggregatesFilter.stub(TRes res) =
      _CopyWithStubImpl$Input$UuidNullableWithAggregatesFilter;

  TRes call({
    Input$NestedIntNullableFilter? $_count,
    Input$NestedStringNullableFilter? $_max,
    Input$NestedStringNullableFilter? $_min,
    String? equals,
    String? gt,
    String? gte,
    List<String>? $in,
    String? lt,
    String? lte,
    Enum$QueryMode? mode,
    Input$NestedUuidNullableWithAggregatesFilter? not,
    List<String>? notIn,
  });
  CopyWith$Input$NestedIntNullableFilter<TRes> get $_count;
  CopyWith$Input$NestedStringNullableFilter<TRes> get $_max;
  CopyWith$Input$NestedStringNullableFilter<TRes> get $_min;
  CopyWith$Input$NestedUuidNullableWithAggregatesFilter<TRes> get not;
}

class _CopyWithImpl$Input$UuidNullableWithAggregatesFilter<TRes>
    implements CopyWith$Input$UuidNullableWithAggregatesFilter<TRes> {
  _CopyWithImpl$Input$UuidNullableWithAggregatesFilter(
    this._instance,
    this._then,
  );

  final Input$UuidNullableWithAggregatesFilter _instance;

  final TRes Function(Input$UuidNullableWithAggregatesFilter) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? $_count = _undefined,
    Object? $_max = _undefined,
    Object? $_min = _undefined,
    Object? equals = _undefined,
    Object? gt = _undefined,
    Object? gte = _undefined,
    Object? $in = _undefined,
    Object? lt = _undefined,
    Object? lte = _undefined,
    Object? mode = _undefined,
    Object? not = _undefined,
    Object? notIn = _undefined,
  }) =>
      _then(Input$UuidNullableWithAggregatesFilter._({
        ..._instance._$data,
        if ($_count != _undefined)
          '_count': ($_count as Input$NestedIntNullableFilter?),
        if ($_max != _undefined)
          '_max': ($_max as Input$NestedStringNullableFilter?),
        if ($_min != _undefined)
          '_min': ($_min as Input$NestedStringNullableFilter?),
        if (equals != _undefined) 'equals': (equals as String?),
        if (gt != _undefined) 'gt': (gt as String?),
        if (gte != _undefined) 'gte': (gte as String?),
        if ($in != _undefined) 'in': ($in as List<String>?),
        if (lt != _undefined) 'lt': (lt as String?),
        if (lte != _undefined) 'lte': (lte as String?),
        if (mode != _undefined) 'mode': (mode as Enum$QueryMode?),
        if (not != _undefined)
          'not': (not as Input$NestedUuidNullableWithAggregatesFilter?),
        if (notIn != _undefined) 'notIn': (notIn as List<String>?),
      }));

  CopyWith$Input$NestedIntNullableFilter<TRes> get $_count {
    final local$$_count = _instance.$_count;
    return local$$_count == null
        ? CopyWith$Input$NestedIntNullableFilter.stub(_then(_instance))
        : CopyWith$Input$NestedIntNullableFilter(
            local$$_count, (e) => call($_count: e));
  }

  CopyWith$Input$NestedStringNullableFilter<TRes> get $_max {
    final local$$_max = _instance.$_max;
    return local$$_max == null
        ? CopyWith$Input$NestedStringNullableFilter.stub(_then(_instance))
        : CopyWith$Input$NestedStringNullableFilter(
            local$$_max, (e) => call($_max: e));
  }

  CopyWith$Input$NestedStringNullableFilter<TRes> get $_min {
    final local$$_min = _instance.$_min;
    return local$$_min == null
        ? CopyWith$Input$NestedStringNullableFilter.stub(_then(_instance))
        : CopyWith$Input$NestedStringNullableFilter(
            local$$_min, (e) => call($_min: e));
  }

  CopyWith$Input$NestedUuidNullableWithAggregatesFilter<TRes> get not {
    final local$not = _instance.not;
    return local$not == null
        ? CopyWith$Input$NestedUuidNullableWithAggregatesFilter.stub(
            _then(_instance))
        : CopyWith$Input$NestedUuidNullableWithAggregatesFilter(
            local$not, (e) => call(not: e));
  }
}

class _CopyWithStubImpl$Input$UuidNullableWithAggregatesFilter<TRes>
    implements CopyWith$Input$UuidNullableWithAggregatesFilter<TRes> {
  _CopyWithStubImpl$Input$UuidNullableWithAggregatesFilter(this._res);

  TRes _res;

  call({
    Input$NestedIntNullableFilter? $_count,
    Input$NestedStringNullableFilter? $_max,
    Input$NestedStringNullableFilter? $_min,
    String? equals,
    String? gt,
    String? gte,
    List<String>? $in,
    String? lt,
    String? lte,
    Enum$QueryMode? mode,
    Input$NestedUuidNullableWithAggregatesFilter? not,
    List<String>? notIn,
  }) =>
      _res;

  CopyWith$Input$NestedIntNullableFilter<TRes> get $_count =>
      CopyWith$Input$NestedIntNullableFilter.stub(_res);

  CopyWith$Input$NestedStringNullableFilter<TRes> get $_max =>
      CopyWith$Input$NestedStringNullableFilter.stub(_res);

  CopyWith$Input$NestedStringNullableFilter<TRes> get $_min =>
      CopyWith$Input$NestedStringNullableFilter.stub(_res);

  CopyWith$Input$NestedUuidNullableWithAggregatesFilter<TRes> get not =>
      CopyWith$Input$NestedUuidNullableWithAggregatesFilter.stub(_res);
}

class Input$UuidWithAggregatesFilter {
  factory Input$UuidWithAggregatesFilter({
    Input$NestedIntFilter? $_count,
    Input$NestedStringFilter? $_max,
    Input$NestedStringFilter? $_min,
    String? equals,
    String? gt,
    String? gte,
    List<String>? $in,
    String? lt,
    String? lte,
    Enum$QueryMode? mode,
    Input$NestedUuidWithAggregatesFilter? not,
    List<String>? notIn,
  }) =>
      Input$UuidWithAggregatesFilter._({
        if ($_count != null) r'_count': $_count,
        if ($_max != null) r'_max': $_max,
        if ($_min != null) r'_min': $_min,
        if (equals != null) r'equals': equals,
        if (gt != null) r'gt': gt,
        if (gte != null) r'gte': gte,
        if ($in != null) r'in': $in,
        if (lt != null) r'lt': lt,
        if (lte != null) r'lte': lte,
        if (mode != null) r'mode': mode,
        if (not != null) r'not': not,
        if (notIn != null) r'notIn': notIn,
      });

  Input$UuidWithAggregatesFilter._(this._$data);

  factory Input$UuidWithAggregatesFilter.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('_count')) {
      final l$$_count = data['_count'];
      result$data['_count'] = l$$_count == null
          ? null
          : Input$NestedIntFilter.fromJson((l$$_count as Map<String, dynamic>));
    }
    if (data.containsKey('_max')) {
      final l$$_max = data['_max'];
      result$data['_max'] = l$$_max == null
          ? null
          : Input$NestedStringFilter.fromJson(
              (l$$_max as Map<String, dynamic>));
    }
    if (data.containsKey('_min')) {
      final l$$_min = data['_min'];
      result$data['_min'] = l$$_min == null
          ? null
          : Input$NestedStringFilter.fromJson(
              (l$$_min as Map<String, dynamic>));
    }
    if (data.containsKey('equals')) {
      final l$equals = data['equals'];
      result$data['equals'] = (l$equals as String?);
    }
    if (data.containsKey('gt')) {
      final l$gt = data['gt'];
      result$data['gt'] = (l$gt as String?);
    }
    if (data.containsKey('gte')) {
      final l$gte = data['gte'];
      result$data['gte'] = (l$gte as String?);
    }
    if (data.containsKey('in')) {
      final l$$in = data['in'];
      result$data['in'] =
          (l$$in as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    if (data.containsKey('lt')) {
      final l$lt = data['lt'];
      result$data['lt'] = (l$lt as String?);
    }
    if (data.containsKey('lte')) {
      final l$lte = data['lte'];
      result$data['lte'] = (l$lte as String?);
    }
    if (data.containsKey('mode')) {
      final l$mode = data['mode'];
      result$data['mode'] =
          l$mode == null ? null : fromJson$Enum$QueryMode((l$mode as String));
    }
    if (data.containsKey('not')) {
      final l$not = data['not'];
      result$data['not'] = l$not == null
          ? null
          : Input$NestedUuidWithAggregatesFilter.fromJson(
              (l$not as Map<String, dynamic>));
    }
    if (data.containsKey('notIn')) {
      final l$notIn = data['notIn'];
      result$data['notIn'] =
          (l$notIn as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    return Input$UuidWithAggregatesFilter._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$NestedIntFilter? get $_count =>
      (_$data['_count'] as Input$NestedIntFilter?);

  Input$NestedStringFilter? get $_max =>
      (_$data['_max'] as Input$NestedStringFilter?);

  Input$NestedStringFilter? get $_min =>
      (_$data['_min'] as Input$NestedStringFilter?);

  String? get equals => (_$data['equals'] as String?);

  String? get gt => (_$data['gt'] as String?);

  String? get gte => (_$data['gte'] as String?);

  List<String>? get $in => (_$data['in'] as List<String>?);

  String? get lt => (_$data['lt'] as String?);

  String? get lte => (_$data['lte'] as String?);

  Enum$QueryMode? get mode => (_$data['mode'] as Enum$QueryMode?);

  Input$NestedUuidWithAggregatesFilter? get not =>
      (_$data['not'] as Input$NestedUuidWithAggregatesFilter?);

  List<String>? get notIn => (_$data['notIn'] as List<String>?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('_count')) {
      final l$$_count = $_count;
      result$data['_count'] = l$$_count?.toJson();
    }
    if (_$data.containsKey('_max')) {
      final l$$_max = $_max;
      result$data['_max'] = l$$_max?.toJson();
    }
    if (_$data.containsKey('_min')) {
      final l$$_min = $_min;
      result$data['_min'] = l$$_min?.toJson();
    }
    if (_$data.containsKey('equals')) {
      final l$equals = equals;
      result$data['equals'] = l$equals;
    }
    if (_$data.containsKey('gt')) {
      final l$gt = gt;
      result$data['gt'] = l$gt;
    }
    if (_$data.containsKey('gte')) {
      final l$gte = gte;
      result$data['gte'] = l$gte;
    }
    if (_$data.containsKey('in')) {
      final l$$in = $in;
      result$data['in'] = l$$in?.map((e) => e).toList();
    }
    if (_$data.containsKey('lt')) {
      final l$lt = lt;
      result$data['lt'] = l$lt;
    }
    if (_$data.containsKey('lte')) {
      final l$lte = lte;
      result$data['lte'] = l$lte;
    }
    if (_$data.containsKey('mode')) {
      final l$mode = mode;
      result$data['mode'] =
          l$mode == null ? null : toJson$Enum$QueryMode(l$mode);
    }
    if (_$data.containsKey('not')) {
      final l$not = not;
      result$data['not'] = l$not?.toJson();
    }
    if (_$data.containsKey('notIn')) {
      final l$notIn = notIn;
      result$data['notIn'] = l$notIn?.map((e) => e).toList();
    }
    return result$data;
  }

  CopyWith$Input$UuidWithAggregatesFilter<Input$UuidWithAggregatesFilter>
      get copyWith => CopyWith$Input$UuidWithAggregatesFilter(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$UuidWithAggregatesFilter) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$$_count = $_count;
    final lOther$$_count = other.$_count;
    if (_$data.containsKey('_count') != other._$data.containsKey('_count')) {
      return false;
    }
    if (l$$_count != lOther$$_count) {
      return false;
    }
    final l$$_max = $_max;
    final lOther$$_max = other.$_max;
    if (_$data.containsKey('_max') != other._$data.containsKey('_max')) {
      return false;
    }
    if (l$$_max != lOther$$_max) {
      return false;
    }
    final l$$_min = $_min;
    final lOther$$_min = other.$_min;
    if (_$data.containsKey('_min') != other._$data.containsKey('_min')) {
      return false;
    }
    if (l$$_min != lOther$$_min) {
      return false;
    }
    final l$equals = equals;
    final lOther$equals = other.equals;
    if (_$data.containsKey('equals') != other._$data.containsKey('equals')) {
      return false;
    }
    if (l$equals != lOther$equals) {
      return false;
    }
    final l$gt = gt;
    final lOther$gt = other.gt;
    if (_$data.containsKey('gt') != other._$data.containsKey('gt')) {
      return false;
    }
    if (l$gt != lOther$gt) {
      return false;
    }
    final l$gte = gte;
    final lOther$gte = other.gte;
    if (_$data.containsKey('gte') != other._$data.containsKey('gte')) {
      return false;
    }
    if (l$gte != lOther$gte) {
      return false;
    }
    final l$$in = $in;
    final lOther$$in = other.$in;
    if (_$data.containsKey('in') != other._$data.containsKey('in')) {
      return false;
    }
    if (l$$in != null && lOther$$in != null) {
      if (l$$in.length != lOther$$in.length) {
        return false;
      }
      for (int i = 0; i < l$$in.length; i++) {
        final l$$in$entry = l$$in[i];
        final lOther$$in$entry = lOther$$in[i];
        if (l$$in$entry != lOther$$in$entry) {
          return false;
        }
      }
    } else if (l$$in != lOther$$in) {
      return false;
    }
    final l$lt = lt;
    final lOther$lt = other.lt;
    if (_$data.containsKey('lt') != other._$data.containsKey('lt')) {
      return false;
    }
    if (l$lt != lOther$lt) {
      return false;
    }
    final l$lte = lte;
    final lOther$lte = other.lte;
    if (_$data.containsKey('lte') != other._$data.containsKey('lte')) {
      return false;
    }
    if (l$lte != lOther$lte) {
      return false;
    }
    final l$mode = mode;
    final lOther$mode = other.mode;
    if (_$data.containsKey('mode') != other._$data.containsKey('mode')) {
      return false;
    }
    if (l$mode != lOther$mode) {
      return false;
    }
    final l$not = not;
    final lOther$not = other.not;
    if (_$data.containsKey('not') != other._$data.containsKey('not')) {
      return false;
    }
    if (l$not != lOther$not) {
      return false;
    }
    final l$notIn = notIn;
    final lOther$notIn = other.notIn;
    if (_$data.containsKey('notIn') != other._$data.containsKey('notIn')) {
      return false;
    }
    if (l$notIn != null && lOther$notIn != null) {
      if (l$notIn.length != lOther$notIn.length) {
        return false;
      }
      for (int i = 0; i < l$notIn.length; i++) {
        final l$notIn$entry = l$notIn[i];
        final lOther$notIn$entry = lOther$notIn[i];
        if (l$notIn$entry != lOther$notIn$entry) {
          return false;
        }
      }
    } else if (l$notIn != lOther$notIn) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$$_count = $_count;
    final l$$_max = $_max;
    final l$$_min = $_min;
    final l$equals = equals;
    final l$gt = gt;
    final l$gte = gte;
    final l$$in = $in;
    final l$lt = lt;
    final l$lte = lte;
    final l$mode = mode;
    final l$not = not;
    final l$notIn = notIn;
    return Object.hashAll([
      _$data.containsKey('_count') ? l$$_count : const {},
      _$data.containsKey('_max') ? l$$_max : const {},
      _$data.containsKey('_min') ? l$$_min : const {},
      _$data.containsKey('equals') ? l$equals : const {},
      _$data.containsKey('gt') ? l$gt : const {},
      _$data.containsKey('gte') ? l$gte : const {},
      _$data.containsKey('in')
          ? l$$in == null
              ? null
              : Object.hashAll(l$$in.map((v) => v))
          : const {},
      _$data.containsKey('lt') ? l$lt : const {},
      _$data.containsKey('lte') ? l$lte : const {},
      _$data.containsKey('mode') ? l$mode : const {},
      _$data.containsKey('not') ? l$not : const {},
      _$data.containsKey('notIn')
          ? l$notIn == null
              ? null
              : Object.hashAll(l$notIn.map((v) => v))
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$UuidWithAggregatesFilter<TRes> {
  factory CopyWith$Input$UuidWithAggregatesFilter(
    Input$UuidWithAggregatesFilter instance,
    TRes Function(Input$UuidWithAggregatesFilter) then,
  ) = _CopyWithImpl$Input$UuidWithAggregatesFilter;

  factory CopyWith$Input$UuidWithAggregatesFilter.stub(TRes res) =
      _CopyWithStubImpl$Input$UuidWithAggregatesFilter;

  TRes call({
    Input$NestedIntFilter? $_count,
    Input$NestedStringFilter? $_max,
    Input$NestedStringFilter? $_min,
    String? equals,
    String? gt,
    String? gte,
    List<String>? $in,
    String? lt,
    String? lte,
    Enum$QueryMode? mode,
    Input$NestedUuidWithAggregatesFilter? not,
    List<String>? notIn,
  });
  CopyWith$Input$NestedIntFilter<TRes> get $_count;
  CopyWith$Input$NestedStringFilter<TRes> get $_max;
  CopyWith$Input$NestedStringFilter<TRes> get $_min;
  CopyWith$Input$NestedUuidWithAggregatesFilter<TRes> get not;
}

class _CopyWithImpl$Input$UuidWithAggregatesFilter<TRes>
    implements CopyWith$Input$UuidWithAggregatesFilter<TRes> {
  _CopyWithImpl$Input$UuidWithAggregatesFilter(
    this._instance,
    this._then,
  );

  final Input$UuidWithAggregatesFilter _instance;

  final TRes Function(Input$UuidWithAggregatesFilter) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? $_count = _undefined,
    Object? $_max = _undefined,
    Object? $_min = _undefined,
    Object? equals = _undefined,
    Object? gt = _undefined,
    Object? gte = _undefined,
    Object? $in = _undefined,
    Object? lt = _undefined,
    Object? lte = _undefined,
    Object? mode = _undefined,
    Object? not = _undefined,
    Object? notIn = _undefined,
  }) =>
      _then(Input$UuidWithAggregatesFilter._({
        ..._instance._$data,
        if ($_count != _undefined)
          '_count': ($_count as Input$NestedIntFilter?),
        if ($_max != _undefined) '_max': ($_max as Input$NestedStringFilter?),
        if ($_min != _undefined) '_min': ($_min as Input$NestedStringFilter?),
        if (equals != _undefined) 'equals': (equals as String?),
        if (gt != _undefined) 'gt': (gt as String?),
        if (gte != _undefined) 'gte': (gte as String?),
        if ($in != _undefined) 'in': ($in as List<String>?),
        if (lt != _undefined) 'lt': (lt as String?),
        if (lte != _undefined) 'lte': (lte as String?),
        if (mode != _undefined) 'mode': (mode as Enum$QueryMode?),
        if (not != _undefined)
          'not': (not as Input$NestedUuidWithAggregatesFilter?),
        if (notIn != _undefined) 'notIn': (notIn as List<String>?),
      }));

  CopyWith$Input$NestedIntFilter<TRes> get $_count {
    final local$$_count = _instance.$_count;
    return local$$_count == null
        ? CopyWith$Input$NestedIntFilter.stub(_then(_instance))
        : CopyWith$Input$NestedIntFilter(
            local$$_count, (e) => call($_count: e));
  }

  CopyWith$Input$NestedStringFilter<TRes> get $_max {
    final local$$_max = _instance.$_max;
    return local$$_max == null
        ? CopyWith$Input$NestedStringFilter.stub(_then(_instance))
        : CopyWith$Input$NestedStringFilter(local$$_max, (e) => call($_max: e));
  }

  CopyWith$Input$NestedStringFilter<TRes> get $_min {
    final local$$_min = _instance.$_min;
    return local$$_min == null
        ? CopyWith$Input$NestedStringFilter.stub(_then(_instance))
        : CopyWith$Input$NestedStringFilter(local$$_min, (e) => call($_min: e));
  }

  CopyWith$Input$NestedUuidWithAggregatesFilter<TRes> get not {
    final local$not = _instance.not;
    return local$not == null
        ? CopyWith$Input$NestedUuidWithAggregatesFilter.stub(_then(_instance))
        : CopyWith$Input$NestedUuidWithAggregatesFilter(
            local$not, (e) => call(not: e));
  }
}

class _CopyWithStubImpl$Input$UuidWithAggregatesFilter<TRes>
    implements CopyWith$Input$UuidWithAggregatesFilter<TRes> {
  _CopyWithStubImpl$Input$UuidWithAggregatesFilter(this._res);

  TRes _res;

  call({
    Input$NestedIntFilter? $_count,
    Input$NestedStringFilter? $_max,
    Input$NestedStringFilter? $_min,
    String? equals,
    String? gt,
    String? gte,
    List<String>? $in,
    String? lt,
    String? lte,
    Enum$QueryMode? mode,
    Input$NestedUuidWithAggregatesFilter? not,
    List<String>? notIn,
  }) =>
      _res;

  CopyWith$Input$NestedIntFilter<TRes> get $_count =>
      CopyWith$Input$NestedIntFilter.stub(_res);

  CopyWith$Input$NestedStringFilter<TRes> get $_max =>
      CopyWith$Input$NestedStringFilter.stub(_res);

  CopyWith$Input$NestedStringFilter<TRes> get $_min =>
      CopyWith$Input$NestedStringFilter.stub(_res);

  CopyWith$Input$NestedUuidWithAggregatesFilter<TRes> get not =>
      CopyWith$Input$NestedUuidWithAggregatesFilter.stub(_res);
}

enum Enum$BookRevisionScalarFieldEnum {
  bookEditedId,
  bookRawId,
  completionTokens,
  content,
  createdAt,
  isRaw,
  model,
  promptTokens,
  raw,
  requestId,
  systemPrompt,
  totalTokens,
  updatedAt,
  userPrompt,
  uuid,
  $unknown
}

String toJson$Enum$BookRevisionScalarFieldEnum(
    Enum$BookRevisionScalarFieldEnum e) {
  switch (e) {
    case Enum$BookRevisionScalarFieldEnum.bookEditedId:
      return r'bookEditedId';
    case Enum$BookRevisionScalarFieldEnum.bookRawId:
      return r'bookRawId';
    case Enum$BookRevisionScalarFieldEnum.completionTokens:
      return r'completionTokens';
    case Enum$BookRevisionScalarFieldEnum.content:
      return r'content';
    case Enum$BookRevisionScalarFieldEnum.createdAt:
      return r'createdAt';
    case Enum$BookRevisionScalarFieldEnum.isRaw:
      return r'isRaw';
    case Enum$BookRevisionScalarFieldEnum.model:
      return r'model';
    case Enum$BookRevisionScalarFieldEnum.promptTokens:
      return r'promptTokens';
    case Enum$BookRevisionScalarFieldEnum.raw:
      return r'raw';
    case Enum$BookRevisionScalarFieldEnum.requestId:
      return r'requestId';
    case Enum$BookRevisionScalarFieldEnum.systemPrompt:
      return r'systemPrompt';
    case Enum$BookRevisionScalarFieldEnum.totalTokens:
      return r'totalTokens';
    case Enum$BookRevisionScalarFieldEnum.updatedAt:
      return r'updatedAt';
    case Enum$BookRevisionScalarFieldEnum.userPrompt:
      return r'userPrompt';
    case Enum$BookRevisionScalarFieldEnum.uuid:
      return r'uuid';
    case Enum$BookRevisionScalarFieldEnum.$unknown:
      return r'$unknown';
  }
}

Enum$BookRevisionScalarFieldEnum fromJson$Enum$BookRevisionScalarFieldEnum(
    String value) {
  switch (value) {
    case r'bookEditedId':
      return Enum$BookRevisionScalarFieldEnum.bookEditedId;
    case r'bookRawId':
      return Enum$BookRevisionScalarFieldEnum.bookRawId;
    case r'completionTokens':
      return Enum$BookRevisionScalarFieldEnum.completionTokens;
    case r'content':
      return Enum$BookRevisionScalarFieldEnum.content;
    case r'createdAt':
      return Enum$BookRevisionScalarFieldEnum.createdAt;
    case r'isRaw':
      return Enum$BookRevisionScalarFieldEnum.isRaw;
    case r'model':
      return Enum$BookRevisionScalarFieldEnum.model;
    case r'promptTokens':
      return Enum$BookRevisionScalarFieldEnum.promptTokens;
    case r'raw':
      return Enum$BookRevisionScalarFieldEnum.raw;
    case r'requestId':
      return Enum$BookRevisionScalarFieldEnum.requestId;
    case r'systemPrompt':
      return Enum$BookRevisionScalarFieldEnum.systemPrompt;
    case r'totalTokens':
      return Enum$BookRevisionScalarFieldEnum.totalTokens;
    case r'updatedAt':
      return Enum$BookRevisionScalarFieldEnum.updatedAt;
    case r'userPrompt':
      return Enum$BookRevisionScalarFieldEnum.userPrompt;
    case r'uuid':
      return Enum$BookRevisionScalarFieldEnum.uuid;
    default:
      return Enum$BookRevisionScalarFieldEnum.$unknown;
  }
}

enum Enum$BookScalarFieldEnum { createdAt, title, updatedAt, uuid, $unknown }

String toJson$Enum$BookScalarFieldEnum(Enum$BookScalarFieldEnum e) {
  switch (e) {
    case Enum$BookScalarFieldEnum.createdAt:
      return r'createdAt';
    case Enum$BookScalarFieldEnum.title:
      return r'title';
    case Enum$BookScalarFieldEnum.updatedAt:
      return r'updatedAt';
    case Enum$BookScalarFieldEnum.uuid:
      return r'uuid';
    case Enum$BookScalarFieldEnum.$unknown:
      return r'$unknown';
  }
}

Enum$BookScalarFieldEnum fromJson$Enum$BookScalarFieldEnum(String value) {
  switch (value) {
    case r'createdAt':
      return Enum$BookScalarFieldEnum.createdAt;
    case r'title':
      return Enum$BookScalarFieldEnum.title;
    case r'updatedAt':
      return Enum$BookScalarFieldEnum.updatedAt;
    case r'uuid':
      return Enum$BookScalarFieldEnum.uuid;
    default:
      return Enum$BookScalarFieldEnum.$unknown;
  }
}

enum Enum$NullsOrder { first, last, $unknown }

String toJson$Enum$NullsOrder(Enum$NullsOrder e) {
  switch (e) {
    case Enum$NullsOrder.first:
      return r'first';
    case Enum$NullsOrder.last:
      return r'last';
    case Enum$NullsOrder.$unknown:
      return r'$unknown';
  }
}

Enum$NullsOrder fromJson$Enum$NullsOrder(String value) {
  switch (value) {
    case r'first':
      return Enum$NullsOrder.first;
    case r'last':
      return Enum$NullsOrder.last;
    default:
      return Enum$NullsOrder.$unknown;
  }
}

enum Enum$QueryMode { $default, insensitive, $unknown }

String toJson$Enum$QueryMode(Enum$QueryMode e) {
  switch (e) {
    case Enum$QueryMode.$default:
      return r'default';
    case Enum$QueryMode.insensitive:
      return r'insensitive';
    case Enum$QueryMode.$unknown:
      return r'$unknown';
  }
}

Enum$QueryMode fromJson$Enum$QueryMode(String value) {
  switch (value) {
    case r'default':
      return Enum$QueryMode.$default;
    case r'insensitive':
      return Enum$QueryMode.insensitive;
    default:
      return Enum$QueryMode.$unknown;
  }
}

enum Enum$SortOrder { asc, desc, $unknown }

String toJson$Enum$SortOrder(Enum$SortOrder e) {
  switch (e) {
    case Enum$SortOrder.asc:
      return r'asc';
    case Enum$SortOrder.desc:
      return r'desc';
    case Enum$SortOrder.$unknown:
      return r'$unknown';
  }
}

Enum$SortOrder fromJson$Enum$SortOrder(String value) {
  switch (value) {
    case r'asc':
      return Enum$SortOrder.asc;
    case r'desc':
      return Enum$SortOrder.desc;
    default:
      return Enum$SortOrder.$unknown;
  }
}

enum Enum$__TypeKind {
  SCALAR,
  OBJECT,
  INTERFACE,
  UNION,
  ENUM,
  INPUT_OBJECT,
  LIST,
  NON_NULL,
  $unknown
}

String toJson$Enum$__TypeKind(Enum$__TypeKind e) {
  switch (e) {
    case Enum$__TypeKind.SCALAR:
      return r'SCALAR';
    case Enum$__TypeKind.OBJECT:
      return r'OBJECT';
    case Enum$__TypeKind.INTERFACE:
      return r'INTERFACE';
    case Enum$__TypeKind.UNION:
      return r'UNION';
    case Enum$__TypeKind.ENUM:
      return r'ENUM';
    case Enum$__TypeKind.INPUT_OBJECT:
      return r'INPUT_OBJECT';
    case Enum$__TypeKind.LIST:
      return r'LIST';
    case Enum$__TypeKind.NON_NULL:
      return r'NON_NULL';
    case Enum$__TypeKind.$unknown:
      return r'$unknown';
  }
}

Enum$__TypeKind fromJson$Enum$__TypeKind(String value) {
  switch (value) {
    case r'SCALAR':
      return Enum$__TypeKind.SCALAR;
    case r'OBJECT':
      return Enum$__TypeKind.OBJECT;
    case r'INTERFACE':
      return Enum$__TypeKind.INTERFACE;
    case r'UNION':
      return Enum$__TypeKind.UNION;
    case r'ENUM':
      return Enum$__TypeKind.ENUM;
    case r'INPUT_OBJECT':
      return Enum$__TypeKind.INPUT_OBJECT;
    case r'LIST':
      return Enum$__TypeKind.LIST;
    case r'NON_NULL':
      return Enum$__TypeKind.NON_NULL;
    default:
      return Enum$__TypeKind.$unknown;
  }
}

enum Enum$__DirectiveLocation {
  QUERY,
  MUTATION,
  SUBSCRIPTION,
  FIELD,
  FRAGMENT_DEFINITION,
  FRAGMENT_SPREAD,
  INLINE_FRAGMENT,
  VARIABLE_DEFINITION,
  SCHEMA,
  SCALAR,
  OBJECT,
  FIELD_DEFINITION,
  ARGUMENT_DEFINITION,
  INTERFACE,
  UNION,
  ENUM,
  ENUM_VALUE,
  INPUT_OBJECT,
  INPUT_FIELD_DEFINITION,
  $unknown
}

String toJson$Enum$__DirectiveLocation(Enum$__DirectiveLocation e) {
  switch (e) {
    case Enum$__DirectiveLocation.QUERY:
      return r'QUERY';
    case Enum$__DirectiveLocation.MUTATION:
      return r'MUTATION';
    case Enum$__DirectiveLocation.SUBSCRIPTION:
      return r'SUBSCRIPTION';
    case Enum$__DirectiveLocation.FIELD:
      return r'FIELD';
    case Enum$__DirectiveLocation.FRAGMENT_DEFINITION:
      return r'FRAGMENT_DEFINITION';
    case Enum$__DirectiveLocation.FRAGMENT_SPREAD:
      return r'FRAGMENT_SPREAD';
    case Enum$__DirectiveLocation.INLINE_FRAGMENT:
      return r'INLINE_FRAGMENT';
    case Enum$__DirectiveLocation.VARIABLE_DEFINITION:
      return r'VARIABLE_DEFINITION';
    case Enum$__DirectiveLocation.SCHEMA:
      return r'SCHEMA';
    case Enum$__DirectiveLocation.SCALAR:
      return r'SCALAR';
    case Enum$__DirectiveLocation.OBJECT:
      return r'OBJECT';
    case Enum$__DirectiveLocation.FIELD_DEFINITION:
      return r'FIELD_DEFINITION';
    case Enum$__DirectiveLocation.ARGUMENT_DEFINITION:
      return r'ARGUMENT_DEFINITION';
    case Enum$__DirectiveLocation.INTERFACE:
      return r'INTERFACE';
    case Enum$__DirectiveLocation.UNION:
      return r'UNION';
    case Enum$__DirectiveLocation.ENUM:
      return r'ENUM';
    case Enum$__DirectiveLocation.ENUM_VALUE:
      return r'ENUM_VALUE';
    case Enum$__DirectiveLocation.INPUT_OBJECT:
      return r'INPUT_OBJECT';
    case Enum$__DirectiveLocation.INPUT_FIELD_DEFINITION:
      return r'INPUT_FIELD_DEFINITION';
    case Enum$__DirectiveLocation.$unknown:
      return r'$unknown';
  }
}

Enum$__DirectiveLocation fromJson$Enum$__DirectiveLocation(String value) {
  switch (value) {
    case r'QUERY':
      return Enum$__DirectiveLocation.QUERY;
    case r'MUTATION':
      return Enum$__DirectiveLocation.MUTATION;
    case r'SUBSCRIPTION':
      return Enum$__DirectiveLocation.SUBSCRIPTION;
    case r'FIELD':
      return Enum$__DirectiveLocation.FIELD;
    case r'FRAGMENT_DEFINITION':
      return Enum$__DirectiveLocation.FRAGMENT_DEFINITION;
    case r'FRAGMENT_SPREAD':
      return Enum$__DirectiveLocation.FRAGMENT_SPREAD;
    case r'INLINE_FRAGMENT':
      return Enum$__DirectiveLocation.INLINE_FRAGMENT;
    case r'VARIABLE_DEFINITION':
      return Enum$__DirectiveLocation.VARIABLE_DEFINITION;
    case r'SCHEMA':
      return Enum$__DirectiveLocation.SCHEMA;
    case r'SCALAR':
      return Enum$__DirectiveLocation.SCALAR;
    case r'OBJECT':
      return Enum$__DirectiveLocation.OBJECT;
    case r'FIELD_DEFINITION':
      return Enum$__DirectiveLocation.FIELD_DEFINITION;
    case r'ARGUMENT_DEFINITION':
      return Enum$__DirectiveLocation.ARGUMENT_DEFINITION;
    case r'INTERFACE':
      return Enum$__DirectiveLocation.INTERFACE;
    case r'UNION':
      return Enum$__DirectiveLocation.UNION;
    case r'ENUM':
      return Enum$__DirectiveLocation.ENUM;
    case r'ENUM_VALUE':
      return Enum$__DirectiveLocation.ENUM_VALUE;
    case r'INPUT_OBJECT':
      return Enum$__DirectiveLocation.INPUT_OBJECT;
    case r'INPUT_FIELD_DEFINITION':
      return Enum$__DirectiveLocation.INPUT_FIELD_DEFINITION;
    default:
      return Enum$__DirectiveLocation.$unknown;
  }
}

const possibleTypesMap = <String, Set<String>>{};
